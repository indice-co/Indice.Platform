//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const CASES_API_BASE_URL = new InjectionToken<string>('CASES_API_BASE_URL');

export interface ICasesApiService {
    /**
     * Download attachment in a PDF format for back-office users.
     * @param api_version (optional)
     * @return Success
     */
    downloadAttachment(attachmentId: string, api_version?: string | undefined): Observable<FileResponse>;
    /**
     * Get case types.
     * @param canCreate (optional) Differentiates between the case types that an admin user can 1) view and 2) select for a case creation
     * @param api_version (optional)
     * @return Success
     */
    getCaseTypes(canCreate?: boolean | undefined, api_version?: string | undefined): Observable<CaseTypePartialResultSet>;
    /**
     * Create new case type.
     * @param api_version (optional)
     * @param body (optional)
     * @return No Content
     */
    createCaseType(api_version?: string | undefined, body?: CaseTypeRequest | undefined): Observable<void>;
    /**
     * Get a specific Case Type by Id.
     * @param caseTypeId The case type Id.
     * @param api_version (optional)
     * @return Success
     */
    getCaseTypeById(caseTypeId: string, api_version?: string | undefined): Observable<CaseType>;
    /**
     * Update a specific Case Type.
     * @param api_version (optional)
     * @param body (optional) The new case type model.
     * @return Success
     */
    updateCaseType(caseTypeId: string, api_version?: string | undefined, body?: CaseTypeRequest | undefined): Observable<CaseType>;
    /**
     * Delete a specific Case Type.
     * @param api_version (optional)
     * @return No Content
     */
    deleteCaseType(caseTypeId: string, api_version?: string | undefined): Observable<void>;
    /**
     * Create a new case in draft mode.
     * @param api_version (optional)
     * @param body (optional) The draft.
     * @return Success
     */
    createDraftAdminCase(api_version?: string | undefined, body?: CreateDraftCaseRequest | undefined): Observable<string>;
    /**
     * Gets the list of all cases using the provided Indice.Types.ListOptions.
     * @param filter_CustomerIds (optional) The Id of the customer to filter.
     * @param filter_CustomerNames (optional) The name of the customer to filter.
     * @param filter_From (optional) The created date of the case, starting from, to filter.
     * @param filter_To (optional) The creation date of the case, ending to, to filter.
     * @param filter_CaseTypeCodes (optional) The list of case type codes to filter.
     * @param filter_CheckpointTypeCodes (optional) The list of checkpoint type codes to filter.
     * @param filter_GroupIds (optional) The list of groupIds to filter.
     * @param filter_Metadata (optional) Construct filter clauses based on the metadata you are adding to the cases in your installation.
     * @param filter_ReferenceNumbers (optional) The reference number of the case to filter.
     * @param filter_Data (optional) Construct filter clauses based on case data.
     * @param filter_IncludeData (optional) Determines whether case data should be included in result.
     * @param page (optional) The current page of the list. Default is Indice.Types.ListOptions.DEFAULT_PAGE.
     * @param size (optional) The size of the list. Default is Indice.Types.ListOptions.DEFAULT_SIZE.
     * @param sort (optional) The property name used to sort the list.
     * @param search (optional) A search term used to limit the results of the list.
     * @param api_version (optional)
     * @return OK
     */
    getCases(filter_CustomerIds?: string[] | undefined, filter_CustomerNames?: string[] | undefined, filter_From?: Date | undefined, filter_To?: Date | undefined, filter_CaseTypeCodes?: string[] | undefined, filter_CheckpointTypeCodes?: string[] | undefined, filter_GroupIds?: string[] | undefined, filter_Metadata?: string[] | undefined, filter_ReferenceNumbers?: string[] | undefined, filter_Data?: string[] | undefined, filter_IncludeData?: boolean | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, api_version?: string | undefined): Observable<CasePartialResultSet>;
    /**
     * Update the case with the business data as defined at the specific case type. This action is allowed only for draft cases.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @param body (optional) The update request.
     * @return No Content
     */
    updateAdminCase(caseId: string, api_version?: string | undefined, body?: UpdateCaseRequest | undefined): Observable<void>;
    /**
     * Gets a case with the specified id.
     * @param caseId The id of the case.
     * @param api_version (optional)
     * @return OK
     */
    getCaseById(caseId: string, api_version?: string | undefined): Observable<Case>;
    /**
     * Deletes a draft case.
     * @param caseId The id of the case.
     * @param api_version (optional)
     * @return No Content
     */
    deleteDraftCase(caseId: string, api_version?: string | undefined): Observable<void>;
    /**
     * Download case in a PDF format.
     * @param caseId The id of the case.
     * @param api_version (optional)
     * @return OK
     */
    downloadCasePdf(caseId: string, api_version?: string | undefined): Observable<FileResponse>;
    /**
     * Gets the cases actions (Approval, edit, assignments, etc) for a case Id. Actions differ based on user role.
     * @param caseId The id of the case.
     * @param api_version (optional)
     * @return OK
     */
    getCaseActions(caseId: string, api_version?: string | undefined): Observable<CaseActions>;
    /**
     * Invoke the approval activity to approve or reject the case.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @param body (optional) The approval request.
     * @return No Content
     */
    submitApproval(caseId: string, api_version?: string | undefined, body?: ApprovalRequest | undefined): Observable<void>;
    /**
     * Invoke the assign activity to assign the case to the caller user.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @return No Content
     */
    assignCase(caseId: string, api_version?: string | undefined): Observable<void>;
    /**
     * Get a list of Attachments for a CaseId
     * @param api_version (optional)
     * @return Success
     */
    getCaseAttachments(caseId: string, api_version?: string | undefined): Observable<CaseAttachmentResultSet>;
    /**
     * Add an attachment to an existing case regardless of its status and mode (draft or not).
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @param file (optional)
     * @return Success
     */
    uploadAdminCaseAttachment(caseId: string, api_version?: string | undefined, file?: FileParameter | undefined): Observable<CasesAttachmentLink>;
    /**
     * Get an Case Attachment
     * @param api_version (optional)
     * @return Success
     */
    getCaseAttachment(caseId: string, attachmentId: string, api_version?: string | undefined): Observable<FileResponse>;
    /**
     * Invoke the edit activity to edit the data of the case.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @param body (optional) The case data in json format.
     * @return No Content
     */
    editCase(caseId: string, api_version?: string | undefined, body?: EditCaseRequest | undefined): Observable<void>;
    /**
     * Get the reject reasons for a case.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @return Success
     */
    getCaseRejectReasons(caseId: string, api_version?: string | undefined): Observable<RejectReason[]>;
    /**
     * Submit the case by removing the draft mode.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @param body (optional) The data of the case.
     * @return No Content
     */
    submitAdminCase(caseId: string, api_version?: string | undefined, body?: any | undefined): Observable<void>;
    /**
     * Gets the timeline entries for a case.
     * @param caseId The id of the case.
     * @param api_version (optional)
     * @return OK
     */
    getCaseTimeline(caseId: string, api_version?: string | undefined): Observable<TimelineEntry[]>;
    /**
     * Invoke the action activity to trigger a business action for the case.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @param body (optional) The action request.
     * @return No Content
     */
    triggerAction(caseId: string, api_version?: string | undefined, body?: ActionRequest | undefined): Observable<void>;
    /**
     * Get the distinct checkpoint types grouped by code
     * @param api_version (optional)
     * @return Success
     */
    getDistinctCheckpointTypes(api_version?: string | undefined): Observable<CheckpointType[]>;
    /**
     * Fetch customers.
     * @param customerId (optional) The Id of the customer as provided by the consumer/integrator.
     * @param caseTypeCode (optional) The case type code, used for filtering customers based on case type (implementantion on client code)
     * @param api_version (optional)
     * @return Success
     */
    getCustomers(customerId?: string | undefined, caseTypeCode?: string | undefined, api_version?: string | undefined): Observable<CustomerDetails[]>;
    /**
     * Fetch customer data for a specific case type code.
     * @param customerId The Id of the customer to the integrator's system.
     * @param caseTypeCode The case type code.
     * @param api_version (optional)
     * @return Success
     */
    getCustomerData(customerId: string, caseTypeCode: string, api_version?: string | undefined): Observable<CustomerData>;
    /**
     * Get a lookup result by lookupName and options.
     * @param lookupName The lookup name that determines the used lookup Service.
     * @param filter_FilterTerms (optional) A list of FilterTerms
     * @param page (optional) The current page of the list. Default is Indice.Types.ListOptions.DEFAULT_PAGE.
     * @param size (optional) The size of the list. Default is Indice.Types.ListOptions.DEFAULT_SIZE.
     * @param sort (optional) The property name used to sort the list.
     * @param search (optional) A search term used to limit the results of the list.
     * @param api_version (optional)
     * @return Success
     */
    getLookup(lookupName: string, filter_FilterTerms?: FilterTerm[] | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, api_version?: string | undefined): Observable<LookupItemResultSet>;
    /**
     * Get the notification subscriptions for a user.
     * @param api_version (optional)
     * @return Success
     */
    getMySubscriptions(api_version?: string | undefined): Observable<NotificationSubscriptionResponse>;
    /**
     * Store user's subscription settings.
     * @param api_version (optional)
     * @param body (optional)
     * @return No Content
     */
    subscribe(api_version?: string | undefined, body?: NotificationSubscriptionRequest | undefined): Observable<void>;
    /**
     * Get saved queries.
     * @param api_version (optional)
     * @return OK
     */
    getQueries(api_version?: string | undefined): Observable<Query[]>;
    /**
     * Save a new query.
     * @param api_version (optional)
     * @param body (optional)
     * @return No Content
     */
    saveQuery(api_version?: string | undefined, body?: SaveQueryRequest | undefined): Observable<void>;
    /**
     * Delete a query.
     * @param queryId The id of the query.
     * @param api_version (optional)
     * @return No Content
     */
    deleteQuery(queryId: string, api_version?: string | undefined): Observable<void>;
    /**
     * Get case report
     * @param reportTag (optional)
     * @param api_version (optional)
     * @return Success
     */
    getCaseReport(reportTag?: ReportTag | undefined, api_version?: string | undefined): Observable<GroupByReportResult[]>;
    /**
     * Gets case types.
     * @param filter_CaseTypeTags (optional) The case type tag filter.
     * @param page (optional) The current page of the list. Default is Indice.Types.ListOptions.DEFAULT_PAGE.
     * @param size (optional) The size of the list. Default is Indice.Types.ListOptions.DEFAULT_SIZE.
     * @param sort (optional) The property name used to sort the list.
     * @param search (optional) A search term used to limit the results of the list.
     * @param api_version (optional)
     * @return Success
     */
    getCaseTypes2(filter_CaseTypeTags?: string[] | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, api_version?: string | undefined): Observable<CaseTypePartialResultSet>;
    /**
     * Gets a case type by its code.
     * @param caseTypeCode The case type code.
     * @param api_version (optional)
     * @return Success
     */
    getCaseType(caseTypeCode: string, api_version?: string | undefined): Observable<CaseTypePartial>;
    /**
     * Get the list of the customer's cases.
     * @param filter_CaseTypeTags (optional) The case type tag filter.
     * @param filter_Statuses (optional) The case status filter.
     * @param filter_CaseTypeCodes (optional) The case type code filter.
     * @param filter_CreatedFrom (optional) The CreatedFrom filter.
     * @param filter_CreatedTo (optional) The CreatedTo filter.
     * @param filter_CompletedFrom (optional) The CompletedFrom filter.
     * @param filter_CompletedTo (optional) The CompletedTo filter.
     * @param filter_Checkpoints (optional) The Checkpoints filter.
     * @param filter_Data (optional) Construct filter clauses based on case data.
     * @param filter_Metadata (optional) Construct filter clauses based on case metadata.
     * @param filter_IncludeDrafts (optional) Determines whether draft cases should be included in result
     * @param filter_ReferenceNumbers (optional) The reference number filter.
     * @param filter_IncludeData (optional) Determines whether case data should be included in result.
     * @param page (optional) The current page of the list. Default is Indice.Types.ListOptions.DEFAULT_PAGE.
     * @param size (optional) The size of the list. Default is Indice.Types.ListOptions.DEFAULT_SIZE.
     * @param sort (optional) The property name used to sort the list.
     * @param search (optional) A search term used to limit the results of the list.
     * @param api_version (optional)
     * @return Success
     */
    getMyCases(filter_CaseTypeTags?: string[] | undefined, filter_Statuses?: CaseStatus[] | undefined, filter_CaseTypeCodes?: string[] | undefined, filter_CreatedFrom?: Date | undefined, filter_CreatedTo?: Date | undefined, filter_CompletedFrom?: Date | undefined, filter_CompletedTo?: Date | undefined, filter_Checkpoints?: string[] | undefined, filter_Data?: string[] | undefined, filter_Metadata?: string[] | undefined, filter_IncludeDrafts?: boolean | undefined, filter_ReferenceNumbers?: number[] | undefined, filter_IncludeData?: boolean | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, api_version?: string | undefined): Observable<MyCasePartialResultSet>;
    /**
     * Create a new case in draft mode. That means no one will be able to edit it besides the creator of the case.
     * @param api_version (optional)
     * @param body (optional) The draft.
     * @return Success
     */
    createDraftCase(api_version?: string | undefined, body?: CreateDraftCaseRequest | undefined): Observable<CreateCaseResponse>;
    /**
     * Get case details by Id.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @return Success
     */
    getMyCaseById(caseId: string, api_version?: string | undefined): Observable<Case>;
    /**
     * Update the case with the business data as defined at the specific case type
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @param body (optional) The update request.
     * @return No Content
     */
    updateCase(caseId: string, api_version?: string | undefined, body?: UpdateCaseRequest | undefined): Observable<void>;
    /**
     * Add an attachment to an existing case regardless of its status and mode (draft or not).
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @param contentType (optional)
     * @param contentDisposition (optional)
     * @param headers (optional)
     * @param length (optional)
     * @param name (optional)
     * @param fileName (optional)
     * @return Success
     */
    uploadCaseAttachment(caseId: string, api_version?: string | undefined, contentType?: string | undefined, contentDisposition?: string | undefined, headers?: { [key: string]: string[]; } | undefined, length?: number | undefined, name?: string | undefined, fileName?: string | undefined): Observable<CasesAttachmentLink>;
    /**
     * Download case in a PDF format
     * @param api_version (optional)
     * @return Success
     */
    downloadMyCasePdf(caseId: string, api_version?: string | undefined): Observable<FileResponse>;
    /**
     * Submit the case by removing the draft mode.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @return No Content
     */
    submitMyCase(caseId: string, api_version?: string | undefined): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class CasesApiService implements ICasesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CASES_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Download attachment in a PDF format for back-office users.
     * @param api_version (optional)
     * @return Success
     */
    downloadAttachment(attachmentId: string, api_version?: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/manage/attachments/{attachmentId}/download?";
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadAttachment(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get case types.
     * @param canCreate (optional) Differentiates between the case types that an admin user can 1) view and 2) select for a case creation
     * @param api_version (optional)
     * @return Success
     */
    getCaseTypes(canCreate?: boolean | undefined, api_version?: string | undefined): Observable<CaseTypePartialResultSet> {
        let url_ = this.baseUrl + "/api/manage/case-types?";
        if (canCreate === null)
            throw new Error("The parameter 'canCreate' cannot be null.");
        else if (canCreate !== undefined)
            url_ += "canCreate=" + encodeURIComponent("" + canCreate) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseTypePartialResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseTypePartialResultSet>;
        }));
    }

    protected processGetCaseTypes(response: HttpResponseBase): Observable<CaseTypePartialResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseTypePartialResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create new case type.
     * @param api_version (optional)
     * @param body (optional)
     * @return No Content
     */
    createCaseType(api_version?: string | undefined, body?: CaseTypeRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/case-types?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCaseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCaseType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateCaseType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get a specific Case Type by Id.
     * @param caseTypeId The case type Id.
     * @param api_version (optional)
     * @return Success
     */
    getCaseTypeById(caseTypeId: string, api_version?: string | undefined): Observable<CaseType> {
        let url_ = this.baseUrl + "/api/manage/case-types/{caseTypeId}?";
        if (caseTypeId === undefined || caseTypeId === null)
            throw new Error("The parameter 'caseTypeId' must be defined.");
        url_ = url_.replace("{caseTypeId}", encodeURIComponent("" + caseTypeId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseType>;
        }));
    }

    protected processGetCaseTypeById(response: HttpResponseBase): Observable<CaseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a specific Case Type.
     * @param api_version (optional)
     * @param body (optional) The new case type model.
     * @return Success
     */
    updateCaseType(caseTypeId: string, api_version?: string | undefined, body?: CaseTypeRequest | undefined): Observable<CaseType> {
        let url_ = this.baseUrl + "/api/manage/case-types/{caseTypeId}?";
        if (caseTypeId === undefined || caseTypeId === null)
            throw new Error("The parameter 'caseTypeId' must be defined.");
        url_ = url_.replace("{caseTypeId}", encodeURIComponent("" + caseTypeId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCaseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCaseType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseType>;
        }));
    }

    protected processUpdateCaseType(response: HttpResponseBase): Observable<CaseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a specific Case Type.
     * @param api_version (optional)
     * @return No Content
     */
    deleteCaseType(caseTypeId: string, api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/case-types/{caseTypeId}?";
        if (caseTypeId === undefined || caseTypeId === null)
            throw new Error("The parameter 'caseTypeId' must be defined.");
        url_ = url_.replace("{caseTypeId}", encodeURIComponent("" + caseTypeId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCaseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCaseType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCaseType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a new case in draft mode.
     * @param api_version (optional)
     * @param body (optional) The draft.
     * @return Success
     */
    createDraftAdminCase(api_version?: string | undefined, body?: CreateDraftCaseRequest | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/manage/cases?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDraftAdminCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDraftAdminCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateDraftAdminCase(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;

            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the list of all cases using the provided Indice.Types.ListOptions.
     * @param filter_CustomerIds (optional) The Id of the customer to filter.
     * @param filter_CustomerNames (optional) The name of the customer to filter.
     * @param filter_From (optional) The created date of the case, starting from, to filter.
     * @param filter_To (optional) The creation date of the case, ending to, to filter.
     * @param filter_CaseTypeCodes (optional) The list of case type codes to filter.
     * @param filter_CheckpointTypeCodes (optional) The list of checkpoint type codes to filter.
     * @param filter_GroupIds (optional) The list of groupIds to filter.
     * @param filter_Metadata (optional) Construct filter clauses based on the metadata you are adding to the cases in your installation.
     * @param filter_ReferenceNumbers (optional) The reference number of the case to filter.
     * @param filter_Data (optional) Construct filter clauses based on case data.
     * @param filter_IncludeData (optional) Determines whether case data should be included in result.
     * @param page (optional) The current page of the list. Default is Indice.Types.ListOptions.DEFAULT_PAGE.
     * @param size (optional) The size of the list. Default is Indice.Types.ListOptions.DEFAULT_SIZE.
     * @param sort (optional) The property name used to sort the list.
     * @param search (optional) A search term used to limit the results of the list.
     * @param api_version (optional)
     * @return OK
     */
    getCases(filter_CustomerIds?: string[] | undefined, filter_CustomerNames?: string[] | undefined, filter_From?: Date | undefined, filter_To?: Date | undefined, filter_CaseTypeCodes?: string[] | undefined, filter_CheckpointTypeCodes?: string[] | undefined, filter_GroupIds?: string[] | undefined, filter_Metadata?: string[] | undefined, filter_ReferenceNumbers?: string[] | undefined, filter_Data?: string[] | undefined, filter_IncludeData?: boolean | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, api_version?: string | undefined): Observable<CasePartialResultSet> {
        let url_ = this.baseUrl + "/api/manage/cases?";
        if (filter_CustomerIds === null)
            throw new Error("The parameter 'filter_CustomerIds' cannot be null.");
        else if (filter_CustomerIds !== undefined)
            filter_CustomerIds && filter_CustomerIds.forEach(item => { url_ += "Filter.CustomerIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter_CustomerNames === null)
            throw new Error("The parameter 'filter_CustomerNames' cannot be null.");
        else if (filter_CustomerNames !== undefined)
            filter_CustomerNames && filter_CustomerNames.forEach(item => { url_ += "Filter.CustomerNames=" + encodeURIComponent("" + item) + "&"; });
        if (filter_From === null)
            throw new Error("The parameter 'filter_From' cannot be null.");
        else if (filter_From !== undefined)
            url_ += "Filter.From=" + encodeURIComponent(filter_From ? "" + filter_From.toISOString() : "") + "&";
        if (filter_To === null)
            throw new Error("The parameter 'filter_To' cannot be null.");
        else if (filter_To !== undefined)
            url_ += "Filter.To=" + encodeURIComponent(filter_To ? "" + filter_To.toISOString() : "") + "&";
        if (filter_CaseTypeCodes === null)
            throw new Error("The parameter 'filter_CaseTypeCodes' cannot be null.");
        else if (filter_CaseTypeCodes !== undefined)
            filter_CaseTypeCodes && filter_CaseTypeCodes.forEach(item => { url_ += "Filter.CaseTypeCodes=" + encodeURIComponent("" + item) + "&"; });
        if (filter_CheckpointTypeCodes === null)
            throw new Error("The parameter 'filter_CheckpointTypeCodes' cannot be null.");
        else if (filter_CheckpointTypeCodes !== undefined)
            filter_CheckpointTypeCodes && filter_CheckpointTypeCodes.forEach(item => { url_ += "Filter.CheckpointTypeCodes=" + encodeURIComponent("" + item) + "&"; });
        if (filter_GroupIds === null)
            throw new Error("The parameter 'filter_GroupIds' cannot be null.");
        else if (filter_GroupIds !== undefined)
            filter_GroupIds && filter_GroupIds.forEach(item => { url_ += "Filter.GroupIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter_Metadata === null)
            throw new Error("The parameter 'filter_Metadata' cannot be null.");
        else if (filter_Metadata !== undefined)
            filter_Metadata && filter_Metadata.forEach(item => { url_ += "Filter.Metadata=" + encodeURIComponent("" + item) + "&"; });
        if (filter_ReferenceNumbers === null)
            throw new Error("The parameter 'filter_ReferenceNumbers' cannot be null.");
        else if (filter_ReferenceNumbers !== undefined)
            filter_ReferenceNumbers && filter_ReferenceNumbers.forEach(item => { url_ += "Filter.ReferenceNumbers=" + encodeURIComponent("" + item) + "&"; });
        if (filter_Data === null)
            throw new Error("The parameter 'filter_Data' cannot be null.");
        else if (filter_Data !== undefined)
            filter_Data && filter_Data.forEach(item => { url_ += "Filter.Data=" + encodeURIComponent("" + item) + "&"; });
        if (filter_IncludeData === null)
            throw new Error("The parameter 'filter_IncludeData' cannot be null.");
        else if (filter_IncludeData !== undefined)
            url_ += "Filter.IncludeData=" + encodeURIComponent("" + filter_IncludeData) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCases(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCases(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CasePartialResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CasePartialResultSet>;
        }));
    }

    protected processGetCases(response: HttpResponseBase): Observable<CasePartialResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CasePartialResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update the case with the business data as defined at the specific case type. This action is allowed only for draft cases.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @param body (optional) The update request.
     * @return No Content
     */
    updateAdminCase(caseId: string, api_version?: string | undefined, body?: UpdateCaseRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAdminCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAdminCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAdminCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a case with the specified id.
     * @param caseId The id of the case.
     * @param api_version (optional)
     * @return OK
     */
    getCaseById(caseId: string, api_version?: string | undefined): Observable<Case> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Case>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Case>;
        }));
    }

    protected processGetCaseById(response: HttpResponseBase): Observable<Case> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Case.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Deletes a draft case.
     * @param caseId The id of the case.
     * @param api_version (optional)
     * @return No Content
     */
    deleteDraftCase(caseId: string, api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDraftCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDraftCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDraftCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Download case in a PDF format.
     * @param caseId The id of the case.
     * @param api_version (optional)
     * @return OK
     */
    downloadCasePdf(caseId: string, api_version?: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}.pdf?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/pdf"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadCasePdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadCasePdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadCasePdf(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the cases actions (Approval, edit, assignments, etc) for a case Id. Actions differ based on user role.
     * @param caseId The id of the case.
     * @param api_version (optional)
     * @return OK
     */
    getCaseActions(caseId: string, api_version?: string | undefined): Observable<CaseActions> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/actions?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseActions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseActions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseActions>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseActions>;
        }));
    }

    protected processGetCaseActions(response: HttpResponseBase): Observable<CaseActions> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseActions.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Invoke the approval activity to approve or reject the case.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @param body (optional) The approval request.
     * @return No Content
     */
    submitApproval(caseId: string, api_version?: string | undefined, body?: ApprovalRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/approve?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitApproval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitApproval(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitApproval(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Invoke the assign activity to assign the case to the caller user.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @return No Content
     */
    assignCase(caseId: string, api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/assign?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssignCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get a list of Attachments for a CaseId
     * @param api_version (optional)
     * @return Success
     */
    getCaseAttachments(caseId: string, api_version?: string | undefined): Observable<CaseAttachmentResultSet> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/attachments?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseAttachmentResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseAttachmentResultSet>;
        }));
    }

    protected processGetCaseAttachments(response: HttpResponseBase): Observable<CaseAttachmentResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseAttachmentResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Add an attachment to an existing case regardless of its status and mode (draft or not).
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @param file (optional)
     * @return Success
     */
    uploadAdminCaseAttachment(caseId: string, api_version?: string | undefined, file?: FileParameter | undefined): Observable<CasesAttachmentLink> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/attachments?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadAdminCaseAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadAdminCaseAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CasesAttachmentLink>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CasesAttachmentLink>;
        }));
    }

    protected processUploadAdminCaseAttachment(response: HttpResponseBase): Observable<CasesAttachmentLink> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CasesAttachmentLink.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get an Case Attachment
     * @param api_version (optional)
     * @return Success
     */
    getCaseAttachment(caseId: string, attachmentId: string, api_version?: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/attachments/{attachmentId}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetCaseAttachment(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Invoke the edit activity to edit the data of the case.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @param body (optional) The case data in json format.
     * @return No Content
     */
    editCase(caseId: string, api_version?: string | undefined, body?: EditCaseRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/edit?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get the reject reasons for a case.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @return Success
     */
    getCaseRejectReasons(caseId: string, api_version?: string | undefined): Observable<RejectReason[]> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/reject-reasons?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseRejectReasons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseRejectReasons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RejectReason[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RejectReason[]>;
        }));
    }

    protected processGetCaseRejectReasons(response: HttpResponseBase): Observable<RejectReason[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RejectReason.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Submit the case by removing the draft mode.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @param body (optional) The data of the case.
     * @return No Content
     */
    submitAdminCase(caseId: string, api_version?: string | undefined, body?: any | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/submit?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitAdminCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitAdminCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitAdminCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the timeline entries for a case.
     * @param caseId The id of the case.
     * @param api_version (optional)
     * @return OK
     */
    getCaseTimeline(caseId: string, api_version?: string | undefined): Observable<TimelineEntry[]> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/timeline?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseTimeline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseTimeline(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimelineEntry[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimelineEntry[]>;
        }));
    }

    protected processGetCaseTimeline(response: HttpResponseBase): Observable<TimelineEntry[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TimelineEntry.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Invoke the action activity to trigger a business action for the case.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @param body (optional) The action request.
     * @return No Content
     */
    triggerAction(caseId: string, api_version?: string | undefined, body?: ActionRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/trigger-action?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTriggerAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTriggerAction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTriggerAction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get the distinct checkpoint types grouped by code
     * @param api_version (optional)
     * @return Success
     */
    getDistinctCheckpointTypes(api_version?: string | undefined): Observable<CheckpointType[]> {
        let url_ = this.baseUrl + "/api/manage/checkpoint-types?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDistinctCheckpointTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDistinctCheckpointTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckpointType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckpointType[]>;
        }));
    }

    protected processGetDistinctCheckpointTypes(response: HttpResponseBase): Observable<CheckpointType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CheckpointType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Fetch customers.
     * @param customerId (optional) The Id of the customer as provided by the consumer/integrator.
     * @param caseTypeCode (optional) The case type code, used for filtering customers based on case type (implementantion on client code)
     * @param api_version (optional)
     * @return Success
     */
    getCustomers(customerId?: string | undefined, caseTypeCode?: string | undefined, api_version?: string | undefined): Observable<CustomerDetails[]> {
        let url_ = this.baseUrl + "/api/manage/integrations/customers?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (caseTypeCode === null)
            throw new Error("The parameter 'caseTypeCode' cannot be null.");
        else if (caseTypeCode !== undefined)
            url_ += "CaseTypeCode=" + encodeURIComponent("" + caseTypeCode) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDetails[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDetails[]>;
        }));
    }

    protected processGetCustomers(response: HttpResponseBase): Observable<CustomerDetails[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerDetails.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Fetch customer data for a specific case type code.
     * @param customerId The Id of the customer to the integrator's system.
     * @param caseTypeCode The case type code.
     * @param api_version (optional)
     * @return Success
     */
    getCustomerData(customerId: string, caseTypeCode: string, api_version?: string | undefined): Observable<CustomerData> {
        let url_ = this.baseUrl + "/api/manage/integrations/customers/{customerId}/data/{caseTypeCode}?";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        if (caseTypeCode === undefined || caseTypeCode === null)
            throw new Error("The parameter 'caseTypeCode' must be defined.");
        url_ = url_.replace("{caseTypeCode}", encodeURIComponent("" + caseTypeCode));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerData>;
        }));
    }

    protected processGetCustomerData(response: HttpResponseBase): Observable<CustomerData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get a lookup result by lookupName and options.
     * @param lookupName The lookup name that determines the used lookup Service.
     * @param filter_FilterTerms (optional) A list of FilterTerms
     * @param page (optional) The current page of the list. Default is Indice.Types.ListOptions.DEFAULT_PAGE.
     * @param size (optional) The size of the list. Default is Indice.Types.ListOptions.DEFAULT_SIZE.
     * @param sort (optional) The property name used to sort the list.
     * @param search (optional) A search term used to limit the results of the list.
     * @param api_version (optional)
     * @return Success
     */
    getLookup(lookupName: string, filter_FilterTerms?: FilterTerm[] | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, api_version?: string | undefined): Observable<LookupItemResultSet> {
        let url_ = this.baseUrl + "/api/manage/lookups/{lookupName}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (filter_FilterTerms === null)
            throw new Error("The parameter 'filter_FilterTerms' cannot be null.");
        else if (filter_FilterTerms !== undefined)
            filter_FilterTerms && filter_FilterTerms.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filter.FilterTerms[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupItemResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupItemResultSet>;
        }));
    }

    protected processGetLookup(response: HttpResponseBase): Observable<LookupItemResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LookupItemResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get the notification subscriptions for a user.
     * @param api_version (optional)
     * @return Success
     */
    getMySubscriptions(api_version?: string | undefined): Observable<NotificationSubscriptionResponse> {
        let url_ = this.baseUrl + "/api/manage/my/notifications?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMySubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMySubscriptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationSubscriptionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationSubscriptionResponse>;
        }));
    }

    protected processGetMySubscriptions(response: HttpResponseBase): Observable<NotificationSubscriptionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationSubscriptionResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Store user's subscription settings.
     * @param api_version (optional)
     * @param body (optional)
     * @return No Content
     */
    subscribe(api_version?: string | undefined, body?: NotificationSubscriptionRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/my/notifications?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscribe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscribe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubscribe(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get saved queries.
     * @param api_version (optional)
     * @return OK
     */
    getQueries(api_version?: string | undefined): Observable<Query[]> {
        let url_ = this.baseUrl + "/api/manage/queries?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQueries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQueries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Query[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Query[]>;
        }));
    }

    protected processGetQueries(response: HttpResponseBase): Observable<Query[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Query.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Save a new query.
     * @param api_version (optional)
     * @param body (optional)
     * @return No Content
     */
    saveQuery(api_version?: string | undefined, body?: SaveQueryRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/queries?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveQuery(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a query.
     * @param queryId The id of the query.
     * @param api_version (optional)
     * @return No Content
     */
    deleteQuery(queryId: string, api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/queries/{queryId}?";
        if (queryId === undefined || queryId === null)
            throw new Error("The parameter 'queryId' must be defined.");
        url_ = url_.replace("{queryId}", encodeURIComponent("" + queryId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteQuery(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get case report
     * @param reportTag (optional)
     * @param api_version (optional)
     * @return Success
     */
    getCaseReport(reportTag?: ReportTag | undefined, api_version?: string | undefined): Observable<GroupByReportResult[]> {
        let url_ = this.baseUrl + "/api/manage/reports?";
        if (reportTag === null)
            throw new Error("The parameter 'reportTag' cannot be null.");
        else if (reportTag !== undefined)
            url_ += "reportTag=" + encodeURIComponent("" + reportTag) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GroupByReportResult[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GroupByReportResult[]>;
        }));
    }

    protected processGetCaseReport(response: HttpResponseBase): Observable<GroupByReportResult[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupByReportResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets case types.
     * @param filter_CaseTypeTags (optional) The case type tag filter.
     * @param page (optional) The current page of the list. Default is Indice.Types.ListOptions.DEFAULT_PAGE.
     * @param size (optional) The size of the list. Default is Indice.Types.ListOptions.DEFAULT_SIZE.
     * @param sort (optional) The property name used to sort the list.
     * @param search (optional) A search term used to limit the results of the list.
     * @param api_version (optional)
     * @return Success
     */
    getCaseTypes2(filter_CaseTypeTags?: string[] | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, api_version?: string | undefined): Observable<CaseTypePartialResultSet> {
        let url_ = this.baseUrl + "/api/my/case-types?";
        if (filter_CaseTypeTags === null)
            throw new Error("The parameter 'filter_CaseTypeTags' cannot be null.");
        else if (filter_CaseTypeTags !== undefined)
            filter_CaseTypeTags && filter_CaseTypeTags.forEach(item => { url_ += "Filter.CaseTypeTags=" + encodeURIComponent("" + item) + "&"; });
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseTypes2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseTypes2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseTypePartialResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseTypePartialResultSet>;
        }));
    }

    protected processGetCaseTypes2(response: HttpResponseBase): Observable<CaseTypePartialResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseTypePartialResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a case type by its code.
     * @param caseTypeCode The case type code.
     * @param api_version (optional)
     * @return Success
     */
    getCaseType(caseTypeCode: string, api_version?: string | undefined): Observable<CaseTypePartial> {
        let url_ = this.baseUrl + "/api/my/case-types/{caseTypeCode}?";
        if (caseTypeCode === undefined || caseTypeCode === null)
            throw new Error("The parameter 'caseTypeCode' must be defined.");
        url_ = url_.replace("{caseTypeCode}", encodeURIComponent("" + caseTypeCode));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseTypePartial>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseTypePartial>;
        }));
    }

    protected processGetCaseType(response: HttpResponseBase): Observable<CaseTypePartial> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseTypePartial.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get the list of the customer's cases.
     * @param filter_CaseTypeTags (optional) The case type tag filter.
     * @param filter_Statuses (optional) The case status filter.
     * @param filter_CaseTypeCodes (optional) The case type code filter.
     * @param filter_CreatedFrom (optional) The CreatedFrom filter.
     * @param filter_CreatedTo (optional) The CreatedTo filter.
     * @param filter_CompletedFrom (optional) The CompletedFrom filter.
     * @param filter_CompletedTo (optional) The CompletedTo filter.
     * @param filter_Checkpoints (optional) The Checkpoints filter.
     * @param filter_Data (optional) Construct filter clauses based on case data.
     * @param filter_Metadata (optional) Construct filter clauses based on case metadata.
     * @param filter_IncludeDrafts (optional) Determines whether draft cases should be included in result
     * @param filter_ReferenceNumbers (optional) The reference number filter.
     * @param filter_IncludeData (optional) Determines whether case data should be included in result.
     * @param page (optional) The current page of the list. Default is Indice.Types.ListOptions.DEFAULT_PAGE.
     * @param size (optional) The size of the list. Default is Indice.Types.ListOptions.DEFAULT_SIZE.
     * @param sort (optional) The property name used to sort the list.
     * @param search (optional) A search term used to limit the results of the list.
     * @param api_version (optional)
     * @return Success
     */
    getMyCases(filter_CaseTypeTags?: string[] | undefined, filter_Statuses?: CaseStatus[] | undefined, filter_CaseTypeCodes?: string[] | undefined, filter_CreatedFrom?: Date | undefined, filter_CreatedTo?: Date | undefined, filter_CompletedFrom?: Date | undefined, filter_CompletedTo?: Date | undefined, filter_Checkpoints?: string[] | undefined, filter_Data?: string[] | undefined, filter_Metadata?: string[] | undefined, filter_IncludeDrafts?: boolean | undefined, filter_ReferenceNumbers?: number[] | undefined, filter_IncludeData?: boolean | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, api_version?: string | undefined): Observable<MyCasePartialResultSet> {
        let url_ = this.baseUrl + "/api/my/cases?";
        if (filter_CaseTypeTags === null)
            throw new Error("The parameter 'filter_CaseTypeTags' cannot be null.");
        else if (filter_CaseTypeTags !== undefined)
            filter_CaseTypeTags && filter_CaseTypeTags.forEach(item => { url_ += "Filter.CaseTypeTags=" + encodeURIComponent("" + item) + "&"; });
        if (filter_Statuses === null)
            throw new Error("The parameter 'filter_Statuses' cannot be null.");
        else if (filter_Statuses !== undefined)
            filter_Statuses && filter_Statuses.forEach(item => { url_ += "Filter.Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (filter_CaseTypeCodes === null)
            throw new Error("The parameter 'filter_CaseTypeCodes' cannot be null.");
        else if (filter_CaseTypeCodes !== undefined)
            filter_CaseTypeCodes && filter_CaseTypeCodes.forEach(item => { url_ += "Filter.CaseTypeCodes=" + encodeURIComponent("" + item) + "&"; });
        if (filter_CreatedFrom === null)
            throw new Error("The parameter 'filter_CreatedFrom' cannot be null.");
        else if (filter_CreatedFrom !== undefined)
            url_ += "Filter.CreatedFrom=" + encodeURIComponent(filter_CreatedFrom ? "" + filter_CreatedFrom.toISOString() : "") + "&";
        if (filter_CreatedTo === null)
            throw new Error("The parameter 'filter_CreatedTo' cannot be null.");
        else if (filter_CreatedTo !== undefined)
            url_ += "Filter.CreatedTo=" + encodeURIComponent(filter_CreatedTo ? "" + filter_CreatedTo.toISOString() : "") + "&";
        if (filter_CompletedFrom === null)
            throw new Error("The parameter 'filter_CompletedFrom' cannot be null.");
        else if (filter_CompletedFrom !== undefined)
            url_ += "Filter.CompletedFrom=" + encodeURIComponent(filter_CompletedFrom ? "" + filter_CompletedFrom.toISOString() : "") + "&";
        if (filter_CompletedTo === null)
            throw new Error("The parameter 'filter_CompletedTo' cannot be null.");
        else if (filter_CompletedTo !== undefined)
            url_ += "Filter.CompletedTo=" + encodeURIComponent(filter_CompletedTo ? "" + filter_CompletedTo.toISOString() : "") + "&";
        if (filter_Checkpoints === null)
            throw new Error("The parameter 'filter_Checkpoints' cannot be null.");
        else if (filter_Checkpoints !== undefined)
            filter_Checkpoints && filter_Checkpoints.forEach(item => { url_ += "Filter.Checkpoints=" + encodeURIComponent("" + item) + "&"; });
        if (filter_Data === null)
            throw new Error("The parameter 'filter_Data' cannot be null.");
        else if (filter_Data !== undefined)
            filter_Data && filter_Data.forEach(item => { url_ += "Filter.Data=" + encodeURIComponent("" + item) + "&"; });
        if (filter_Metadata === null)
            throw new Error("The parameter 'filter_Metadata' cannot be null.");
        else if (filter_Metadata !== undefined)
            filter_Metadata && filter_Metadata.forEach(item => { url_ += "Filter.Metadata=" + encodeURIComponent("" + item) + "&"; });
        if (filter_IncludeDrafts === null)
            throw new Error("The parameter 'filter_IncludeDrafts' cannot be null.");
        else if (filter_IncludeDrafts !== undefined)
            url_ += "Filter.IncludeDrafts=" + encodeURIComponent("" + filter_IncludeDrafts) + "&";
        if (filter_ReferenceNumbers === null)
            throw new Error("The parameter 'filter_ReferenceNumbers' cannot be null.");
        else if (filter_ReferenceNumbers !== undefined)
            filter_ReferenceNumbers && filter_ReferenceNumbers.forEach(item => { url_ += "Filter.ReferenceNumbers=" + encodeURIComponent("" + item) + "&"; });
        if (filter_IncludeData === null)
            throw new Error("The parameter 'filter_IncludeData' cannot be null.");
        else if (filter_IncludeData !== undefined)
            url_ += "Filter.IncludeData=" + encodeURIComponent("" + filter_IncludeData) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyCases(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyCases(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MyCasePartialResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MyCasePartialResultSet>;
        }));
    }

    protected processGetMyCases(response: HttpResponseBase): Observable<MyCasePartialResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MyCasePartialResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a new case in draft mode. That means no one will be able to edit it besides the creator of the case.
     * @param api_version (optional)
     * @param body (optional) The draft.
     * @return Success
     */
    createDraftCase(api_version?: string | undefined, body?: CreateDraftCaseRequest | undefined): Observable<CreateCaseResponse> {
        let url_ = this.baseUrl + "/api/my/cases?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDraftCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDraftCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateCaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateCaseResponse>;
        }));
    }

    protected processCreateDraftCase(response: HttpResponseBase): Observable<CreateCaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateCaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get case details by Id.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @return Success
     */
    getMyCaseById(caseId: string, api_version?: string | undefined): Observable<Case> {
        let url_ = this.baseUrl + "/api/my/cases/{caseId}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyCaseById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyCaseById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Case>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Case>;
        }));
    }

    protected processGetMyCaseById(response: HttpResponseBase): Observable<Case> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Case.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update the case with the business data as defined at the specific case type
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @param body (optional) The update request.
     * @return No Content
     */
    updateCase(caseId: string, api_version?: string | undefined, body?: UpdateCaseRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/my/cases/{caseId}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Add an attachment to an existing case regardless of its status and mode (draft or not).
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @param contentType (optional)
     * @param contentDisposition (optional)
     * @param headers (optional)
     * @param length (optional)
     * @param name (optional)
     * @param fileName (optional)
     * @return Success
     */
    uploadCaseAttachment(caseId: string, api_version?: string | undefined, contentType?: string | undefined, contentDisposition?: string | undefined, headers?: { [key: string]: string[]; } | undefined, length?: number | undefined, name?: string | undefined, fileName?: string | undefined): Observable<CasesAttachmentLink> {
        let url_ = this.baseUrl + "/api/my/cases/{caseId}/attachments?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            content_.append("Headers", JSON.stringify(headers));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileName === null || fileName === undefined)
            throw new Error("The parameter 'fileName' cannot be null.");
        else
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadCaseAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadCaseAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CasesAttachmentLink>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CasesAttachmentLink>;
        }));
    }

    protected processUploadCaseAttachment(response: HttpResponseBase): Observable<CasesAttachmentLink> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CasesAttachmentLink.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Download case in a PDF format
     * @param api_version (optional)
     * @return Success
     */
    downloadMyCasePdf(caseId: string, api_version?: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/my/cases/{caseId}/download?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/pdf"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadMyCasePdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadMyCasePdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadMyCasePdf(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Submit the case by removing the draft mode.
     * @param caseId The Id of the case.
     * @param api_version (optional)
     * @return No Content
     */
    submitMyCase(caseId: string, api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/my/cases/{caseId}/submit?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitMyCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitMyCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitMyCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

/** The request that triggers an action. */
export class ActionRequest implements IActionRequest {
    /** The Id of the action. */
    id?: string;
    /** The value of the action (non-required). */
    value?: string | undefined;

    constructor(data?: IActionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ActionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ActionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data;
    }
}

/** The request that triggers an action. */
export interface IActionRequest {
    /** The Id of the action. */
    id?: string;
    /** The value of the action (non-required). */
    value?: string | undefined;
}

/** The Approval action for a Case. */
export enum Approval {
    Approve = "Approve",
    Reject = "Reject",
}

/** The approval request to trigger the Indice.Features.Cases.Workflows.Activities.AwaitApprovalActivity */
export class ApprovalRequest implements IApprovalRequest {
    action?: Approval;
    /** User comment related to the action. */
    comment?: string | undefined;

    constructor(data?: IApprovalRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): ApprovalRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["comment"] = this.comment;
        return data;
    }
}

/** The approval request to trigger the Indice.Features.Cases.Workflows.Activities.AwaitApprovalActivity */
export interface IApprovalRequest {
    action?: Approval;
    /** User comment related to the action. */
    comment?: string | undefined;
}

/** Audit metadata related with the user principal that "did" the action. */
export class AuditMeta implements IAuditMeta {
    /** The Id of the user. */
    id?: string | undefined;
    /** The name of the user. */
    name?: string | undefined;
    /** The email of the user. */
    email?: string | undefined;
    /** The timestamp the audit happened. */
    when?: Date | undefined;

    constructor(data?: IAuditMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.when = _data["when"] ? new Date(_data["when"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditMeta {
        data = typeof data === 'object' ? data : {};
        let result = new AuditMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["when"] = this.when ? this.when.toISOString() : <any>undefined;
        return data;
    }
}

/** Audit metadata related with the user principal that "did" the action. */
export interface IAuditMeta {
    /** The Id of the user. */
    id?: string | undefined;
    /** The name of the user. */
    name?: string | undefined;
    /** The email of the user. */
    email?: string | undefined;
    /** The timestamp the audit happened. */
    when?: Date | undefined;
}

/** Models case details. */
export class Case implements ICase {
    /** The Id of the case. */
    id?: string;
    /** The reference number of this case if it has one. */
    referenceNumber?: number | undefined;
    /** The Id of the customer as provided from integration services (core or 3rd party). */
    customerId?: string | undefined;
    /** The Id of the user as provided from our Identity server. */
    userId?: string | undefined;
    /** The full name of the customer. */
    customerName?: string | undefined;
    /** The created date of the case. */
    createdByWhen?: Date | undefined;
    /** The Id of the user that created the case. */
    createdById?: string | undefined;
    /** The email of the user that created the case. */
    createdByEmail?: string | undefined;
    /** The full name of the user that created the case. */
    createdByName?: string | undefined;
    caseType?: CaseTypePartial;
    /** The case metadata as provided from the client or integrator. */
    metadata?: { [key: string]: string; } | undefined;
    /** The Id of the group the case belongs. */
    groupId?: string | undefined;
    checkpointType?: CheckpointType;
    /** The json data of the case. */
    data?: any | undefined;
    /** The name of the user that has the case assigned. */
    assignedToName?: string | undefined;
    /** The channel of th case. */
    channel?: string | undefined;
    /** Indicate if the case is in draft mode. */
    draft?: boolean;
    /** The attachments of the case. */
    attachments?: CaseAttachment[] | undefined;
    /** The back-office users that approved the case. */
    approvers?: AuditMeta[] | undefined;

    constructor(data?: ICase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.referenceNumber = _data["referenceNumber"];
            this.customerId = _data["customerId"];
            this.userId = _data["userId"];
            this.customerName = _data["customerName"];
            this.createdByWhen = _data["createdByWhen"] ? new Date(_data["createdByWhen"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.createdByEmail = _data["createdByEmail"];
            this.createdByName = _data["createdByName"];
            this.caseType = _data["caseType"] ? CaseTypePartial.fromJS(_data["caseType"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.groupId = _data["groupId"];
            this.checkpointType = _data["checkpointType"] ? CheckpointType.fromJS(_data["checkpointType"]) : <any>undefined;
            this.data = _data["data"];
            this.assignedToName = _data["assignedToName"];
            this.channel = _data["channel"];
            this.draft = _data["draft"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(CaseAttachment.fromJS(item));
            }
            if (Array.isArray(_data["approvers"])) {
                this.approvers = [] as any;
                for (let item of _data["approvers"])
                    this.approvers!.push(AuditMeta.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Case {
        data = typeof data === 'object' ? data : {};
        let result = new Case();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["referenceNumber"] = this.referenceNumber;
        data["customerId"] = this.customerId;
        data["userId"] = this.userId;
        data["customerName"] = this.customerName;
        data["createdByWhen"] = this.createdByWhen ? this.createdByWhen.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["createdByEmail"] = this.createdByEmail;
        data["createdByName"] = this.createdByName;
        data["caseType"] = this.caseType ? this.caseType.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["groupId"] = this.groupId;
        data["checkpointType"] = this.checkpointType ? this.checkpointType.toJSON() : <any>undefined;
        data["data"] = this.data;
        data["assignedToName"] = this.assignedToName;
        data["channel"] = this.channel;
        data["draft"] = this.draft;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.approvers)) {
            data["approvers"] = [];
            for (let item of this.approvers)
                data["approvers"].push(item.toJSON());
        }
        return data;
    }
}

/** Models case details. */
export interface ICase {
    /** The Id of the case. */
    id?: string;
    /** The reference number of this case if it has one. */
    referenceNumber?: number | undefined;
    /** The Id of the customer as provided from integration services (core or 3rd party). */
    customerId?: string | undefined;
    /** The Id of the user as provided from our Identity server. */
    userId?: string | undefined;
    /** The full name of the customer. */
    customerName?: string | undefined;
    /** The created date of the case. */
    createdByWhen?: Date | undefined;
    /** The Id of the user that created the case. */
    createdById?: string | undefined;
    /** The email of the user that created the case. */
    createdByEmail?: string | undefined;
    /** The full name of the user that created the case. */
    createdByName?: string | undefined;
    caseType?: CaseTypePartial;
    /** The case metadata as provided from the client or integrator. */
    metadata?: { [key: string]: string; } | undefined;
    /** The Id of the group the case belongs. */
    groupId?: string | undefined;
    checkpointType?: CheckpointType;
    /** The json data of the case. */
    data?: any | undefined;
    /** The name of the user that has the case assigned. */
    assignedToName?: string | undefined;
    /** The channel of th case. */
    channel?: string | undefined;
    /** Indicate if the case is in draft mode. */
    draft?: boolean;
    /** The attachments of the case. */
    attachments?: CaseAttachment[] | undefined;
    /** The back-office users that approved the case. */
    approvers?: AuditMeta[] | undefined;
}

/** The available actions for a user, depending on his role and checkpoint of the case. */
export class CaseActions implements ICaseActions {
    /** User can assign the case to himself. */
    hasAssignment?: boolean;
    /** User can remove the assignment of the case. */
    hasUnassignment?: boolean;
    /** User can edit the case data. */
    hasEdit?: boolean;
    /** User can approve/reject the case. */
    hasApproval?: boolean;
    /** The list of custom action blocking activities that will generate the corresponding components. */
    customActions?: CustomCaseAction[] | undefined;

    constructor(data?: ICaseActions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasAssignment = _data["hasAssignment"];
            this.hasUnassignment = _data["hasUnassignment"];
            this.hasEdit = _data["hasEdit"];
            this.hasApproval = _data["hasApproval"];
            if (Array.isArray(_data["customActions"])) {
                this.customActions = [] as any;
                for (let item of _data["customActions"])
                    this.customActions!.push(CustomCaseAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CaseActions {
        data = typeof data === 'object' ? data : {};
        let result = new CaseActions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasAssignment"] = this.hasAssignment;
        data["hasUnassignment"] = this.hasUnassignment;
        data["hasEdit"] = this.hasEdit;
        data["hasApproval"] = this.hasApproval;
        if (Array.isArray(this.customActions)) {
            data["customActions"] = [];
            for (let item of this.customActions)
                data["customActions"].push(item.toJSON());
        }
        return data;
    }
}

/** The available actions for a user, depending on his role and checkpoint of the case. */
export interface ICaseActions {
    /** User can assign the case to himself. */
    hasAssignment?: boolean;
    /** User can remove the assignment of the case. */
    hasUnassignment?: boolean;
    /** User can edit the case data. */
    hasEdit?: boolean;
    /** User can approve/reject the case. */
    hasApproval?: boolean;
    /** The list of custom action blocking activities that will generate the corresponding components. */
    customActions?: CustomCaseAction[] | undefined;
}

/** Minimal Case Attachment response model. */
export class CaseAttachment implements ICaseAttachment {
    /** The Id of the attachment. */
    id?: string;
    /** The name of the attachment. */
    name?: string | undefined;
    /** The content type of the attachment. */
    contentType?: string | undefined;
    /** The extension of the attachment. */
    extension?: string | undefined;
    /** The binary data of the attachment. */
    data?: string | undefined;

    constructor(data?: ICaseAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.contentType = _data["contentType"];
            this.extension = _data["extension"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): CaseAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new CaseAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["contentType"] = this.contentType;
        data["extension"] = this.extension;
        data["data"] = this.data;
        return data;
    }
}

/** Minimal Case Attachment response model. */
export interface ICaseAttachment {
    /** The Id of the attachment. */
    id?: string;
    /** The name of the attachment. */
    name?: string | undefined;
    /** The content type of the attachment. */
    contentType?: string | undefined;
    /** The extension of the attachment. */
    extension?: string | undefined;
    /** The binary data of the attachment. */
    data?: string | undefined;
}

/**  collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export class CaseAttachmentResultSet implements ICaseAttachmentResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: CaseAttachment[] | undefined;

    constructor(data?: ICaseAttachmentResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CaseAttachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CaseAttachmentResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new CaseAttachmentResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/**  collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export interface ICaseAttachmentResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: CaseAttachment[] | undefined;
}

/** The partial model of a case. */
export class CasePartial implements ICasePartial {
    /** The Id of the case. */
    id?: string;
    /** The reference number of this case if it has one. */
    referenceNumber?: number | undefined;
    /** The Id of the customer as provided from integration services (core or 3rd party). */
    customerId?: string | undefined;
    /** The Id of the user as provided from our Identity server. */
    userId?: string | undefined;
    /** The full name of the customer. */
    customerName?: string | undefined;
    /** The created date of the case. */
    createdByWhen?: Date | undefined;
    /** The Id of the user that created the case. */
    createdById?: string | undefined;
    /** The email of the user that created the case. */
    createdByEmail?: string | undefined;
    /** The full name of the user that created the case. */
    createdByName?: string | undefined;
    caseType?: CaseTypePartial;
    /** The case metadata as provided from the client or integrator. */
    metadata?: { [key: string]: string; } | undefined;
    /** The Id of the group the case belongs. */
    groupId?: string | undefined;
    checkpointType?: CheckpointType;
    /** The json data of the case. */
    data?: any | undefined;
    /** The name of the user that has the case assigned. */
    assignedToName?: string | undefined;
    /** The channel of th case. */
    channel?: string | undefined;
    /** Indicate if the case is in draft mode. */
    draft?: boolean;

    constructor(data?: ICasePartial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.referenceNumber = _data["referenceNumber"];
            this.customerId = _data["customerId"];
            this.userId = _data["userId"];
            this.customerName = _data["customerName"];
            this.createdByWhen = _data["createdByWhen"] ? new Date(_data["createdByWhen"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.createdByEmail = _data["createdByEmail"];
            this.createdByName = _data["createdByName"];
            this.caseType = _data["caseType"] ? CaseTypePartial.fromJS(_data["caseType"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.groupId = _data["groupId"];
            this.checkpointType = _data["checkpointType"] ? CheckpointType.fromJS(_data["checkpointType"]) : <any>undefined;
            this.data = _data["data"];
            this.assignedToName = _data["assignedToName"];
            this.channel = _data["channel"];
            this.draft = _data["draft"];
        }
    }

    static fromJS(data: any): CasePartial {
        data = typeof data === 'object' ? data : {};
        let result = new CasePartial();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["referenceNumber"] = this.referenceNumber;
        data["customerId"] = this.customerId;
        data["userId"] = this.userId;
        data["customerName"] = this.customerName;
        data["createdByWhen"] = this.createdByWhen ? this.createdByWhen.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["createdByEmail"] = this.createdByEmail;
        data["createdByName"] = this.createdByName;
        data["caseType"] = this.caseType ? this.caseType.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["groupId"] = this.groupId;
        data["checkpointType"] = this.checkpointType ? this.checkpointType.toJSON() : <any>undefined;
        data["data"] = this.data;
        data["assignedToName"] = this.assignedToName;
        data["channel"] = this.channel;
        data["draft"] = this.draft;
        return data;
    }
}

/** The partial model of a case. */
export interface ICasePartial {
    /** The Id of the case. */
    id?: string;
    /** The reference number of this case if it has one. */
    referenceNumber?: number | undefined;
    /** The Id of the customer as provided from integration services (core or 3rd party). */
    customerId?: string | undefined;
    /** The Id of the user as provided from our Identity server. */
    userId?: string | undefined;
    /** The full name of the customer. */
    customerName?: string | undefined;
    /** The created date of the case. */
    createdByWhen?: Date | undefined;
    /** The Id of the user that created the case. */
    createdById?: string | undefined;
    /** The email of the user that created the case. */
    createdByEmail?: string | undefined;
    /** The full name of the user that created the case. */
    createdByName?: string | undefined;
    caseType?: CaseTypePartial;
    /** The case metadata as provided from the client or integrator. */
    metadata?: { [key: string]: string; } | undefined;
    /** The Id of the group the case belongs. */
    groupId?: string | undefined;
    checkpointType?: CheckpointType;
    /** The json data of the case. */
    data?: any | undefined;
    /** The name of the user that has the case assigned. */
    assignedToName?: string | undefined;
    /** The channel of th case. */
    channel?: string | undefined;
    /** Indicate if the case is in draft mode. */
    draft?: boolean;
}

/**  collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export class CasePartialResultSet implements ICasePartialResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: CasePartial[] | undefined;

    constructor(data?: ICasePartialResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CasePartial.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CasePartialResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new CasePartialResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/**  collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export interface ICasePartialResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: CasePartial[] | undefined;
}

/** Define the status for the customer. It is defined at the Indice.Features.Cases.Data.Models.DbCheckpointType.Status. */
export enum CaseStatus {
    Submitted = "Submitted",
    InProgress = "InProgress",
    Completed = "Completed",
    Deleted = "Deleted",
}

/** The case type details model. */
export class CaseType implements ICaseType {
    /** The Id of the case type. */
    id?: string;
    /** The case type code. */
    code?: string | undefined;
    /** The case type title. */
    title?: string | undefined;
    /** The case type description. */
    description?: string | undefined;
    /** The case type json schema. */
    dataSchema?: string | undefined;
    /** The layout for the data schema. */
    layout?: string | undefined;
    /** The case type translations. */
    translations?: string | undefined;
    /** The layout translations. */
    layoutTranslations?: string | undefined;
    /** The case type tags. */
    tags?: string | undefined;
    /** The case type configuration. */
    config?: string | undefined;
    /** The allowed Roles that can create a new Case. */
    canCreateRoles?: string | undefined;
    /** The flag for checking if the case type is a menu item or not. */
    isMenuItem?: boolean;
    /** The filter configuration for the cases of the specified case type. */
    gridFilterConfig?: string | undefined;
    /** The column configuration for the cases of the specified case type. */
    gridColumnConfig?: string | undefined;
    /** The checkpoints for this case type. */
    checkpointTypes?: CheckpointTypeDetails[] | undefined;
    /** Case type order. */
    order?: number | undefined;

    constructor(data?: ICaseType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.dataSchema = _data["dataSchema"];
            this.layout = _data["layout"];
            this.translations = _data["translations"];
            this.layoutTranslations = _data["layoutTranslations"];
            this.tags = _data["tags"];
            this.config = _data["config"];
            this.canCreateRoles = _data["canCreateRoles"];
            this.isMenuItem = _data["isMenuItem"];
            this.gridFilterConfig = _data["gridFilterConfig"];
            this.gridColumnConfig = _data["gridColumnConfig"];
            if (Array.isArray(_data["checkpointTypes"])) {
                this.checkpointTypes = [] as any;
                for (let item of _data["checkpointTypes"])
                    this.checkpointTypes!.push(CheckpointTypeDetails.fromJS(item));
            }
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): CaseType {
        data = typeof data === 'object' ? data : {};
        let result = new CaseType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["title"] = this.title;
        data["description"] = this.description;
        data["dataSchema"] = this.dataSchema;
        data["layout"] = this.layout;
        data["translations"] = this.translations;
        data["layoutTranslations"] = this.layoutTranslations;
        data["tags"] = this.tags;
        data["config"] = this.config;
        data["canCreateRoles"] = this.canCreateRoles;
        data["isMenuItem"] = this.isMenuItem;
        data["gridFilterConfig"] = this.gridFilterConfig;
        data["gridColumnConfig"] = this.gridColumnConfig;
        if (Array.isArray(this.checkpointTypes)) {
            data["checkpointTypes"] = [];
            for (let item of this.checkpointTypes)
                data["checkpointTypes"].push(item.toJSON());
        }
        data["order"] = this.order;
        return data;
    }
}

/** The case type details model. */
export interface ICaseType {
    /** The Id of the case type. */
    id?: string;
    /** The case type code. */
    code?: string | undefined;
    /** The case type title. */
    title?: string | undefined;
    /** The case type description. */
    description?: string | undefined;
    /** The case type json schema. */
    dataSchema?: string | undefined;
    /** The layout for the data schema. */
    layout?: string | undefined;
    /** The case type translations. */
    translations?: string | undefined;
    /** The layout translations. */
    layoutTranslations?: string | undefined;
    /** The case type tags. */
    tags?: string | undefined;
    /** The case type configuration. */
    config?: string | undefined;
    /** The allowed Roles that can create a new Case. */
    canCreateRoles?: string | undefined;
    /** The flag for checking if the case type is a menu item or not. */
    isMenuItem?: boolean;
    /** The filter configuration for the cases of the specified case type. */
    gridFilterConfig?: string | undefined;
    /** The column configuration for the cases of the specified case type. */
    gridColumnConfig?: string | undefined;
    /** The checkpoints for this case type. */
    checkpointTypes?: CheckpointTypeDetails[] | undefined;
    /** Case type order. */
    order?: number | undefined;
}

/** The case type model. */
export class CaseTypePartial implements ICaseTypePartial {
    /** The Id of the case type. */
    id?: string;
    /** The case type code. */
    code?: string | undefined;
    /** The case type title. */
    title?: string | undefined;
    /** The case type description. */
    description?: string | undefined;
    /** The case type json schema. */
    dataSchema?: string | undefined;
    /** The layout for the data schema. */
    layout?: string | undefined;
    /** The layout translations for the data schema. */
    layoutTranslations?: string | undefined;
    /** The case type tags. */
    tags?: string | undefined;
    /** The case type configuration. */
    config?: string | undefined;
    /** The order which the case type will be shown. */
    order?: number | undefined;
    /** The allowed Roles For case Creation. */
    canCreateRoles?: string[] | undefined;
    category?: Category;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: CaseTypeTranslation; } | undefined;
    /** The flag for checking if the case type is a menu item or not. */
    isMenuItem?: boolean;
    /** The filter configuration for the cases of the specified case type. */
    gridFilterConfig?: string | undefined;
    /** The column configuration for the cases of the specified case type. */
    gridColumnConfig?: string | undefined;

    constructor(data?: ICaseTypePartial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.dataSchema = _data["dataSchema"];
            this.layout = _data["layout"];
            this.layoutTranslations = _data["layoutTranslations"];
            this.tags = _data["tags"];
            this.config = _data["config"];
            this.order = _data["order"];
            if (Array.isArray(_data["canCreateRoles"])) {
                this.canCreateRoles = [] as any;
                for (let item of _data["canCreateRoles"])
                    this.canCreateRoles!.push(item);
            }
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? CaseTypeTranslation.fromJS(_data["translations"][key]) : new CaseTypeTranslation();
                }
            }
            this.isMenuItem = _data["isMenuItem"];
            this.gridFilterConfig = _data["gridFilterConfig"];
            this.gridColumnConfig = _data["gridColumnConfig"];
        }
    }

    static fromJS(data: any): CaseTypePartial {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypePartial();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["title"] = this.title;
        data["description"] = this.description;
        data["dataSchema"] = this.dataSchema;
        data["layout"] = this.layout;
        data["layoutTranslations"] = this.layoutTranslations;
        data["tags"] = this.tags;
        data["config"] = this.config;
        data["order"] = this.order;
        if (Array.isArray(this.canCreateRoles)) {
            data["canCreateRoles"] = [];
            for (let item of this.canCreateRoles)
                data["canCreateRoles"].push(item);
        }
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        data["isMenuItem"] = this.isMenuItem;
        data["gridFilterConfig"] = this.gridFilterConfig;
        data["gridColumnConfig"] = this.gridColumnConfig;
        return data;
    }
}

/** The case type model. */
export interface ICaseTypePartial {
    /** The Id of the case type. */
    id?: string;
    /** The case type code. */
    code?: string | undefined;
    /** The case type title. */
    title?: string | undefined;
    /** The case type description. */
    description?: string | undefined;
    /** The case type json schema. */
    dataSchema?: string | undefined;
    /** The layout for the data schema. */
    layout?: string | undefined;
    /** The layout translations for the data schema. */
    layoutTranslations?: string | undefined;
    /** The case type tags. */
    tags?: string | undefined;
    /** The case type configuration. */
    config?: string | undefined;
    /** The order which the case type will be shown. */
    order?: number | undefined;
    /** The allowed Roles For case Creation. */
    canCreateRoles?: string[] | undefined;
    category?: Category;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: CaseTypeTranslation; } | undefined;
    /** The flag for checking if the case type is a menu item or not. */
    isMenuItem?: boolean;
    /** The filter configuration for the cases of the specified case type. */
    gridFilterConfig?: string | undefined;
    /** The column configuration for the cases of the specified case type. */
    gridColumnConfig?: string | undefined;
}

/**  collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export class CaseTypePartialResultSet implements ICaseTypePartialResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: CaseTypePartial[] | undefined;

    constructor(data?: ICaseTypePartialResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CaseTypePartial.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CaseTypePartialResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypePartialResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/**  collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export interface ICaseTypePartialResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: CaseTypePartial[] | undefined;
}

/** The case type request model. */
export class CaseTypeRequest implements ICaseTypeRequest {
    /** The Id of the case type. */
    id?: string | undefined;
    /** The Code of the case type. */
    code?: string | undefined;
    /** The Title of the case type. */
    title?: string | undefined;
    /** The case type description. */
    description?: string | undefined;
    /** The Data Schema of the case type */
    dataSchema?: string | undefined;
    /** the Layout of the case type */
    layout?: string | undefined;
    /** The Translation for the case type */
    translations?: string | undefined;
    /** The Translation for the layout */
    layoutTranslations?: string | undefined;
    /** The case type tags. */
    tags?: string | undefined;
    /** The case type configuration. */
    config?: string | undefined;
    /** The allowed Roles that can create a new Case. */
    canCreateRoles?: string | undefined;
    /** The order of the case type. */
    order?: number | undefined;
    /** The flag for checking if the case type is a menu item or not. */
    isMenuItem?: boolean;
    /** The filter configuration for the cases of the specified case type. */
    gridFilterConfig?: string | undefined;
    /** The column configuration for the cases of the specified case type. */
    gridColumnConfig?: string | undefined;

    constructor(data?: ICaseTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.dataSchema = _data["dataSchema"];
            this.layout = _data["layout"];
            this.translations = _data["translations"];
            this.layoutTranslations = _data["layoutTranslations"];
            this.tags = _data["tags"];
            this.config = _data["config"];
            this.canCreateRoles = _data["canCreateRoles"];
            this.order = _data["order"];
            this.isMenuItem = _data["isMenuItem"];
            this.gridFilterConfig = _data["gridFilterConfig"];
            this.gridColumnConfig = _data["gridColumnConfig"];
        }
    }

    static fromJS(data: any): CaseTypeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["title"] = this.title;
        data["description"] = this.description;
        data["dataSchema"] = this.dataSchema;
        data["layout"] = this.layout;
        data["translations"] = this.translations;
        data["layoutTranslations"] = this.layoutTranslations;
        data["tags"] = this.tags;
        data["config"] = this.config;
        data["canCreateRoles"] = this.canCreateRoles;
        data["order"] = this.order;
        data["isMenuItem"] = this.isMenuItem;
        data["gridFilterConfig"] = this.gridFilterConfig;
        data["gridColumnConfig"] = this.gridColumnConfig;
        return data;
    }
}

/** The case type request model. */
export interface ICaseTypeRequest {
    /** The Id of the case type. */
    id?: string | undefined;
    /** The Code of the case type. */
    code?: string | undefined;
    /** The Title of the case type. */
    title?: string | undefined;
    /** The case type description. */
    description?: string | undefined;
    /** The Data Schema of the case type */
    dataSchema?: string | undefined;
    /** the Layout of the case type */
    layout?: string | undefined;
    /** The Translation for the case type */
    translations?: string | undefined;
    /** The Translation for the layout */
    layoutTranslations?: string | undefined;
    /** The case type tags. */
    tags?: string | undefined;
    /** The case type configuration. */
    config?: string | undefined;
    /** The allowed Roles that can create a new Case. */
    canCreateRoles?: string | undefined;
    /** The order of the case type. */
    order?: number | undefined;
    /** The flag for checking if the case type is a menu item or not. */
    isMenuItem?: boolean;
    /** The filter configuration for the cases of the specified case type. */
    gridFilterConfig?: string | undefined;
    /** The column configuration for the cases of the specified case type. */
    gridColumnConfig?: string | undefined;
}

/** The Translation of the case type. */
export class CaseTypeTranslation implements ICaseTypeTranslation {
    /** The title of the case type. */
    title?: string | undefined;
    /** The case type description. */
    description?: string | undefined;

    constructor(data?: ICaseTypeTranslation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CaseTypeTranslation {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypeTranslation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        return data;
    }
}

/** The Translation of the case type. */
export interface ICaseTypeTranslation {
    /** The title of the case type. */
    title?: string | undefined;
    /** The case type description. */
    description?: string | undefined;
}

/** Models an attachment that is associated with a case. */
export class CasesAttachmentLink implements ICasesAttachmentLink {
    /** The id of the attachment. */
    id?: string;
    /** The unique file identifier. */
    fileGuid?: string;
    /** The URL to the file. */
    permaLink?: string | undefined;
    /** The label of the file. */
    label?: string | undefined;
    /** The file size in bytes. */
    size?: number;
    /** The file size in readable format. */
    readonly sizeText?: string | undefined;
    /** The content type of the file. */
    contentType?: string | undefined;

    constructor(data?: ICasesAttachmentLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileGuid = _data["fileGuid"];
            this.permaLink = _data["permaLink"];
            this.label = _data["label"];
            this.size = _data["size"];
            (<any>this).sizeText = _data["sizeText"];
            this.contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): CasesAttachmentLink {
        data = typeof data === 'object' ? data : {};
        let result = new CasesAttachmentLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileGuid"] = this.fileGuid;
        data["permaLink"] = this.permaLink;
        data["label"] = this.label;
        data["size"] = this.size;
        data["sizeText"] = this.sizeText;
        data["contentType"] = this.contentType;
        return data;
    }
}

/** Models an attachment that is associated with a case. */
export interface ICasesAttachmentLink {
    /** The id of the attachment. */
    id?: string;
    /** The unique file identifier. */
    fileGuid?: string;
    /** The URL to the file. */
    permaLink?: string | undefined;
    /** The label of the file. */
    label?: string | undefined;
    /** The file size in bytes. */
    size?: number;
    /** The file size in readable format. */
    sizeText?: string | undefined;
    /** The content type of the file. */
    contentType?: string | undefined;
}

/** Case Type Category model. */
export class Category implements ICategory {
    /** The Id of the category */
    id?: string;
    /** The Code of the category */
    name?: string | undefined;
    /** the Description of the category */
    description?: string | undefined;
    /** The Order of the category */
    order?: number | undefined;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: CategoryTranslation; } | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.order = _data["order"];
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? CategoryTranslation.fromJS(_data["translations"][key]) : new CategoryTranslation();
                }
            }
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["order"] = this.order;
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Case Type Category model. */
export interface ICategory {
    /** The Id of the category */
    id?: string;
    /** The Code of the category */
    name?: string | undefined;
    /** the Description of the category */
    description?: string | undefined;
    /** The Order of the category */
    order?: number | undefined;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: CategoryTranslation; } | undefined;
}

/** The translation of the case type category. */
export class CategoryTranslation implements ICategoryTranslation {
    /** The name of the category */
    name?: string | undefined;
    /** the description of the category */
    description?: string | undefined;

    constructor(data?: ICategoryTranslation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CategoryTranslation {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryTranslation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

/** The translation of the case type category. */
export interface ICategoryTranslation {
    /** The name of the category */
    name?: string | undefined;
    /** the description of the category */
    description?: string | undefined;
}

/** The checkpoint entry for a case. */
export class Checkpoint implements ICheckpoint {
    /** The Id of the checkpoint. */
    id?: string;
    checkpointType?: CheckpointType;
    /** The completed date of the checkpoint. */
    completedDate?: Date | undefined;
    /** The due date of the checkpoint. */
    dueDate?: Date | undefined;

    constructor(data?: ICheckpoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.checkpointType = _data["checkpointType"] ? CheckpointType.fromJS(_data["checkpointType"]) : <any>undefined;
            this.completedDate = _data["completedDate"] ? new Date(_data["completedDate"].toString()) : <any>undefined;
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Checkpoint {
        data = typeof data === 'object' ? data : {};
        let result = new Checkpoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checkpointType"] = this.checkpointType ? this.checkpointType.toJSON() : <any>undefined;
        data["completedDate"] = this.completedDate ? this.completedDate.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        return data;
    }
}

/** The checkpoint entry for a case. */
export interface ICheckpoint {
    /** The Id of the checkpoint. */
    id?: string;
    checkpointType?: CheckpointType;
    /** The completed date of the checkpoint. */
    completedDate?: Date | undefined;
    /** The due date of the checkpoint. */
    dueDate?: Date | undefined;
}

/** The checkpoint type model. */
export class CheckpointType implements ICheckpointType {
    /** The Id of the <b>checkpoint type</b>. */
    id?: string;
    /** The code of the <b>checkpoint type</b>. */
    code?: string | undefined;
    /** The title of the <b>checkpoint type</b>. */
    title?: string | undefined;
    /** The description of the <b>checkpoint type</b>. */
    description?: string | undefined;
    status?: CaseStatus;
    /** Indicates if the checkpoint type is private, which means not visible to the customer. */
    private?: boolean | undefined;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: CheckpointTypeTranslation; } | undefined;

    constructor(data?: ICheckpointType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.private = _data["private"];
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? CheckpointTypeTranslation.fromJS(_data["translations"][key]) : new CheckpointTypeTranslation();
                }
            }
        }
    }

    static fromJS(data: any): CheckpointType {
        data = typeof data === 'object' ? data : {};
        let result = new CheckpointType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["title"] = this.title;
        data["description"] = this.description;
        data["status"] = this.status;
        data["private"] = this.private;
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** The checkpoint type model. */
export interface ICheckpointType {
    /** The Id of the <b>checkpoint type</b>. */
    id?: string;
    /** The code of the <b>checkpoint type</b>. */
    code?: string | undefined;
    /** The title of the <b>checkpoint type</b>. */
    title?: string | undefined;
    /** The description of the <b>checkpoint type</b>. */
    description?: string | undefined;
    status?: CaseStatus;
    /** Indicates if the checkpoint type is private, which means not visible to the customer. */
    private?: boolean | undefined;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: CheckpointTypeTranslation; } | undefined;
}

/** The checkpoint type request model. */
export class CheckpointTypeDetails implements ICheckpointTypeDetails {
    /** The Id of the checkpoint type. */
    id?: string;
    /** The name of the checkpoint. */
    code?: string | undefined;
    /** The description of the checkpoint. */
    description?: string | undefined;
    status?: CaseStatus;
    /** Boolean for whether the checkpoint is private. */
    private?: boolean;
    /** The related roles for this checkpoint. */
    roles?: string[] | undefined;

    constructor(data?: ICheckpointTypeDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.private = _data["private"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CheckpointTypeDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CheckpointTypeDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["description"] = this.description;
        data["status"] = this.status;
        data["private"] = this.private;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

/** The checkpoint type request model. */
export interface ICheckpointTypeDetails {
    /** The Id of the checkpoint type. */
    id?: string;
    /** The name of the checkpoint. */
    code?: string | undefined;
    /** The description of the checkpoint. */
    description?: string | undefined;
    status?: CaseStatus;
    /** Boolean for whether the checkpoint is private. */
    private?: boolean;
    /** The related roles for this checkpoint. */
    roles?: string[] | undefined;
}

/** The Translation of the checkpoint type. */
export class CheckpointTypeTranslation implements ICheckpointTypeTranslation {
    /** The title of the checkpoint type. */
    title?: string | undefined;
    /** The checkpoint type description. */
    description?: string | undefined;

    constructor(data?: ICheckpointTypeTranslation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CheckpointTypeTranslation {
        data = typeof data === 'object' ? data : {};
        let result = new CheckpointTypeTranslation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        return data;
    }
}

/** The Translation of the checkpoint type. */
export interface ICheckpointTypeTranslation {
    /** The title of the checkpoint type. */
    title?: string | undefined;
    /** The checkpoint type description. */
    description?: string | undefined;
}

/** The comment entry for a case. */
export class Comment implements IComment {
    /** The Id of the comment. */
    id?: string;
    /** The comment text. */
    text?: string | undefined;
    /** Indicates if the comment is made by customer */
    isCustomer?: boolean | undefined;
    /** Indicates if the comment is private, which means not visible to the customer. */
    private?: boolean | undefined;
    attachment?: CasesAttachmentLink;
    replyToComment?: Comment;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.isCustomer = _data["isCustomer"];
            this.private = _data["private"];
            this.attachment = _data["attachment"] ? CasesAttachmentLink.fromJS(_data["attachment"]) : <any>undefined;
            this.replyToComment = _data["replyToComment"] ? Comment.fromJS(_data["replyToComment"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["isCustomer"] = this.isCustomer;
        data["private"] = this.private;
        data["attachment"] = this.attachment ? this.attachment.toJSON() : <any>undefined;
        data["replyToComment"] = this.replyToComment ? this.replyToComment.toJSON() : <any>undefined;
        return data;
    }
}

/** The comment entry for a case. */
export interface IComment {
    /** The Id of the comment. */
    id?: string;
    /** The comment text. */
    text?: string | undefined;
    /** Indicates if the comment is made by customer */
    isCustomer?: boolean | undefined;
    /** Indicates if the comment is private, which means not visible to the customer. */
    private?: boolean | undefined;
    attachment?: CasesAttachmentLink;
    replyToComment?: Comment;
}

/** The response payload when creating a case. */
export class CreateCaseResponse implements ICreateCaseResponse {
    /** The Id of the case that created. */
    id?: string;
    /** The created date of the case that created. */
    created?: Date;

    constructor(data?: ICreateCaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateCaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

/** The response payload when creating a case. */
export interface ICreateCaseResponse {
    /** The Id of the case that created. */
    id?: string;
    /** The created date of the case that created. */
    created?: Date;
}

/** The request payload for creating a new draft case. */
export class CreateDraftCaseRequest implements ICreateDraftCaseRequest {
    /** The Case type code of the case. */
    caseTypeCode?: string | undefined;
    /** The group this case belongs to, eg a customer's branch */
    groupId?: string | undefined;
    customer?: CustomerMeta;
    /** A list of case metadata in key value pairs */
    metadata?: { [key: string]: string; } | undefined;
    /** The channel that created the draft case */
    channel?: string | undefined;

    constructor(data?: ICreateDraftCaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.caseTypeCode = _data["caseTypeCode"];
            this.groupId = _data["groupId"];
            this.customer = _data["customer"] ? CustomerMeta.fromJS(_data["customer"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.channel = _data["channel"];
        }
    }

    static fromJS(data: any): CreateDraftCaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDraftCaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caseTypeCode"] = this.caseTypeCode;
        data["groupId"] = this.groupId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["channel"] = this.channel;
        return data;
    }
}

/** The request payload for creating a new draft case. */
export interface ICreateDraftCaseRequest {
    /** The Case type code of the case. */
    caseTypeCode?: string | undefined;
    /** The group this case belongs to, eg a customer's branch */
    groupId?: string | undefined;
    customer?: CustomerMeta;
    /** A list of case metadata in key value pairs */
    metadata?: { [key: string]: string; } | undefined;
    /** The channel that created the draft case */
    channel?: string | undefined;
}

/** Custom action blocking activity that will generate the corresponding component. */
export class CustomCaseAction implements ICustomCaseAction {
    /** The Id to trigger the action. */
    id?: string | undefined;
    /** The name of the action. */
    name?: string | undefined;
    /** The label of the action. */
    label?: string | undefined;
    /** The class of the action. */
    class?: string | undefined;
    /** Determines whether at the end of the action the user will be redirected to Cases list of Back-office UI. */
    redirectToList?: boolean | undefined;
    successMessage?: SuccessMessage;
    /** The description of the action. */
    description?: string | undefined;
    /** The Default Value of action's input. */
    defaultValue?: string | undefined;
    /** Determines whether the action will have an input element. */
    hasInput?: boolean | undefined;

    constructor(data?: ICustomCaseAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.label = _data["label"];
            this.class = _data["class"];
            this.redirectToList = _data["redirectToList"];
            this.successMessage = _data["successMessage"] ? SuccessMessage.fromJS(_data["successMessage"]) : <any>undefined;
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
            this.hasInput = _data["hasInput"];
        }
    }

    static fromJS(data: any): CustomCaseAction {
        data = typeof data === 'object' ? data : {};
        let result = new CustomCaseAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["label"] = this.label;
        data["class"] = this.class;
        data["redirectToList"] = this.redirectToList;
        data["successMessage"] = this.successMessage ? this.successMessage.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["hasInput"] = this.hasInput;
        return data;
    }
}

/** Custom action blocking activity that will generate the corresponding component. */
export interface ICustomCaseAction {
    /** The Id to trigger the action. */
    id?: string | undefined;
    /** The name of the action. */
    name?: string | undefined;
    /** The label of the action. */
    label?: string | undefined;
    /** The class of the action. */
    class?: string | undefined;
    /** Determines whether at the end of the action the user will be redirected to Cases list of Back-office UI. */
    redirectToList?: boolean | undefined;
    successMessage?: SuccessMessage;
    /** The description of the action. */
    description?: string | undefined;
    /** The Default Value of action's input. */
    defaultValue?: string | undefined;
    /** Determines whether the action will have an input element. */
    hasInput?: boolean | undefined;
}

/** Customer Data as Json string */
export class CustomerData implements ICustomerData {
    /** The json data as string. */
    formData?: any | undefined;

    constructor(data?: ICustomerData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formData = _data["formData"];
        }
    }

    static fromJS(data: any): CustomerData {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formData"] = this.formData;
        return data;
    }
}

/** Customer Data as Json string */
export interface ICustomerData {
    /** The json data as string. */
    formData?: any | undefined;
}

/** The customer response object that contains information from the integration system. Properties that have no direct mapping to this model can be added to Indice.Features.Cases.Models.Responses.CustomerDetails.Metadata dictionary. */
export class CustomerDetails implements ICustomerDetails {
    /** The Id of the customer as created to our Identity provider. */
    userId?: string | undefined;
    /** The Id of the customer as provided by the consumer/integrator. */
    customerId?: string | undefined;
    /** The first name of the customer. */
    firstName?: string | undefined;
    /** The last name of the customer. */
    lastName?: string | undefined;
    /** The Id of the group the customer belongs. */
    groupId?: string | undefined;
    /** Any extra customer metadata with consumer/integrator business logic. */
    metadata?: { [key: string]: string; } | undefined;

    constructor(data?: ICustomerDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.customerId = _data["customerId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.groupId = _data["groupId"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
        }
    }

    static fromJS(data: any): CustomerDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["customerId"] = this.customerId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["groupId"] = this.groupId;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        return data;
    }
}

/** The customer response object that contains information from the integration system. Properties that have no direct mapping to this model can be added to Indice.Features.Cases.Models.Responses.CustomerDetails.Metadata dictionary. */
export interface ICustomerDetails {
    /** The Id of the customer as created to our Identity provider. */
    userId?: string | undefined;
    /** The Id of the customer as provided by the consumer/integrator. */
    customerId?: string | undefined;
    /** The first name of the customer. */
    firstName?: string | undefined;
    /** The last name of the customer. */
    lastName?: string | undefined;
    /** The Id of the group the customer belongs. */
    groupId?: string | undefined;
    /** Any extra customer metadata with consumer/integrator business logic. */
    metadata?: { [key: string]: string; } | undefined;
}

/** Customer metadata related to the Customer the case is created for. The customer may create the case himself or the case could be created on this customers behalf */
export class CustomerMeta implements ICustomerMeta {
    userId?: string | undefined;
    customerId?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    readonly fullName?: string | undefined;

    constructor(data?: ICustomerMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.customerId = _data["customerId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            (<any>this).fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): CustomerMeta {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["customerId"] = this.customerId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        return data;
    }
}

/** Customer metadata related to the Customer the case is created for. The customer may create the case himself or the case could be created on this customers behalf */
export interface ICustomerMeta {
    userId?: string | undefined;
    customerId?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
}

/** The request payload with the edited data. */
export class EditCaseRequest implements IEditCaseRequest {
    /** The data as json. */
    data?: any | undefined;

    constructor(data?: IEditCaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): EditCaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EditCaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        return data;
    }
}

/** The request payload with the edited data. */
export interface IEditCaseRequest {
    /** The data as json. */
    data?: any | undefined;
}

/** The Filter Term model. */
export class FilterTerm implements IFilterTerm {
    /** FilterTerm's Key */
    key?: string | undefined;
    /** FilterTerm's Value */
    value?: string | undefined;

    constructor(data?: IFilterTerm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): FilterTerm {
        data = typeof data === 'object' ? data : {};
        let result = new FilterTerm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

/** The Filter Term model. */
export interface IFilterTerm {
    /** FilterTerm's Key */
    key?: string | undefined;
    /** FilterTerm's Value */
    value?: string | undefined;
}

/** The GroupByReportResult. */
export class GroupByReportResult implements IGroupByReportResult {
    /** Count */
    count?: number;
    /** Label */
    label?: string | undefined;

    constructor(data?: IGroupByReportResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): GroupByReportResult {
        data = typeof data === 'object' ? data : {};
        let result = new GroupByReportResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["label"] = this.label;
        return data;
    }
}

/** The GroupByReportResult. */
export interface IGroupByReportResult {
    /** Count */
    count?: number;
    /** Label */
    label?: string | undefined;
}

/** The lookup item model. */
export class LookupItem implements ILookupItem {
    /** The name or the key of the look up item */
    name?: string | undefined;
    /** The value of the lookup item */
    value?: string | undefined;

    constructor(data?: ILookupItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): LookupItem {
        data = typeof data === 'object' ? data : {};
        let result = new LookupItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

/** The lookup item model. */
export interface ILookupItem {
    /** The name or the key of the look up item */
    name?: string | undefined;
    /** The value of the lookup item */
    value?: string | undefined;
}

/**  collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export class LookupItemResultSet implements ILookupItemResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: LookupItem[] | undefined;

    constructor(data?: ILookupItemResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LookupItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupItemResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new LookupItemResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/**  collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export interface ILookupItemResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: LookupItem[] | undefined;
}

/** The model for the customer with the minimum required properties. */
export class MyCasePartial implements IMyCasePartial {
    /** Id of the case. */
    id?: string;
    /** The reference number of this case if it has one. */
    referenceNumber?: number | undefined;
    /** The date the case was created. */
    created?: Date | undefined;
    /** The case type code of the case. */
    caseTypeCode?: string | undefined;
    /** The case type title of the case. */
    title?: string | undefined;
    checkpointType?: CheckpointType;
    /** The case metadata. */
    metadata?: { [key: string]: string; } | undefined;
    /** The message that has been submitted from the backoffice. */
    message?: string | undefined;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: MyCasePartialTranslation; } | undefined;
    /** The json data of the case. */
    data?: any | undefined;

    constructor(data?: IMyCasePartial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.referenceNumber = _data["referenceNumber"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.caseTypeCode = _data["caseTypeCode"];
            this.title = _data["title"];
            this.checkpointType = _data["checkpointType"] ? CheckpointType.fromJS(_data["checkpointType"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.message = _data["message"];
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? MyCasePartialTranslation.fromJS(_data["translations"][key]) : new MyCasePartialTranslation();
                }
            }
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): MyCasePartial {
        data = typeof data === 'object' ? data : {};
        let result = new MyCasePartial();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["referenceNumber"] = this.referenceNumber;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["caseTypeCode"] = this.caseTypeCode;
        data["title"] = this.title;
        data["checkpointType"] = this.checkpointType ? this.checkpointType.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["message"] = this.message;
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        data["data"] = this.data;
        return data;
    }
}

/** The model for the customer with the minimum required properties. */
export interface IMyCasePartial {
    /** Id of the case. */
    id?: string;
    /** The reference number of this case if it has one. */
    referenceNumber?: number | undefined;
    /** The date the case was created. */
    created?: Date | undefined;
    /** The case type code of the case. */
    caseTypeCode?: string | undefined;
    /** The case type title of the case. */
    title?: string | undefined;
    checkpointType?: CheckpointType;
    /** The case metadata. */
    metadata?: { [key: string]: string; } | undefined;
    /** The message that has been submitted from the backoffice. */
    message?: string | undefined;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: MyCasePartialTranslation; } | undefined;
    /** The json data of the case. */
    data?: any | undefined;
}

/**  collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export class MyCasePartialResultSet implements IMyCasePartialResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: MyCasePartial[] | undefined;

    constructor(data?: IMyCasePartialResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MyCasePartial.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MyCasePartialResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new MyCasePartialResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/**  collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export interface IMyCasePartialResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: MyCasePartial[] | undefined;
}

/** The translation wrapper for Indice.Features.Cases.Models.Responses.MyCasePartial model. */
export class MyCasePartialTranslation implements IMyCasePartialTranslation {
    /** The title of the case type. */
    title?: string | undefined;
    checkpointType?: CheckpointType;

    constructor(data?: IMyCasePartialTranslation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.checkpointType = _data["checkpointType"] ? CheckpointType.fromJS(_data["checkpointType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MyCasePartialTranslation {
        data = typeof data === 'object' ? data : {};
        let result = new MyCasePartialTranslation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["checkpointType"] = this.checkpointType ? this.checkpointType.toJSON() : <any>undefined;
        return data;
    }
}

/** The translation wrapper for Indice.Features.Cases.Models.Responses.MyCasePartial model. */
export interface IMyCasePartialTranslation {
    /** The title of the case type. */
    title?: string | undefined;
    checkpointType?: CheckpointType;
}

/** The notification subscription. */
export class NotificationSubscription implements INotificationSubscription {
    /** The notification subscription CaseType Id. */
    caseTypeId?: string;
    /** Subscriber email. */
    email?: string | undefined;
    /** Subscriber group Id. */
    groupId?: string | undefined;

    constructor(data?: INotificationSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.caseTypeId = _data["caseTypeId"];
            this.email = _data["email"];
            this.groupId = _data["groupId"];
        }
    }

    static fromJS(data: any): NotificationSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caseTypeId"] = this.caseTypeId;
        data["email"] = this.email;
        data["groupId"] = this.groupId;
        return data;
    }
}

/** The notification subscription. */
export interface INotificationSubscription {
    /** The notification subscription CaseType Id. */
    caseTypeId?: string;
    /** Subscriber email. */
    email?: string | undefined;
    /** Subscriber group Id. */
    groupId?: string | undefined;
}

/** The notification subscription Request. */
export class NotificationSubscriptionRequest implements INotificationSubscriptionRequest {
    /** The Ids of the CaseTypes that the User wants to subscribe to. */
    caseTypeIds?: string[] | undefined;

    constructor(data?: INotificationSubscriptionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["caseTypeIds"])) {
                this.caseTypeIds = [] as any;
                for (let item of _data["caseTypeIds"])
                    this.caseTypeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): NotificationSubscriptionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.caseTypeIds)) {
            data["caseTypeIds"] = [];
            for (let item of this.caseTypeIds)
                data["caseTypeIds"].push(item);
        }
        return data;
    }
}

/** The notification subscription Request. */
export interface INotificationSubscriptionRequest {
    /** The Ids of the CaseTypes that the User wants to subscribe to. */
    caseTypeIds?: string[] | undefined;
}

/** The notification subscription Response. */
export class NotificationSubscriptionResponse implements INotificationSubscriptionResponse {
    /** User's notification subscriptions. */
    notificationSubscriptions?: NotificationSubscription[] | undefined;

    constructor(data?: INotificationSubscriptionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["notificationSubscriptions"])) {
                this.notificationSubscriptions = [] as any;
                for (let item of _data["notificationSubscriptions"])
                    this.notificationSubscriptions!.push(NotificationSubscription.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationSubscriptionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.notificationSubscriptions)) {
            data["notificationSubscriptions"] = [];
            for (let item of this.notificationSubscriptions)
                data["notificationSubscriptions"].push(item.toJSON());
        }
        return data;
    }
}

/** The notification subscription Response. */
export interface INotificationSubscriptionResponse {
    /** User's notification subscriptions. */
    notificationSubscriptions?: NotificationSubscription[] | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

/** A user defined query. */
export class Query implements IQuery {
    /** The Id of the Query. */
    id?: string;
    /** The Friendly Name of the Query. */
    friendlyName?: string | undefined;
    /** The Parameters of the Query. */
    parameters?: string | undefined;

    constructor(data?: IQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.friendlyName = _data["friendlyName"];
            this.parameters = _data["parameters"];
        }
    }

    static fromJS(data: any): Query {
        data = typeof data === 'object' ? data : {};
        let result = new Query();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["friendlyName"] = this.friendlyName;
        data["parameters"] = this.parameters;
        return data;
    }
}

/** A user defined query. */
export interface IQuery {
    /** The Id of the Query. */
    id?: string;
    /** The Friendly Name of the Query. */
    friendlyName?: string | undefined;
    /** The Parameters of the Query. */
    parameters?: string | undefined;
}

/** The reject reason dto. */
export class RejectReason implements IRejectReason {
    /** The key of the reject reason. This key will be used in resources. */
    key?: string | undefined;
    /** The value of the reject reason. This will be translated into request language. */
    value?: string | undefined;

    constructor(data?: IRejectReason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): RejectReason {
        data = typeof data === 'object' ? data : {};
        let result = new RejectReason();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

/** The reject reason dto. */
export interface IRejectReason {
    /** The key of the reject reason. This key will be used in resources. */
    key?: string | undefined;
    /** The value of the reject reason. This will be translated into request language. */
    value?: string | undefined;
}

/** Define the case report tag. */
export enum ReportTag {
    GroupedByCasetype = "GroupedByCasetype",
    AgentGroupedByCasetype = "AgentGroupedByCasetype",
    CustomerGroupedByCasetype = "CustomerGroupedByCasetype",
    GroupedByStatus = "GroupedByStatus",
    AgentGroupedByStatus = "AgentGroupedByStatus",
    CustomerGroupedByStatus = "CustomerGroupedByStatus",
    GroupedByGroupId = "GroupedByGroupId",
}

/** The Save Query Request */
export class SaveQueryRequest implements ISaveQueryRequest {
    /** The Friendly Name of the request */
    friendlyName?: string | undefined;
    /** The Parameters of the request */
    parameters?: string | undefined;

    constructor(data?: ISaveQueryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.friendlyName = _data["friendlyName"];
            this.parameters = _data["parameters"];
        }
    }

    static fromJS(data: any): SaveQueryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SaveQueryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendlyName"] = this.friendlyName;
        data["parameters"] = this.parameters;
        return data;
    }
}

/** The Save Query Request */
export interface ISaveQueryRequest {
    /** The Friendly Name of the request */
    friendlyName?: string | undefined;
    /** The Parameters of the request */
    parameters?: string | undefined;
}

/** A success response message. */
export class SuccessMessage implements ISuccessMessage {
    /** The message's Title. */
    title?: string | undefined;
    /** The message's Body. */
    body?: string | undefined;

    constructor(data?: ISuccessMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): SuccessMessage {
        data = typeof data === 'object' ? data : {};
        let result = new SuccessMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["body"] = this.body;
        return data;
    }
}

/** A success response message. */
export interface ISuccessMessage {
    /** The message's Title. */
    title?: string | undefined;
    /** The message's Body. */
    body?: string | undefined;
}

/** A class that represents a timeline entry for a case. */
export class TimelineEntry implements ITimelineEntry {
    /** The timestamp. */
    timestamp?: Date;
    createdBy?: AuditMeta;
    /** Checks if the entry is Checkpoint change. */
    readonly isCheckpoint?: boolean;
    checkpoint?: Checkpoint;
    comment?: Comment;

    constructor(data?: ITimelineEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"] ? AuditMeta.fromJS(_data["createdBy"]) : <any>undefined;
            (<any>this).isCheckpoint = _data["isCheckpoint"];
            this.checkpoint = _data["checkpoint"] ? Checkpoint.fromJS(_data["checkpoint"]) : <any>undefined;
            this.comment = _data["comment"] ? Comment.fromJS(_data["comment"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TimelineEntry {
        data = typeof data === 'object' ? data : {};
        let result = new TimelineEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["isCheckpoint"] = this.isCheckpoint;
        data["checkpoint"] = this.checkpoint ? this.checkpoint.toJSON() : <any>undefined;
        data["comment"] = this.comment ? this.comment.toJSON() : <any>undefined;
        return data;
    }
}

/** A class that represents a timeline entry for a case. */
export interface ITimelineEntry {
    /** The timestamp. */
    timestamp?: Date;
    createdBy?: AuditMeta;
    /** Checks if the entry is Checkpoint change. */
    isCheckpoint?: boolean;
    checkpoint?: Checkpoint;
    comment?: Comment;
}

/** The request to update the data of the case. */
export class UpdateCaseRequest implements IUpdateCaseRequest {
    /** The data in json string. */
    data?: any | undefined;

    constructor(data?: IUpdateCaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): UpdateCaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        return data;
    }
}

/** The request to update the data of the case. */
export interface IUpdateCaseRequest {
    /** The data in json string. */
    data?: any | undefined;
}

export class ValidationProblemDetails implements IValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    readonly errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;

    constructor(data?: IValidationProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["errors"]) {
                (<any>this).errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>(<any>this).errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        return data;
    }
}

export interface IValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
