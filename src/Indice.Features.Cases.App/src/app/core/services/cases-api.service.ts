//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const CASES_API_BASE_URL = new InjectionToken<string>('CASES_API_BASE_URL');

export interface ICasesApiService {
    /**
     * Get Access rules.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param role (optional) 
     * @param groupId (optional) 
     * @param checkpoint (optional) 
     * @param caseType (optional) 
     * @return OK
     */
    getAccessRules(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, role?: string | undefined, groupId?: string | undefined, checkpoint?: string | undefined, caseType?: string | undefined): Observable<AccessRuleResultSet>;
    /**
     * Delete an existing Access rule.
     * @return No Content
     */
    deleteAccessRule(ruleId: string): Observable<void>;
    /**
     * Update an existing Access rule.
     * @return No Content
     */
    updateAccessRule(ruleId: string, accessLevel: number): Observable<void>;
    /**
     * Add a new Access rule for admin Users.
     * @return No Content
     */
    createAccessRuleAdmin(body: AddAccessRuleRequest): Observable<void>;
    /**
     * Add a new Access rule for admin Users.
     * @return No Content
     */
    createBatchAccessRulesAdmin(body: AddAccessRuleRequest[]): Observable<void>;
    /**
     * Add a new Access rule for a case.
     * @return No Content
     */
    createAccessRules(caseId: string, body: AddCaseAccessRuleRequest): Observable<void>;
    /**
     * Update a batch of Access rules for a case.
     * @return No Content
     */
    updateBatchAccessRules(caseId: string, body: AddCaseAccessRuleRequest[]): Observable<void>;
    /**
     * Download attachment in a PDF format for back-office users.
     * @return OK
     */
    downloadAttachment(attachmentId: string): Observable<FileResponse>;
    /**
     * Get case types.
     * @param canCreate (optional) 
     * @return OK
     */
    getCaseTypesList(canCreate?: boolean | undefined): Observable<CaseTypePartialResultSet>;
    /**
     * Create new case type.
     * @return No Content
     */
    createCaseType(body: CaseTypeRequest): Observable<void>;
    /**
     * Get a specific Case Type by Id.
     * @return OK
     */
    getCaseTypeById(caseTypeId: string): Observable<CaseType>;
    /**
     * Update a specific Case Type.
     * @return OK
     */
    updateCaseType(caseTypeId: string, body: CaseTypeRequest): Observable<CaseType>;
    /**
     * Delete a specific Case Type.
     * @return No Content
     */
    deleteCaseType(caseTypeId: string): Observable<void>;
    /**
     * Create a new case in draft mode.
     * @return OK
     */
    createDraftAdminCase(body: CreateDraftCaseRequest): Observable<CreateCaseResponse>;
    /**
     * Gets the list of all cases using the provided.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param ownerIds (optional) 
     * @param ownerNames (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @param caseTypeCodes (optional) 
     * @param checkpointTypeCodes (optional) 
     * @param groupIds (optional) 
     * @param metadata (optional) 
     * @param referenceNumbers (optional) 
     * @param data (optional) 
     * @param includeData (optional) 
     * @return OK
     */
    getCases(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, ownerIds?: string[] | undefined, ownerNames?: string[] | undefined, from?: Date | undefined, to?: Date | undefined, caseTypeCodes?: string[] | undefined, checkpointTypeCodes?: string[] | undefined, groupIds?: string[] | undefined, metadata?: string[] | undefined, referenceNumbers?: string[] | undefined, data?: string[] | undefined, includeData?: boolean | undefined): Observable<CasePartialResultSet>;
    /**
     * Update the case with the business data as defined at the specific case type. This action is allowed only for draft cases.
     * @return No Content
     */
    updateAdminCase(caseId: string, body: UpdateCaseRequest): Observable<void>;
    /**
     * Gets a case with the specified id.
     * @return OK
     */
    getCaseById(caseId: string): Observable<Case>;
    /**
     * Deletes a draft case with the specified id.
     * @return No Content
     */
    deleteDraftCase(caseId: string): Observable<void>;
    /**
     * Download case in a PDF format.
     * @return OK
     */
    downloadCasePdf(caseId: string): Observable<FileResponse>;
    /**
     * Get Access rules for the specified case.
     * @return OK
     */
    getAccessRulesForCase(caseId: string): Observable<AccessRule[]>;
    /**
     * Gets the cases actions (Approval, edit, assignments, etc) for a case Id. Actions differ based on user role.
     * @return OK
     */
    getCaseActions(caseId: string): Observable<CaseActions>;
    /**
     * Invoke the approval activity to approve or reject the case.
     * @return No Content
     */
    submitApproval(caseId: string, body: ApprovalRequest): Observable<void>;
    /**
     * Invoke the assign activity to assign the case to the caller user.
     * @return No Content
     */
    assignCase(caseId: string): Observable<void>;
    /**
     * Get a list of Attachments for a CaseId
     * @return OK
     */
    getCaseAttachments(caseId: string): Observable<CaseAttachmentResultSet>;
    /**
     * Add an attachment to an existing case regardless of its status and mode (draft or not).
     * @param file (optional) 
     * @return OK
     */
    uploadAdminCaseAttachment(caseId: string, file?: FileParameter | undefined): Observable<CasesAttachmentLink>;
    /**
     * Get an Case Attachment
     */
    getCaseAttachment(caseId: string, attachmentId: string): Observable<void>;
    /**
     * Get a Case Attachment by field name.
     */
    getAttachmentByField(caseId: string, fieldName: string): Observable<void>;
    /**
     * Add a comment to a case.
     * @return No Content
     */
    adminAddComment(caseId: string, body: SendCommentRequest): Observable<void>;
    /**
     * Patches the Case.Data object with an object passed in the body.
     * @return No Content
     */
    patchAdminCaseData(caseId: string, body: any): Observable<void>;
    /**
     * Update the Case Data for the specific caseId according to https://datatracker.ietf.org/doc/html/rfc6902#appendix-A.
     * @return No Content
     */
    jsonPatchAdminCaseData(caseId: string, body: PatchJsonPathRequest[]): Observable<void>;
    /**
     * Invoke the edit activity to edit the data of the case.
     * @return No Content
     */
    editCase(caseId: string, body: EditCaseRequest): Observable<void>;
    /**
     * Patches the metadata of a case.
     * @return No Content
     */
    patchCaseMetadata(caseId: string, body: { [key: string]: string; }): Observable<void>;
    /**
     * Get the reject reasons for a case.
     * @return OK
     */
    getCaseRejectReasons(caseId: string): Observable<RejectReason[]>;
    /**
     * Gets the cases that are related to the given id.
     * @return OK
     */
    getRelatedCases(caseId: string): Observable<CasePartial[]>;
    /**
     * Submit the case by removing the draft mode.
     * @return No Content
     */
    submitAdminCase(caseId: string, body: any): Observable<void>;
    /**
     * Gets the timeline entries for a case.
     * @return OK
     */
    getCaseTimeline(caseId: string): Observable<TimelineEntry[]>;
    /**
     * Invoke the action activity to trigger a business action for the case.
     * @return No Content
     */
    triggerAction(caseId: string, body: ActionRequest): Observable<void>;
    /**
     * Get the distinct checkpoint types grouped by code.
     * @return OK
     */
    getDistinctCheckpointTypes(): Observable<CheckpointType[]>;
    /**
     * Search contacts.
     * @param reference (optional) 
     * @param caseTypeCode (optional) 
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @return OK
     */
    getContacts(reference?: string | undefined, caseTypeCode?: string | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined): Observable<ContactResultSet>;
    /**
     * Fetch contact data by contact.reference number for a specific case type code.
     * @return OK
     */
    getContactData(reference: string, caseTypeCode: string): Observable<Contact>;
    /**
     * Get a lookup result by lookupName and options.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param filterTerms (optional) 
     * @return OK
     */
    getLookup(lookupName: string, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, filterTerms?: string[] | undefined): Observable<LookupItemResultSet>;
    /**
     * Get the notification subscriptions for a user.
     * @return OK
     */
    getMySubscriptions(): Observable<NotificationSubscriptionResponse>;
    /**
     * Store user's subscription settings.
     * @return No Content
     */
    subscribe(body: NotificationSubscriptionRequest): Observable<void>;
    /**
     * Get saved queries.
     * @return OK
     */
    getQueries(): Observable<Query[]>;
    /**
     * Save a new query.
     * @return No Content
     */
    saveQuery(body: SaveQueryRequest): Observable<void>;
    /**
     * Delete a query.
     * @return No Content
     */
    deleteQuery(queryId: string): Observable<void>;
    /**
     * Get case report
     * @return OK
     */
    getCaseReport(reportTag: ReportTag): Observable<GroupByReportResult[]>;
}

@Injectable({
    providedIn: 'root'
})
export class CasesApiService implements ICasesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CASES_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get Access rules.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param role (optional) 
     * @param groupId (optional) 
     * @param checkpoint (optional) 
     * @param caseType (optional) 
     * @return OK
     */
    getAccessRules(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, role?: string | undefined, groupId?: string | undefined, checkpoint?: string | undefined, caseType?: string | undefined): Observable<AccessRuleResultSet> {
        let url_ = this.baseUrl + "/api/manage/access-rules?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (role === null)
            throw new Error("The parameter 'role' cannot be null.");
        else if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "GroupId=" + encodeURIComponent("" + groupId) + "&";
        if (checkpoint === null)
            throw new Error("The parameter 'checkpoint' cannot be null.");
        else if (checkpoint !== undefined)
            url_ += "Checkpoint=" + encodeURIComponent("" + checkpoint) + "&";
        if (caseType === null)
            throw new Error("The parameter 'caseType' cannot be null.");
        else if (caseType !== undefined)
            url_ += "CaseType=" + encodeURIComponent("" + caseType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccessRules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccessRules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccessRuleResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccessRuleResultSet>;
        }));
    }

    protected processGetAccessRules(response: HttpResponseBase): Observable<AccessRuleResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessRuleResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete an existing Access rule.
     * @return No Content
     */
    deleteAccessRule(ruleId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/access-rules/{ruleId}";
        if (ruleId === undefined || ruleId === null)
            throw new Error("The parameter 'ruleId' must be defined.");
        url_ = url_.replace("{ruleId}", encodeURIComponent("" + ruleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccessRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccessRule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAccessRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update an existing Access rule.
     * @return No Content
     */
    updateAccessRule(ruleId: string, accessLevel: number): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/access-rules/{ruleId}/{accessLevel}";
        if (ruleId === undefined || ruleId === null)
            throw new Error("The parameter 'ruleId' must be defined.");
        url_ = url_.replace("{ruleId}", encodeURIComponent("" + ruleId));
        if (accessLevel === undefined || accessLevel === null)
            throw new Error("The parameter 'accessLevel' must be defined.");
        url_ = url_.replace("{accessLevel}", encodeURIComponent("" + accessLevel));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccessRule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccessRule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAccessRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Add a new Access rule for admin Users.
     * @return No Content
     */
    createAccessRuleAdmin(body: AddAccessRuleRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/access-rules/admin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAccessRuleAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAccessRuleAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateAccessRuleAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Add a new Access rule for admin Users.
     * @return No Content
     */
    createBatchAccessRulesAdmin(body: AddAccessRuleRequest[]): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/access-rules/admin/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBatchAccessRulesAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBatchAccessRulesAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateBatchAccessRulesAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Add a new Access rule for a case.
     * @return No Content
     */
    createAccessRules(caseId: string, body: AddCaseAccessRuleRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/access-rules/case/{caseId}";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAccessRules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAccessRules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateAccessRules(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a batch of Access rules for a case.
     * @return No Content
     */
    updateBatchAccessRules(caseId: string, body: AddCaseAccessRuleRequest[]): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/access-rules/case/{caseId}/batch";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBatchAccessRules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBatchAccessRules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateBatchAccessRules(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Download attachment in a PDF format for back-office users.
     * @return OK
     */
    downloadAttachment(attachmentId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/manage/attachments/{attachmentId}/download";
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadAttachment(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get case types.
     * @param canCreate (optional) 
     * @return OK
     */
    getCaseTypesList(canCreate?: boolean | undefined): Observable<CaseTypePartialResultSet> {
        let url_ = this.baseUrl + "/api/manage/case-types?";
        if (canCreate === null)
            throw new Error("The parameter 'canCreate' cannot be null.");
        else if (canCreate !== undefined)
            url_ += "canCreate=" + encodeURIComponent("" + canCreate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseTypesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseTypesList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseTypePartialResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseTypePartialResultSet>;
        }));
    }

    protected processGetCaseTypesList(response: HttpResponseBase): Observable<CaseTypePartialResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseTypePartialResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create new case type.
     * @return No Content
     */
    createCaseType(body: CaseTypeRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/case-types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCaseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCaseType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateCaseType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get a specific Case Type by Id.
     * @return OK
     */
    getCaseTypeById(caseTypeId: string): Observable<CaseType> {
        let url_ = this.baseUrl + "/api/manage/case-types/{caseTypeId}";
        if (caseTypeId === undefined || caseTypeId === null)
            throw new Error("The parameter 'caseTypeId' must be defined.");
        url_ = url_.replace("{caseTypeId}", encodeURIComponent("" + caseTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseType>;
        }));
    }

    protected processGetCaseTypeById(response: HttpResponseBase): Observable<CaseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a specific Case Type.
     * @return OK
     */
    updateCaseType(caseTypeId: string, body: CaseTypeRequest): Observable<CaseType> {
        let url_ = this.baseUrl + "/api/manage/case-types/{caseTypeId}";
        if (caseTypeId === undefined || caseTypeId === null)
            throw new Error("The parameter 'caseTypeId' must be defined.");
        url_ = url_.replace("{caseTypeId}", encodeURIComponent("" + caseTypeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCaseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCaseType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseType>;
        }));
    }

    protected processUpdateCaseType(response: HttpResponseBase): Observable<CaseType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a specific Case Type.
     * @return No Content
     */
    deleteCaseType(caseTypeId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/case-types/{caseTypeId}";
        if (caseTypeId === undefined || caseTypeId === null)
            throw new Error("The parameter 'caseTypeId' must be defined.");
        url_ = url_.replace("{caseTypeId}", encodeURIComponent("" + caseTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCaseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCaseType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCaseType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a new case in draft mode.
     * @return OK
     */
    createDraftAdminCase(body: CreateDraftCaseRequest): Observable<CreateCaseResponse> {
        let url_ = this.baseUrl + "/api/manage/cases";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDraftAdminCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDraftAdminCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateCaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateCaseResponse>;
        }));
    }

    protected processCreateDraftAdminCase(response: HttpResponseBase): Observable<CreateCaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateCaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the list of all cases using the provided.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param ownerIds (optional) 
     * @param ownerNames (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @param caseTypeCodes (optional) 
     * @param checkpointTypeCodes (optional) 
     * @param groupIds (optional) 
     * @param metadata (optional) 
     * @param referenceNumbers (optional) 
     * @param data (optional) 
     * @param includeData (optional) 
     * @return OK
     */
    getCases(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, ownerIds?: string[] | undefined, ownerNames?: string[] | undefined, from?: Date | undefined, to?: Date | undefined, caseTypeCodes?: string[] | undefined, checkpointTypeCodes?: string[] | undefined, groupIds?: string[] | undefined, metadata?: string[] | undefined, referenceNumbers?: string[] | undefined, data?: string[] | undefined, includeData?: boolean | undefined): Observable<CasePartialResultSet> {
        let url_ = this.baseUrl + "/api/manage/cases?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (ownerIds === null)
            throw new Error("The parameter 'ownerIds' cannot be null.");
        else if (ownerIds !== undefined)
            ownerIds && ownerIds.forEach(item => { url_ += "OwnerIds=" + encodeURIComponent("" + item) + "&"; });
        if (ownerNames === null)
            throw new Error("The parameter 'ownerNames' cannot be null.");
        else if (ownerNames !== undefined)
            ownerNames && ownerNames.forEach(item => { url_ += "OwnerNames=" + encodeURIComponent("" + item) + "&"; });
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === null)
            throw new Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (caseTypeCodes === null)
            throw new Error("The parameter 'caseTypeCodes' cannot be null.");
        else if (caseTypeCodes !== undefined)
            caseTypeCodes && caseTypeCodes.forEach(item => { url_ += "CaseTypeCodes=" + encodeURIComponent("" + item) + "&"; });
        if (checkpointTypeCodes === null)
            throw new Error("The parameter 'checkpointTypeCodes' cannot be null.");
        else if (checkpointTypeCodes !== undefined)
            checkpointTypeCodes && checkpointTypeCodes.forEach(item => { url_ += "CheckpointTypeCodes=" + encodeURIComponent("" + item) + "&"; });
        if (groupIds === null)
            throw new Error("The parameter 'groupIds' cannot be null.");
        else if (groupIds !== undefined)
            groupIds && groupIds.forEach(item => { url_ += "GroupIds=" + encodeURIComponent("" + item) + "&"; });
        if (metadata === null)
            throw new Error("The parameter 'metadata' cannot be null.");
        else if (metadata !== undefined)
            metadata && metadata.forEach(item => { url_ += "Metadata=" + encodeURIComponent("" + item) + "&"; });
        if (referenceNumbers === null)
            throw new Error("The parameter 'referenceNumbers' cannot be null.");
        else if (referenceNumbers !== undefined)
            referenceNumbers && referenceNumbers.forEach(item => { url_ += "ReferenceNumbers=" + encodeURIComponent("" + item) + "&"; });
        if (data === null)
            throw new Error("The parameter 'data' cannot be null.");
        else if (data !== undefined)
            data && data.forEach(item => { url_ += "Data=" + encodeURIComponent("" + item) + "&"; });
        if (includeData === null)
            throw new Error("The parameter 'includeData' cannot be null.");
        else if (includeData !== undefined)
            url_ += "IncludeData=" + encodeURIComponent("" + includeData) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCases(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCases(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CasePartialResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CasePartialResultSet>;
        }));
    }

    protected processGetCases(response: HttpResponseBase): Observable<CasePartialResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CasePartialResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update the case with the business data as defined at the specific case type. This action is allowed only for draft cases.
     * @return No Content
     */
    updateAdminCase(caseId: string, body: UpdateCaseRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAdminCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAdminCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAdminCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a case with the specified id.
     * @return OK
     */
    getCaseById(caseId: string): Observable<Case> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Case>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Case>;
        }));
    }

    protected processGetCaseById(response: HttpResponseBase): Observable<Case> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Case.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Deletes a draft case with the specified id.
     * @return No Content
     */
    deleteDraftCase(caseId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDraftCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDraftCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDraftCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Download case in a PDF format.
     * @return OK
     */
    downloadCasePdf(caseId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}.pdf";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/pdf"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadCasePdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadCasePdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadCasePdf(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get Access rules for the specified case.
     * @return OK
     */
    getAccessRulesForCase(caseId: string): Observable<AccessRule[]> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/access-rules";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccessRulesForCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccessRulesForCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccessRule[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccessRule[]>;
        }));
    }

    protected processGetAccessRulesForCase(response: HttpResponseBase): Observable<AccessRule[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AccessRule.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the cases actions (Approval, edit, assignments, etc) for a case Id. Actions differ based on user role.
     * @return OK
     */
    getCaseActions(caseId: string): Observable<CaseActions> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/actions";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseActions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseActions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseActions>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseActions>;
        }));
    }

    protected processGetCaseActions(response: HttpResponseBase): Observable<CaseActions> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseActions.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Invoke the approval activity to approve or reject the case.
     * @return No Content
     */
    submitApproval(caseId: string, body: ApprovalRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/approve";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitApproval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitApproval(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitApproval(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Invoke the assign activity to assign the case to the caller user.
     * @return No Content
     */
    assignCase(caseId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/assign";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssignCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get a list of Attachments for a CaseId
     * @return OK
     */
    getCaseAttachments(caseId: string): Observable<CaseAttachmentResultSet> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/attachments";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseAttachmentResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseAttachmentResultSet>;
        }));
    }

    protected processGetCaseAttachments(response: HttpResponseBase): Observable<CaseAttachmentResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseAttachmentResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Add an attachment to an existing case regardless of its status and mode (draft or not).
     * @param file (optional) 
     * @return OK
     */
    uploadAdminCaseAttachment(caseId: string, file?: FileParameter | undefined): Observable<CasesAttachmentLink> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/attachments";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadAdminCaseAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadAdminCaseAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CasesAttachmentLink>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CasesAttachmentLink>;
        }));
    }

    protected processUploadAdminCaseAttachment(response: HttpResponseBase): Observable<CasesAttachmentLink> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CasesAttachmentLink.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get an Case Attachment
     */
    getCaseAttachment(caseId: string, attachmentId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/attachments/{attachmentId}";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetCaseAttachment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get a Case Attachment by field name.
     */
    getAttachmentByField(caseId: string, fieldName: string): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/attachments/{attachmentName}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (fieldName === undefined || fieldName === null)
            throw new Error("The parameter 'fieldName' must be defined and cannot be null.");
        else
            url_ += "fieldName=" + encodeURIComponent("" + fieldName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttachmentByField(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttachmentByField(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetAttachmentByField(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Add a comment to a case.
     * @return No Content
     */
    adminAddComment(caseId: string, body: SendCommentRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/comment";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdminAddComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdminAddComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdminAddComment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Patches the Case.Data object with an object passed in the body.
     * @return No Content
     */
    patchAdminCaseData(caseId: string, body: any): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/data";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatchAdminCaseData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatchAdminCaseData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPatchAdminCaseData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update the Case Data for the specific caseId according to https://datatracker.ietf.org/doc/html/rfc6902#appendix-A.
     * @return No Content
     */
    jsonPatchAdminCaseData(caseId: string, body: PatchJsonPathRequest[]): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/data-json";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJsonPatchAdminCaseData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJsonPatchAdminCaseData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processJsonPatchAdminCaseData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Invoke the edit activity to edit the data of the case.
     * @return No Content
     */
    editCase(caseId: string, body: EditCaseRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/edit";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Patches the metadata of a case.
     * @return No Content
     */
    patchCaseMetadata(caseId: string, body: { [key: string]: string; }): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/metadata";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatchCaseMetadata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatchCaseMetadata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPatchCaseMetadata(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get the reject reasons for a case.
     * @return OK
     */
    getCaseRejectReasons(caseId: string): Observable<RejectReason[]> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/reject-reasons";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseRejectReasons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseRejectReasons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RejectReason[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RejectReason[]>;
        }));
    }

    protected processGetCaseRejectReasons(response: HttpResponseBase): Observable<RejectReason[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RejectReason.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the cases that are related to the given id.
     * @return OK
     */
    getRelatedCases(caseId: string): Observable<CasePartial[]> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/related-cases";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRelatedCases(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRelatedCases(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CasePartial[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CasePartial[]>;
        }));
    }

    protected processGetRelatedCases(response: HttpResponseBase): Observable<CasePartial[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CasePartial.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Submit the case by removing the draft mode.
     * @return No Content
     */
    submitAdminCase(caseId: string, body: any): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/submit";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitAdminCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitAdminCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitAdminCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the timeline entries for a case.
     * @return OK
     */
    getCaseTimeline(caseId: string): Observable<TimelineEntry[]> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/timeline";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseTimeline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseTimeline(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimelineEntry[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimelineEntry[]>;
        }));
    }

    protected processGetCaseTimeline(response: HttpResponseBase): Observable<TimelineEntry[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TimelineEntry.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Invoke the action activity to trigger a business action for the case.
     * @return No Content
     */
    triggerAction(caseId: string, body: ActionRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/trigger-action";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTriggerAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTriggerAction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTriggerAction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get the distinct checkpoint types grouped by code.
     * @return OK
     */
    getDistinctCheckpointTypes(): Observable<CheckpointType[]> {
        let url_ = this.baseUrl + "/api/manage/checkpoint-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDistinctCheckpointTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDistinctCheckpointTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckpointType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckpointType[]>;
        }));
    }

    protected processGetDistinctCheckpointTypes(response: HttpResponseBase): Observable<CheckpointType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CheckpointType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Search contacts.
     * @param reference (optional) 
     * @param caseTypeCode (optional) 
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @return OK
     */
    getContacts(reference?: string | undefined, caseTypeCode?: string | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined): Observable<ContactResultSet> {
        let url_ = this.baseUrl + "/api/manage/integrations/contacts?";
        if (reference === null)
            throw new Error("The parameter 'reference' cannot be null.");
        else if (reference !== undefined)
            url_ += "Reference=" + encodeURIComponent("" + reference) + "&";
        if (caseTypeCode === null)
            throw new Error("The parameter 'caseTypeCode' cannot be null.");
        else if (caseTypeCode !== undefined)
            url_ += "CaseTypeCode=" + encodeURIComponent("" + caseTypeCode) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContacts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactResultSet>;
        }));
    }

    protected processGetContacts(response: HttpResponseBase): Observable<ContactResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Fetch contact data by contact.reference number for a specific case type code.
     * @return OK
     */
    getContactData(reference: string, caseTypeCode: string): Observable<Contact> {
        let url_ = this.baseUrl + "/api/manage/integrations/contacts/{referemce}/data/{caseTypeCode}?";
        if (caseTypeCode === undefined || caseTypeCode === null)
            throw new Error("The parameter 'caseTypeCode' must be defined.");
        url_ = url_.replace("{caseTypeCode}", encodeURIComponent("" + caseTypeCode));
        if (reference === undefined || reference === null)
            throw new Error("The parameter 'reference' must be defined and cannot be null.");
        else
            url_ += "reference=" + encodeURIComponent("" + reference) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Contact>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Contact>;
        }));
    }

    protected processGetContactData(response: HttpResponseBase): Observable<Contact> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contact.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get a lookup result by lookupName and options.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param filterTerms (optional) 
     * @return OK
     */
    getLookup(lookupName: string, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, filterTerms?: string[] | undefined): Observable<LookupItemResultSet> {
        let url_ = this.baseUrl + "/api/manage/lookups/{lookupName}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (filterTerms === null)
            throw new Error("The parameter 'filterTerms' cannot be null.");
        else if (filterTerms !== undefined)
            filterTerms && filterTerms.forEach(item => { url_ += "filterTerms=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupItemResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupItemResultSet>;
        }));
    }

    protected processGetLookup(response: HttpResponseBase): Observable<LookupItemResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LookupItemResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get the notification subscriptions for a user.
     * @return OK
     */
    getMySubscriptions(): Observable<NotificationSubscriptionResponse> {
        let url_ = this.baseUrl + "/api/manage/my/notifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMySubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMySubscriptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationSubscriptionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationSubscriptionResponse>;
        }));
    }

    protected processGetMySubscriptions(response: HttpResponseBase): Observable<NotificationSubscriptionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationSubscriptionResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Bad Request", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Store user's subscription settings.
     * @return No Content
     */
    subscribe(body: NotificationSubscriptionRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/my/notifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscribe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscribe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubscribe(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Bad Request", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get saved queries.
     * @return OK
     */
    getQueries(): Observable<Query[]> {
        let url_ = this.baseUrl + "/api/manage/queries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQueries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQueries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Query[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Query[]>;
        }));
    }

    protected processGetQueries(response: HttpResponseBase): Observable<Query[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Query.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Save a new query.
     * @return No Content
     */
    saveQuery(body: SaveQueryRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/queries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveQuery(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a query.
     * @return No Content
     */
    deleteQuery(queryId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/queries/{queryId}";
        if (queryId === undefined || queryId === null)
            throw new Error("The parameter 'queryId' must be defined.");
        url_ = url_.replace("{queryId}", encodeURIComponent("" + queryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteQuery(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get case report
     * @return OK
     */
    getCaseReport(reportTag: ReportTag): Observable<GroupByReportResult[]> {
        let url_ = this.baseUrl + "/api/manage/reports?";
        if (reportTag === undefined || reportTag === null)
            throw new Error("The parameter 'reportTag' must be defined and cannot be null.");
        else
            url_ += "reportTag=" + encodeURIComponent("" + reportTag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GroupByReportResult[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GroupByReportResult[]>;
        }));
    }

    protected processGetCaseReport(response: HttpResponseBase): Observable<GroupByReportResult[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupByReportResult.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AccessRule implements IAccessRule {
    id?: string | undefined;
    ruleCaseId?: string | undefined;
    ruleCaseTypeId?: string | undefined;
    ruleCheckpointTypeId?: string | undefined;
    memberRole?: string | undefined;
    memberGroupId?: string | undefined;
    memberUserId?: string | undefined;
    accessLevel?: number;

    constructor(data?: IAccessRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ruleCaseId = _data["ruleCaseId"];
            this.ruleCaseTypeId = _data["ruleCaseTypeId"];
            this.ruleCheckpointTypeId = _data["ruleCheckpointTypeId"];
            this.memberRole = _data["memberRole"];
            this.memberGroupId = _data["memberGroupId"];
            this.memberUserId = _data["memberUserId"];
            this.accessLevel = _data["accessLevel"];
        }
    }

    static fromJS(data: any): AccessRule {
        data = typeof data === 'object' ? data : {};
        let result = new AccessRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ruleCaseId"] = this.ruleCaseId;
        data["ruleCaseTypeId"] = this.ruleCaseTypeId;
        data["ruleCheckpointTypeId"] = this.ruleCheckpointTypeId;
        data["memberRole"] = this.memberRole;
        data["memberGroupId"] = this.memberGroupId;
        data["memberUserId"] = this.memberUserId;
        data["accessLevel"] = this.accessLevel;
        return data;
    }
}

export interface IAccessRule {
    id?: string | undefined;
    ruleCaseId?: string | undefined;
    ruleCaseTypeId?: string | undefined;
    ruleCheckpointTypeId?: string | undefined;
    memberRole?: string | undefined;
    memberGroupId?: string | undefined;
    memberUserId?: string | undefined;
    accessLevel?: number;
}

/** Α collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export class AccessRuleResultSet implements IAccessRuleResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: AccessRule[] | undefined;

    constructor(data?: IAccessRuleResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AccessRule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AccessRuleResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new AccessRuleResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Α collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export interface IAccessRuleResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: AccessRule[] | undefined;
}

export class ActionRequest implements IActionRequest {
    id?: string;
    value?: string | undefined;

    constructor(data?: IActionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ActionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ActionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data;
    }
}

export interface IActionRequest {
    id?: string;
    value?: string | undefined;
}

export class AddAccessRuleRequest implements IAddAccessRuleRequest {
    ruleCaseId?: string | undefined;
    ruleCheckpointTypeId?: string | undefined;
    ruleCaseTypeId?: string | undefined;
    memberRole?: string | undefined;
    memberGroupId?: string | undefined;
    memberUserId?: string | undefined;
    accessLevel?: number;

    constructor(data?: IAddAccessRuleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ruleCaseId = _data["ruleCaseId"];
            this.ruleCheckpointTypeId = _data["ruleCheckpointTypeId"];
            this.ruleCaseTypeId = _data["ruleCaseTypeId"];
            this.memberRole = _data["memberRole"];
            this.memberGroupId = _data["memberGroupId"];
            this.memberUserId = _data["memberUserId"];
            this.accessLevel = _data["accessLevel"];
        }
    }

    static fromJS(data: any): AddAccessRuleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddAccessRuleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleCaseId"] = this.ruleCaseId;
        data["ruleCheckpointTypeId"] = this.ruleCheckpointTypeId;
        data["ruleCaseTypeId"] = this.ruleCaseTypeId;
        data["memberRole"] = this.memberRole;
        data["memberGroupId"] = this.memberGroupId;
        data["memberUserId"] = this.memberUserId;
        data["accessLevel"] = this.accessLevel;
        return data;
    }
}

export interface IAddAccessRuleRequest {
    ruleCaseId?: string | undefined;
    ruleCheckpointTypeId?: string | undefined;
    ruleCaseTypeId?: string | undefined;
    memberRole?: string | undefined;
    memberGroupId?: string | undefined;
    memberUserId?: string | undefined;
    accessLevel?: number;
}

export class AddCaseAccessRuleRequest implements IAddCaseAccessRuleRequest {
    ruleCheckpointTypeId?: string | undefined;
    memberRole?: string | undefined;
    memberGroupId?: string | undefined;
    memberUserId?: string | undefined;
    accessLevel?: number;

    constructor(data?: IAddCaseAccessRuleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ruleCheckpointTypeId = _data["ruleCheckpointTypeId"];
            this.memberRole = _data["memberRole"];
            this.memberGroupId = _data["memberGroupId"];
            this.memberUserId = _data["memberUserId"];
            this.accessLevel = _data["accessLevel"];
        }
    }

    static fromJS(data: any): AddCaseAccessRuleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddCaseAccessRuleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleCheckpointTypeId"] = this.ruleCheckpointTypeId;
        data["memberRole"] = this.memberRole;
        data["memberGroupId"] = this.memberGroupId;
        data["memberUserId"] = this.memberUserId;
        data["accessLevel"] = this.accessLevel;
        return data;
    }
}

export interface IAddCaseAccessRuleRequest {
    ruleCheckpointTypeId?: string | undefined;
    memberRole?: string | undefined;
    memberGroupId?: string | undefined;
    memberUserId?: string | undefined;
    accessLevel?: number;
}

export enum Approval {
    Approve = "Approve",
    Reject = "Reject",
}

export class ApprovalRequest implements IApprovalRequest {
    action?: Approval;
    comment?: string | undefined;

    constructor(data?: IApprovalRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): ApprovalRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IApprovalRequest {
    action?: Approval;
    comment?: string | undefined;
}

export class AuditMeta implements IAuditMeta {
    id?: string | undefined;
    name?: string | undefined;
    email?: string | undefined;
    when?: Date | undefined;

    constructor(data?: IAuditMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.when = _data["when"] ? new Date(_data["when"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditMeta {
        data = typeof data === 'object' ? data : {};
        let result = new AuditMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["when"] = this.when ? this.when.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAuditMeta {
    id?: string | undefined;
    name?: string | undefined;
    email?: string | undefined;
    when?: Date | undefined;
}

export class Case implements ICase {
    id?: string;
    referenceNumber?: number | undefined;
    ownerId?: string | undefined;
    ownerName?: string | undefined;
    userId?: string | undefined;
    createdByWhen?: Date | undefined;
    createdById?: string | undefined;
    createdByEmail?: string | undefined;
    createdByName?: string | undefined;
    caseType?: CaseTypePartial;
    metadata?: { [key: string]: string; } | undefined;
    groupId?: string | undefined;
    checkpointType?: CheckpointType;
    data?: any | undefined;
    assignedToName?: string | undefined;
    channel?: string | undefined;
    draft?: boolean;
    accessLevel?: number;
    attachments?: CaseAttachment[] | undefined;
    approvers?: AuditMeta[] | undefined;

    constructor(data?: ICase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.referenceNumber = _data["referenceNumber"];
            this.ownerId = _data["ownerId"];
            this.ownerName = _data["ownerName"];
            this.userId = _data["userId"];
            this.createdByWhen = _data["createdByWhen"] ? new Date(_data["createdByWhen"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.createdByEmail = _data["createdByEmail"];
            this.createdByName = _data["createdByName"];
            this.caseType = _data["caseType"] ? CaseTypePartial.fromJS(_data["caseType"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.groupId = _data["groupId"];
            this.checkpointType = _data["checkpointType"] ? CheckpointType.fromJS(_data["checkpointType"]) : <any>undefined;
            this.data = _data["data"];
            this.assignedToName = _data["assignedToName"];
            this.channel = _data["channel"];
            this.draft = _data["draft"];
            this.accessLevel = _data["accessLevel"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(CaseAttachment.fromJS(item));
            }
            if (Array.isArray(_data["approvers"])) {
                this.approvers = [] as any;
                for (let item of _data["approvers"])
                    this.approvers!.push(AuditMeta.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Case {
        data = typeof data === 'object' ? data : {};
        let result = new Case();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["referenceNumber"] = this.referenceNumber;
        data["ownerId"] = this.ownerId;
        data["ownerName"] = this.ownerName;
        data["userId"] = this.userId;
        data["createdByWhen"] = this.createdByWhen ? this.createdByWhen.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["createdByEmail"] = this.createdByEmail;
        data["createdByName"] = this.createdByName;
        data["caseType"] = this.caseType ? this.caseType.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["groupId"] = this.groupId;
        data["checkpointType"] = this.checkpointType ? this.checkpointType.toJSON() : <any>undefined;
        data["data"] = this.data;
        data["assignedToName"] = this.assignedToName;
        data["channel"] = this.channel;
        data["draft"] = this.draft;
        data["accessLevel"] = this.accessLevel;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.approvers)) {
            data["approvers"] = [];
            for (let item of this.approvers)
                data["approvers"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICase {
    id?: string;
    referenceNumber?: number | undefined;
    ownerId?: string | undefined;
    ownerName?: string | undefined;
    userId?: string | undefined;
    createdByWhen?: Date | undefined;
    createdById?: string | undefined;
    createdByEmail?: string | undefined;
    createdByName?: string | undefined;
    caseType?: CaseTypePartial;
    metadata?: { [key: string]: string; } | undefined;
    groupId?: string | undefined;
    checkpointType?: CheckpointType;
    data?: any | undefined;
    assignedToName?: string | undefined;
    channel?: string | undefined;
    draft?: boolean;
    accessLevel?: number;
    attachments?: CaseAttachment[] | undefined;
    approvers?: AuditMeta[] | undefined;
}

export class CaseActions implements ICaseActions {
    hasAssignment?: boolean;
    hasUnassignment?: boolean;
    hasEdit?: boolean;
    hasApproval?: boolean;
    customActions?: CustomCaseAction[] | undefined;

    constructor(data?: ICaseActions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasAssignment = _data["hasAssignment"];
            this.hasUnassignment = _data["hasUnassignment"];
            this.hasEdit = _data["hasEdit"];
            this.hasApproval = _data["hasApproval"];
            if (Array.isArray(_data["customActions"])) {
                this.customActions = [] as any;
                for (let item of _data["customActions"])
                    this.customActions!.push(CustomCaseAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CaseActions {
        data = typeof data === 'object' ? data : {};
        let result = new CaseActions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasAssignment"] = this.hasAssignment;
        data["hasUnassignment"] = this.hasUnassignment;
        data["hasEdit"] = this.hasEdit;
        data["hasApproval"] = this.hasApproval;
        if (Array.isArray(this.customActions)) {
            data["customActions"] = [];
            for (let item of this.customActions)
                data["customActions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICaseActions {
    hasAssignment?: boolean;
    hasUnassignment?: boolean;
    hasEdit?: boolean;
    hasApproval?: boolean;
    customActions?: CustomCaseAction[] | undefined;
}

export class CaseAttachment implements ICaseAttachment {
    id?: string;
    fileName?: string | undefined;
    contentType?: string | undefined;
    fileExtension?: string | undefined;
    data?: string | undefined;

    constructor(data?: ICaseAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileName = _data["fileName"];
            this.contentType = _data["contentType"];
            this.fileExtension = _data["fileExtension"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): CaseAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new CaseAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileName"] = this.fileName;
        data["contentType"] = this.contentType;
        data["fileExtension"] = this.fileExtension;
        data["data"] = this.data;
        return data;
    }
}

export interface ICaseAttachment {
    id?: string;
    fileName?: string | undefined;
    contentType?: string | undefined;
    fileExtension?: string | undefined;
    data?: string | undefined;
}

/** Α collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export class CaseAttachmentResultSet implements ICaseAttachmentResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: CaseAttachment[] | undefined;

    constructor(data?: ICaseAttachmentResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CaseAttachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CaseAttachmentResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new CaseAttachmentResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Α collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export interface ICaseAttachmentResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: CaseAttachment[] | undefined;
}

export class CasePartial implements ICasePartial {
    id?: string;
    referenceNumber?: number | undefined;
    ownerId?: string | undefined;
    ownerName?: string | undefined;
    userId?: string | undefined;
    createdByWhen?: Date | undefined;
    createdById?: string | undefined;
    createdByEmail?: string | undefined;
    createdByName?: string | undefined;
    caseType?: CaseTypePartial;
    metadata?: { [key: string]: string; } | undefined;
    groupId?: string | undefined;
    checkpointType?: CheckpointType;
    data?: any | undefined;
    assignedToName?: string | undefined;
    channel?: string | undefined;
    draft?: boolean;
    accessLevel?: number;

    constructor(data?: ICasePartial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.referenceNumber = _data["referenceNumber"];
            this.ownerId = _data["ownerId"];
            this.ownerName = _data["ownerName"];
            this.userId = _data["userId"];
            this.createdByWhen = _data["createdByWhen"] ? new Date(_data["createdByWhen"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.createdByEmail = _data["createdByEmail"];
            this.createdByName = _data["createdByName"];
            this.caseType = _data["caseType"] ? CaseTypePartial.fromJS(_data["caseType"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.groupId = _data["groupId"];
            this.checkpointType = _data["checkpointType"] ? CheckpointType.fromJS(_data["checkpointType"]) : <any>undefined;
            this.data = _data["data"];
            this.assignedToName = _data["assignedToName"];
            this.channel = _data["channel"];
            this.draft = _data["draft"];
            this.accessLevel = _data["accessLevel"];
        }
    }

    static fromJS(data: any): CasePartial {
        data = typeof data === 'object' ? data : {};
        let result = new CasePartial();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["referenceNumber"] = this.referenceNumber;
        data["ownerId"] = this.ownerId;
        data["ownerName"] = this.ownerName;
        data["userId"] = this.userId;
        data["createdByWhen"] = this.createdByWhen ? this.createdByWhen.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["createdByEmail"] = this.createdByEmail;
        data["createdByName"] = this.createdByName;
        data["caseType"] = this.caseType ? this.caseType.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["groupId"] = this.groupId;
        data["checkpointType"] = this.checkpointType ? this.checkpointType.toJSON() : <any>undefined;
        data["data"] = this.data;
        data["assignedToName"] = this.assignedToName;
        data["channel"] = this.channel;
        data["draft"] = this.draft;
        data["accessLevel"] = this.accessLevel;
        return data;
    }
}

export interface ICasePartial {
    id?: string;
    referenceNumber?: number | undefined;
    ownerId?: string | undefined;
    ownerName?: string | undefined;
    userId?: string | undefined;
    createdByWhen?: Date | undefined;
    createdById?: string | undefined;
    createdByEmail?: string | undefined;
    createdByName?: string | undefined;
    caseType?: CaseTypePartial;
    metadata?: { [key: string]: string; } | undefined;
    groupId?: string | undefined;
    checkpointType?: CheckpointType;
    data?: any | undefined;
    assignedToName?: string | undefined;
    channel?: string | undefined;
    draft?: boolean;
    accessLevel?: number;
}

/** Α collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export class CasePartialResultSet implements ICasePartialResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: CasePartial[] | undefined;

    constructor(data?: ICasePartialResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CasePartial.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CasePartialResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new CasePartialResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Α collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export interface ICasePartialResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: CasePartial[] | undefined;
}

export enum CaseStatus {
    Submitted = "Submitted",
    InProgress = "InProgress",
    Completed = "Completed",
    Deleted = "Deleted",
}

export class CaseType implements ICaseType {
    id?: string;
    code?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    dataSchema?: any | undefined;
    layout?: any | undefined;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: CaseTypeTranslation; } | undefined;
    layoutTranslations?: { [key: string]: string; } | undefined;
    tags?: string | undefined;
    config?: any | undefined;
    canCreateRoles?: string | undefined;
    isMenuItem?: boolean;
    gridFilterConfig?: any | undefined;
    gridColumnConfig?: any | undefined;
    checkpointTypes?: CheckpointTypeDetails[] | undefined;
    order?: number | undefined;

    constructor(data?: ICaseType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.dataSchema = _data["dataSchema"];
            this.layout = _data["layout"];
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? CaseTypeTranslation.fromJS(_data["translations"][key]) : new CaseTypeTranslation();
                }
            }
            if (_data["layoutTranslations"]) {
                this.layoutTranslations = {} as any;
                for (let key in _data["layoutTranslations"]) {
                    if (_data["layoutTranslations"].hasOwnProperty(key))
                        (<any>this.layoutTranslations)![key] = _data["layoutTranslations"][key];
                }
            }
            this.tags = _data["tags"];
            this.config = _data["config"];
            this.canCreateRoles = _data["canCreateRoles"];
            this.isMenuItem = _data["isMenuItem"];
            this.gridFilterConfig = _data["gridFilterConfig"];
            this.gridColumnConfig = _data["gridColumnConfig"];
            if (Array.isArray(_data["checkpointTypes"])) {
                this.checkpointTypes = [] as any;
                for (let item of _data["checkpointTypes"])
                    this.checkpointTypes!.push(CheckpointTypeDetails.fromJS(item));
            }
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): CaseType {
        data = typeof data === 'object' ? data : {};
        let result = new CaseType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["title"] = this.title;
        data["description"] = this.description;
        data["dataSchema"] = this.dataSchema;
        data["layout"] = this.layout;
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        if (this.layoutTranslations) {
            data["layoutTranslations"] = {};
            for (let key in this.layoutTranslations) {
                if (this.layoutTranslations.hasOwnProperty(key))
                    (<any>data["layoutTranslations"])[key] = (<any>this.layoutTranslations)[key];
            }
        }
        data["tags"] = this.tags;
        data["config"] = this.config;
        data["canCreateRoles"] = this.canCreateRoles;
        data["isMenuItem"] = this.isMenuItem;
        data["gridFilterConfig"] = this.gridFilterConfig;
        data["gridColumnConfig"] = this.gridColumnConfig;
        if (Array.isArray(this.checkpointTypes)) {
            data["checkpointTypes"] = [];
            for (let item of this.checkpointTypes)
                data["checkpointTypes"].push(item.toJSON());
        }
        data["order"] = this.order;
        return data;
    }
}

export interface ICaseType {
    id?: string;
    code?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    dataSchema?: any | undefined;
    layout?: any | undefined;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: CaseTypeTranslation; } | undefined;
    layoutTranslations?: { [key: string]: string; } | undefined;
    tags?: string | undefined;
    config?: any | undefined;
    canCreateRoles?: string | undefined;
    isMenuItem?: boolean;
    gridFilterConfig?: any | undefined;
    gridColumnConfig?: any | undefined;
    checkpointTypes?: CheckpointTypeDetails[] | undefined;
    order?: number | undefined;
}

export class CaseTypePartial implements ICaseTypePartial {
    id?: string;
    code?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    dataSchema?: any | undefined;
    layout?: any | undefined;
    layoutTranslations?: { [key: string]: string; } | undefined;
    tags?: string | undefined;
    config?: any | undefined;
    order?: number | undefined;
    canCreateRoles?: string[] | undefined;
    category?: Category;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: CaseTypeTranslation; } | undefined;
    isMenuItem?: boolean;
    gridFilterConfig?: any | undefined;
    gridColumnConfig?: any | undefined;

    constructor(data?: ICaseTypePartial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.dataSchema = _data["dataSchema"];
            this.layout = _data["layout"];
            if (_data["layoutTranslations"]) {
                this.layoutTranslations = {} as any;
                for (let key in _data["layoutTranslations"]) {
                    if (_data["layoutTranslations"].hasOwnProperty(key))
                        (<any>this.layoutTranslations)![key] = _data["layoutTranslations"][key];
                }
            }
            this.tags = _data["tags"];
            this.config = _data["config"];
            this.order = _data["order"];
            if (Array.isArray(_data["canCreateRoles"])) {
                this.canCreateRoles = [] as any;
                for (let item of _data["canCreateRoles"])
                    this.canCreateRoles!.push(item);
            }
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? CaseTypeTranslation.fromJS(_data["translations"][key]) : new CaseTypeTranslation();
                }
            }
            this.isMenuItem = _data["isMenuItem"];
            this.gridFilterConfig = _data["gridFilterConfig"];
            this.gridColumnConfig = _data["gridColumnConfig"];
        }
    }

    static fromJS(data: any): CaseTypePartial {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypePartial();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["title"] = this.title;
        data["description"] = this.description;
        data["dataSchema"] = this.dataSchema;
        data["layout"] = this.layout;
        if (this.layoutTranslations) {
            data["layoutTranslations"] = {};
            for (let key in this.layoutTranslations) {
                if (this.layoutTranslations.hasOwnProperty(key))
                    (<any>data["layoutTranslations"])[key] = (<any>this.layoutTranslations)[key];
            }
        }
        data["tags"] = this.tags;
        data["config"] = this.config;
        data["order"] = this.order;
        if (Array.isArray(this.canCreateRoles)) {
            data["canCreateRoles"] = [];
            for (let item of this.canCreateRoles)
                data["canCreateRoles"].push(item);
        }
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        data["isMenuItem"] = this.isMenuItem;
        data["gridFilterConfig"] = this.gridFilterConfig;
        data["gridColumnConfig"] = this.gridColumnConfig;
        return data;
    }
}

export interface ICaseTypePartial {
    id?: string;
    code?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    dataSchema?: any | undefined;
    layout?: any | undefined;
    layoutTranslations?: { [key: string]: string; } | undefined;
    tags?: string | undefined;
    config?: any | undefined;
    order?: number | undefined;
    canCreateRoles?: string[] | undefined;
    category?: Category;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: CaseTypeTranslation; } | undefined;
    isMenuItem?: boolean;
    gridFilterConfig?: any | undefined;
    gridColumnConfig?: any | undefined;
}

/** Α collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export class CaseTypePartialResultSet implements ICaseTypePartialResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: CaseTypePartial[] | undefined;

    constructor(data?: ICaseTypePartialResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CaseTypePartial.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CaseTypePartialResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypePartialResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Α collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export interface ICaseTypePartialResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: CaseTypePartial[] | undefined;
}

export class CaseTypeRequest implements ICaseTypeRequest {
    id?: string | undefined;
    code?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    dataSchema?: any | undefined;
    layout?: any | undefined;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: CaseTypeTranslation; } | undefined;
    layoutTranslations?: { [key: string]: string; } | undefined;
    tags?: string | undefined;
    config?: any | undefined;
    canCreateRoles?: string | undefined;
    order?: number | undefined;
    isMenuItem?: boolean;
    gridFilterConfig?: any | undefined;
    gridColumnConfig?: any | undefined;

    constructor(data?: ICaseTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.dataSchema = _data["dataSchema"];
            this.layout = _data["layout"];
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? CaseTypeTranslation.fromJS(_data["translations"][key]) : new CaseTypeTranslation();
                }
            }
            if (_data["layoutTranslations"]) {
                this.layoutTranslations = {} as any;
                for (let key in _data["layoutTranslations"]) {
                    if (_data["layoutTranslations"].hasOwnProperty(key))
                        (<any>this.layoutTranslations)![key] = _data["layoutTranslations"][key];
                }
            }
            this.tags = _data["tags"];
            this.config = _data["config"];
            this.canCreateRoles = _data["canCreateRoles"];
            this.order = _data["order"];
            this.isMenuItem = _data["isMenuItem"];
            this.gridFilterConfig = _data["gridFilterConfig"];
            this.gridColumnConfig = _data["gridColumnConfig"];
        }
    }

    static fromJS(data: any): CaseTypeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["title"] = this.title;
        data["description"] = this.description;
        data["dataSchema"] = this.dataSchema;
        data["layout"] = this.layout;
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        if (this.layoutTranslations) {
            data["layoutTranslations"] = {};
            for (let key in this.layoutTranslations) {
                if (this.layoutTranslations.hasOwnProperty(key))
                    (<any>data["layoutTranslations"])[key] = (<any>this.layoutTranslations)[key];
            }
        }
        data["tags"] = this.tags;
        data["config"] = this.config;
        data["canCreateRoles"] = this.canCreateRoles;
        data["order"] = this.order;
        data["isMenuItem"] = this.isMenuItem;
        data["gridFilterConfig"] = this.gridFilterConfig;
        data["gridColumnConfig"] = this.gridColumnConfig;
        return data;
    }
}

export interface ICaseTypeRequest {
    id?: string | undefined;
    code?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    dataSchema?: any | undefined;
    layout?: any | undefined;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: CaseTypeTranslation; } | undefined;
    layoutTranslations?: { [key: string]: string; } | undefined;
    tags?: string | undefined;
    config?: any | undefined;
    canCreateRoles?: string | undefined;
    order?: number | undefined;
    isMenuItem?: boolean;
    gridFilterConfig?: any | undefined;
    gridColumnConfig?: any | undefined;
}

export class CaseTypeTranslation implements ICaseTypeTranslation {
    title?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICaseTypeTranslation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CaseTypeTranslation {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypeTranslation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        return data;
    }
}

export interface ICaseTypeTranslation {
    title?: string | undefined;
    description?: string | undefined;
}

export class CasesAttachmentLink implements ICasesAttachmentLink {
    id?: string;
    fileGuid?: string;
    permaLink?: string | undefined;
    label?: string | undefined;
    size?: number;
    readonly sizeText?: string | undefined;
    contentType?: string | undefined;

    constructor(data?: ICasesAttachmentLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileGuid = _data["fileGuid"];
            this.permaLink = _data["permaLink"];
            this.label = _data["label"];
            this.size = _data["size"];
            (<any>this).sizeText = _data["sizeText"];
            this.contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): CasesAttachmentLink {
        data = typeof data === 'object' ? data : {};
        let result = new CasesAttachmentLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileGuid"] = this.fileGuid;
        data["permaLink"] = this.permaLink;
        data["label"] = this.label;
        data["size"] = this.size;
        data["sizeText"] = this.sizeText;
        data["contentType"] = this.contentType;
        return data;
    }
}

export interface ICasesAttachmentLink {
    id?: string;
    fileGuid?: string;
    permaLink?: string | undefined;
    label?: string | undefined;
    size?: number;
    sizeText?: string | undefined;
    contentType?: string | undefined;
}

export class Category implements ICategory {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    order?: number | undefined;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: CategoryTranslation; } | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.order = _data["order"];
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? CategoryTranslation.fromJS(_data["translations"][key]) : new CategoryTranslation();
                }
            }
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["order"] = this.order;
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface ICategory {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    order?: number | undefined;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: CategoryTranslation; } | undefined;
}

export class CategoryTranslation implements ICategoryTranslation {
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICategoryTranslation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CategoryTranslation {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryTranslation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface ICategoryTranslation {
    name?: string | undefined;
    description?: string | undefined;
}

export class Checkpoint implements ICheckpoint {
    id?: string;
    checkpointType?: CheckpointType;
    completedDate?: Date | undefined;
    dueDate?: Date | undefined;

    constructor(data?: ICheckpoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.checkpointType = _data["checkpointType"] ? CheckpointType.fromJS(_data["checkpointType"]) : <any>undefined;
            this.completedDate = _data["completedDate"] ? new Date(_data["completedDate"].toString()) : <any>undefined;
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Checkpoint {
        data = typeof data === 'object' ? data : {};
        let result = new Checkpoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checkpointType"] = this.checkpointType ? this.checkpointType.toJSON() : <any>undefined;
        data["completedDate"] = this.completedDate ? this.completedDate.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICheckpoint {
    id?: string;
    checkpointType?: CheckpointType;
    completedDate?: Date | undefined;
    dueDate?: Date | undefined;
}

export class CheckpointType implements ICheckpointType {
    id?: string;
    code?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    status?: CaseStatus;
    private?: boolean | undefined;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: CheckpointTypeTranslation; } | undefined;

    constructor(data?: ICheckpointType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.private = _data["private"];
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? CheckpointTypeTranslation.fromJS(_data["translations"][key]) : new CheckpointTypeTranslation();
                }
            }
        }
    }

    static fromJS(data: any): CheckpointType {
        data = typeof data === 'object' ? data : {};
        let result = new CheckpointType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["title"] = this.title;
        data["description"] = this.description;
        data["status"] = this.status;
        data["private"] = this.private;
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface ICheckpointType {
    id?: string;
    code?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    status?: CaseStatus;
    private?: boolean | undefined;
    /** A type that models the translation of an object. */
    translations?: { [key: string]: CheckpointTypeTranslation; } | undefined;
}

export class CheckpointTypeDetails implements ICheckpointTypeDetails {
    id?: string;
    code?: string | undefined;
    description?: string | undefined;
    status?: CaseStatus;
    private?: boolean;
    roles?: string[] | undefined;

    constructor(data?: ICheckpointTypeDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.status = _data["status"];
            this.private = _data["private"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CheckpointTypeDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CheckpointTypeDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["description"] = this.description;
        data["status"] = this.status;
        data["private"] = this.private;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ICheckpointTypeDetails {
    id?: string;
    code?: string | undefined;
    description?: string | undefined;
    status?: CaseStatus;
    private?: boolean;
    roles?: string[] | undefined;
}

export class CheckpointTypeTranslation implements ICheckpointTypeTranslation {
    title?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICheckpointTypeTranslation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CheckpointTypeTranslation {
        data = typeof data === 'object' ? data : {};
        let result = new CheckpointTypeTranslation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        return data;
    }
}

export interface ICheckpointTypeTranslation {
    title?: string | undefined;
    description?: string | undefined;
}

export class Comment implements IComment {
    id?: string;
    text?: string | undefined;
    isCustomer?: boolean | undefined;
    private?: boolean | undefined;
    attachment?: CasesAttachmentLink;
    replyToComment?: Comment;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.isCustomer = _data["isCustomer"];
            this.private = _data["private"];
            this.attachment = _data["attachment"] ? CasesAttachmentLink.fromJS(_data["attachment"]) : <any>undefined;
            this.replyToComment = _data["replyToComment"] ? Comment.fromJS(_data["replyToComment"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["isCustomer"] = this.isCustomer;
        data["private"] = this.private;
        data["attachment"] = this.attachment ? this.attachment.toJSON() : <any>undefined;
        data["replyToComment"] = this.replyToComment ? this.replyToComment.toJSON() : <any>undefined;
        return data;
    }
}

export interface IComment {
    id?: string;
    text?: string | undefined;
    isCustomer?: boolean | undefined;
    private?: boolean | undefined;
    attachment?: CasesAttachmentLink;
    replyToComment?: Comment;
}

export class Contact implements IContact {
    userId?: string | undefined;
    reference?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    groupId?: string | undefined;
    tin?: string | undefined;
    metadata?: { [key: string]: string; } | undefined;
    formData?: any | undefined;

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.reference = _data["reference"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.groupId = _data["groupId"];
            this.tin = _data["tin"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.formData = _data["formData"];
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["reference"] = this.reference;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["groupId"] = this.groupId;
        data["tin"] = this.tin;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["formData"] = this.formData;
        return data;
    }
}

export interface IContact {
    userId?: string | undefined;
    reference?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    groupId?: string | undefined;
    tin?: string | undefined;
    metadata?: { [key: string]: string; } | undefined;
    formData?: any | undefined;
}

export class ContactMeta implements IContactMeta {
    userId?: string | undefined;
    reference?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    readonly fullName?: string | undefined;

    constructor(data?: IContactMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.reference = _data["reference"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            (<any>this).fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): ContactMeta {
        data = typeof data === 'object' ? data : {};
        let result = new ContactMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["reference"] = this.reference;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        return data;
    }
}

export interface IContactMeta {
    userId?: string | undefined;
    reference?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
}

/** Α collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export class ContactResultSet implements IContactResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: Contact[] | undefined;

    constructor(data?: IContactResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Contact.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new ContactResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Α collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export interface IContactResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: Contact[] | undefined;
}

export class CreateCaseResponse implements ICreateCaseResponse {
    id?: string;
    created?: Date;

    constructor(data?: ICreateCaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateCaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateCaseResponse {
    id?: string;
    created?: Date;
}

export class CreateDraftCaseRequest implements ICreateDraftCaseRequest {
    caseTypeCode?: string | undefined;
    groupId?: string | undefined;
    owner?: ContactMeta;
    metadata?: { [key: string]: string; } | undefined;
    channel?: string | undefined;

    constructor(data?: ICreateDraftCaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.caseTypeCode = _data["caseTypeCode"];
            this.groupId = _data["groupId"];
            this.owner = _data["owner"] ? ContactMeta.fromJS(_data["owner"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.channel = _data["channel"];
        }
    }

    static fromJS(data: any): CreateDraftCaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDraftCaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caseTypeCode"] = this.caseTypeCode;
        data["groupId"] = this.groupId;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["channel"] = this.channel;
        return data;
    }
}

export interface ICreateDraftCaseRequest {
    caseTypeCode?: string | undefined;
    groupId?: string | undefined;
    owner?: ContactMeta;
    metadata?: { [key: string]: string; } | undefined;
    channel?: string | undefined;
}

export class CustomCaseAction implements ICustomCaseAction {
    id?: string | undefined;
    name?: string | undefined;
    label?: string | undefined;
    class?: string | undefined;
    redirectToList?: boolean | undefined;
    successMessage?: SuccessMessage;
    description?: string | undefined;
    defaultValue?: string | undefined;
    hasInput?: boolean | undefined;

    constructor(data?: ICustomCaseAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.label = _data["label"];
            this.class = _data["class"];
            this.redirectToList = _data["redirectToList"];
            this.successMessage = _data["successMessage"] ? SuccessMessage.fromJS(_data["successMessage"]) : <any>undefined;
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
            this.hasInput = _data["hasInput"];
        }
    }

    static fromJS(data: any): CustomCaseAction {
        data = typeof data === 'object' ? data : {};
        let result = new CustomCaseAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["label"] = this.label;
        data["class"] = this.class;
        data["redirectToList"] = this.redirectToList;
        data["successMessage"] = this.successMessage ? this.successMessage.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["hasInput"] = this.hasInput;
        return data;
    }
}

export interface ICustomCaseAction {
    id?: string | undefined;
    name?: string | undefined;
    label?: string | undefined;
    class?: string | undefined;
    redirectToList?: boolean | undefined;
    successMessage?: SuccessMessage;
    description?: string | undefined;
    defaultValue?: string | undefined;
    hasInput?: boolean | undefined;
}

export class EditCaseRequest implements IEditCaseRequest {
    data?: any | undefined;

    constructor(data?: IEditCaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): EditCaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EditCaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        return data;
    }
}

export interface IEditCaseRequest {
    data?: any | undefined;
}

export class GroupByReportResult implements IGroupByReportResult {
    count?: number;
    label?: string | undefined;

    constructor(data?: IGroupByReportResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): GroupByReportResult {
        data = typeof data === 'object' ? data : {};
        let result = new GroupByReportResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["label"] = this.label;
        return data;
    }
}

export interface IGroupByReportResult {
    count?: number;
    label?: string | undefined;
}

export class HttpValidationProblemDetails implements IHttpValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;

    constructor(data?: IHttpValidationProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        return data;
    }
}

export interface IHttpValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;
}

export class LookupItem implements ILookupItem {
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: ILookupItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): LookupItem {
        data = typeof data === 'object' ? data : {};
        let result = new LookupItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface ILookupItem {
    name?: string | undefined;
    value?: string | undefined;
}

/** Α collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export class LookupItemResultSet implements ILookupItemResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: LookupItem[] | undefined;

    constructor(data?: ILookupItemResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LookupItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupItemResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new LookupItemResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Α collection wrapper that encapsulates the results of an API call or operation. Used usually for paginated results. */
export interface ILookupItemResultSet {
    /** Total results count. */
    count?: number;
    /** The actual items collection. These could be less in number than the Indice.Types.ResultSet`1.Count if the results refers to a page. */
    items?: LookupItem[] | undefined;
}

export class NotificationSubscription implements INotificationSubscription {
    caseTypeId?: string;
    email?: string | undefined;
    groupId?: string | undefined;

    constructor(data?: INotificationSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.caseTypeId = _data["caseTypeId"];
            this.email = _data["email"];
            this.groupId = _data["groupId"];
        }
    }

    static fromJS(data: any): NotificationSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caseTypeId"] = this.caseTypeId;
        data["email"] = this.email;
        data["groupId"] = this.groupId;
        return data;
    }
}

export interface INotificationSubscription {
    caseTypeId?: string;
    email?: string | undefined;
    groupId?: string | undefined;
}

export class NotificationSubscriptionRequest implements INotificationSubscriptionRequest {
    caseTypeIds?: string[] | undefined;

    constructor(data?: INotificationSubscriptionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["caseTypeIds"])) {
                this.caseTypeIds = [] as any;
                for (let item of _data["caseTypeIds"])
                    this.caseTypeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): NotificationSubscriptionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.caseTypeIds)) {
            data["caseTypeIds"] = [];
            for (let item of this.caseTypeIds)
                data["caseTypeIds"].push(item);
        }
        return data;
    }
}

export interface INotificationSubscriptionRequest {
    caseTypeIds?: string[] | undefined;
}

export class NotificationSubscriptionResponse implements INotificationSubscriptionResponse {
    notificationSubscriptions?: NotificationSubscription[] | undefined;

    constructor(data?: INotificationSubscriptionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["notificationSubscriptions"])) {
                this.notificationSubscriptions = [] as any;
                for (let item of _data["notificationSubscriptions"])
                    this.notificationSubscriptions!.push(NotificationSubscription.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationSubscriptionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.notificationSubscriptions)) {
            data["notificationSubscriptions"] = [];
            for (let item of this.notificationSubscriptions)
                data["notificationSubscriptions"].push(item.toJSON());
        }
        return data;
    }
}

export interface INotificationSubscriptionResponse {
    notificationSubscriptions?: NotificationSubscription[] | undefined;
}

export enum OperationType {
    Unknown = "Unknown",
    Add = "Add",
    Remove = "Remove",
    Replace = "Replace",
    Move = "Move",
    Copy = "Copy",
    Test = "Test",
}

export class PatchJsonPathRequest implements IPatchJsonPathRequest {
    op?: OperationType;
    path?: string | undefined;
    value?: any | undefined;
    from?: string | undefined;

    constructor(data?: IPatchJsonPathRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.op = _data["op"];
            this.path = _data["path"];
            this.value = _data["value"];
            this.from = _data["from"];
        }
    }

    static fromJS(data: any): PatchJsonPathRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PatchJsonPathRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["op"] = this.op;
        data["path"] = this.path;
        data["value"] = this.value;
        data["from"] = this.from;
        return data;
    }
}

export interface IPatchJsonPathRequest {
    op?: OperationType;
    path?: string | undefined;
    value?: any | undefined;
    from?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class Query implements IQuery {
    id?: string;
    friendlyName?: string | undefined;
    parameters?: string | undefined;

    constructor(data?: IQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.friendlyName = _data["friendlyName"];
            this.parameters = _data["parameters"];
        }
    }

    static fromJS(data: any): Query {
        data = typeof data === 'object' ? data : {};
        let result = new Query();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["friendlyName"] = this.friendlyName;
        data["parameters"] = this.parameters;
        return data;
    }
}

export interface IQuery {
    id?: string;
    friendlyName?: string | undefined;
    parameters?: string | undefined;
}

export class RejectReason implements IRejectReason {
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: IRejectReason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): RejectReason {
        data = typeof data === 'object' ? data : {};
        let result = new RejectReason();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IRejectReason {
    key?: string | undefined;
    value?: string | undefined;
}

export enum ReportTag {
    GroupedByCasetype = "GroupedByCasetype",
    AgentGroupedByCasetype = "AgentGroupedByCasetype",
    CustomerGroupedByCasetype = "CustomerGroupedByCasetype",
    GroupedByStatus = "GroupedByStatus",
    AgentGroupedByStatus = "AgentGroupedByStatus",
    CustomerGroupedByStatus = "CustomerGroupedByStatus",
    GroupedByGroupId = "GroupedByGroupId",
}

export class SaveQueryRequest implements ISaveQueryRequest {
    friendlyName?: string | undefined;
    parameters?: string | undefined;

    constructor(data?: ISaveQueryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.friendlyName = _data["friendlyName"];
            this.parameters = _data["parameters"];
        }
    }

    static fromJS(data: any): SaveQueryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SaveQueryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendlyName"] = this.friendlyName;
        data["parameters"] = this.parameters;
        return data;
    }
}

export interface ISaveQueryRequest {
    friendlyName?: string | undefined;
    parameters?: string | undefined;
}

export class SendCommentRequest implements ISendCommentRequest {
    replyToCommentId?: string | undefined;
    privateComment?: boolean | undefined;
    comment?: string | undefined;

    constructor(data?: ISendCommentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.replyToCommentId = _data["replyToCommentId"];
            this.privateComment = _data["privateComment"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): SendCommentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SendCommentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["replyToCommentId"] = this.replyToCommentId;
        data["privateComment"] = this.privateComment;
        data["comment"] = this.comment;
        return data;
    }
}

export interface ISendCommentRequest {
    replyToCommentId?: string | undefined;
    privateComment?: boolean | undefined;
    comment?: string | undefined;
}

export class SuccessMessage implements ISuccessMessage {
    title?: string | undefined;
    body?: string | undefined;

    constructor(data?: ISuccessMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): SuccessMessage {
        data = typeof data === 'object' ? data : {};
        let result = new SuccessMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["body"] = this.body;
        return data;
    }
}

export interface ISuccessMessage {
    title?: string | undefined;
    body?: string | undefined;
}

export class TimelineEntry implements ITimelineEntry {
    timestamp?: Date;
    createdBy?: AuditMeta;
    readonly isCheckpoint?: boolean;
    checkpoint?: Checkpoint;
    comment?: Comment;

    constructor(data?: ITimelineEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"] ? AuditMeta.fromJS(_data["createdBy"]) : <any>undefined;
            (<any>this).isCheckpoint = _data["isCheckpoint"];
            this.checkpoint = _data["checkpoint"] ? Checkpoint.fromJS(_data["checkpoint"]) : <any>undefined;
            this.comment = _data["comment"] ? Comment.fromJS(_data["comment"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TimelineEntry {
        data = typeof data === 'object' ? data : {};
        let result = new TimelineEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["isCheckpoint"] = this.isCheckpoint;
        data["checkpoint"] = this.checkpoint ? this.checkpoint.toJSON() : <any>undefined;
        data["comment"] = this.comment ? this.comment.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITimelineEntry {
    timestamp?: Date;
    createdBy?: AuditMeta;
    isCheckpoint?: boolean;
    checkpoint?: Checkpoint;
    comment?: Comment;
}

export class UpdateCaseRequest implements IUpdateCaseRequest {
    data?: any | undefined;

    constructor(data?: IUpdateCaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): UpdateCaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        return data;
    }
}

export interface IUpdateCaseRequest {
    data?: any | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}