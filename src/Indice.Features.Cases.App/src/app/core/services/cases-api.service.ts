//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const CASES_API_BASE_URL = new InjectionToken<string>('CASES_API_BASE_URL');

export interface ICasesApiService {
    /**
     * Download attachment in a PDF format for back-office users.
     * @param api_version (optional) 
     * @return Success
     */
    downloadAttachment(attachmentId: string, api_version?: string | undefined): Observable<FileResponse>;
    /**
     * Create a new case in draft mode.
     * @param api_version (optional) 
     * @param body (optional) The draft.
     * @return Success
     */
    createDraftAdminCase(api_version?: string | undefined, body?: CreateDraftCaseRequest | undefined): Observable<string>;
    /**
     * Gets the list of all cases using the provided Indice.Types.ListOptions.
     * @param filter_CustomerId (optional) The Id of the customer to filter.
     * @param filter_CustomerName (optional) The name of the customer to filter.
     * @param filter_From (optional) The created date of the case, starting from, to filter.
     * @param filter_To (optional) The create date of the case, ending to, to filter.
     * @param filter_CaseTypeCodes (optional) The list of case type codes to filter.
     * @param filter_CheckpointTypeCodes (optional) The list of checkpoint type codes to filter.
     * @param filter_GroupIds (optional) The list of groupIds to filter.
     * @param filter_Metadata (optional) Construct filter clauses based on the metadata you are adding to the cases in your installation.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param api_version (optional) 
     * @return OK
     */
    getCases(filter_CustomerId?: string | undefined, filter_CustomerName?: string | undefined, filter_From?: Date | undefined, filter_To?: Date | undefined, filter_CaseTypeCodes?: string[] | undefined, filter_CheckpointTypeCodes?: string[] | undefined, filter_GroupIds?: string[] | undefined, filter_Metadata?: string[] | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, api_version?: string | undefined): Observable<CasePartialResultSet>;
    /**
     * Update the case with the business data as defined at the specific case type. This action is allowed only for draft cases.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param body (optional) The update request.
     * @return No Content
     */
    updateAdminCase(caseId: string, api_version?: string | undefined, body?: UpdateCaseRequest | undefined): Observable<void>;
    /**
     * Gets a case with the specified id.
     * @param caseId The id of the case.
     * @param api_version (optional) 
     * @return OK
     */
    getCaseById(caseId: string, api_version?: string | undefined): Observable<CaseDetails>;
    /**
     * Deletes a draft case.
     * @param caseId The id of the case.
     * @param api_version (optional) 
     * @return No Content
     */
    deleteDraftCase(caseId: string, api_version?: string | undefined): Observable<void>;
    /**
     * Download case in a PDF format for backoffice users
     * @param api_version (optional) 
     * @return Success
     */
    downloadCasePdf(caseId: string, api_version?: string | undefined): Observable<FileResponse>;
    /**
     * Gets the cases actions (Approval, edit, assignments, etc) for a case Id. Actions differ based on user role.
     * @param caseId The id of the case.
     * @param api_version (optional) 
     * @return OK
     */
    getCaseActions(caseId: string, api_version?: string | undefined): Observable<CaseActions>;
    /**
     * Invoke the approval activity to approve or reject the case.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param body (optional) The approval request.
     * @return No Content
     */
    submitApproval(caseId: string, api_version?: string | undefined, body?: ApprovalRequest | undefined): Observable<void>;
    /**
     * Invoke the assign activity to assign the case to the caller user.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @return No Content
     */
    assignCase(caseId: string, api_version?: string | undefined): Observable<void>;
    /**
     * Get a list of Attachments for a CaseId
     * @param api_version (optional) 
     * @return Success
     */
    getCaseAttachments(caseId: string, api_version?: string | undefined): Observable<CaseAttachmentResultSet>;
    /**
     * Add an attachment to an existing case regardless of its status and mode (draft or not).
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param file (optional) 
     * @return Success
     */
    uploadAdminCaseAttachment(caseId: string, api_version?: string | undefined, file?: FileParameter | undefined): Observable<CasesAttachmentLink>;
    /**
     * Get an Case Attachment
     * @param api_version (optional) 
     * @return Success
     */
    getCaseAttachment(caseId: string, attachmentId: string, api_version?: string | undefined): Observable<FileResponse>;
    /**
     * Invoke the edit activity to edit the data of the case.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param body (optional) The case data in json format.
     * @return No Content
     */
    editCase(caseId: string, api_version?: string | undefined, body?: EditCaseRequest | undefined): Observable<void>;
    /**
     * Get the reject reasons for a case.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @return Success
     */
    getCaseRejectReasons(caseId: string, api_version?: string | undefined): Observable<RejectReason[]>;
    /**
     * Submit the case by removing the draft mode.
     * @param caseId The Id of the case.
     * @param data (optional) The data of the case.
     * @param api_version (optional) 
     * @return No Content
     */
    submitAdminCase(caseId: string, data?: string | undefined, api_version?: string | undefined): Observable<void>;
    /**
     * Gets the timeline entries for a case.
     * @param caseId The id of the case.
     * @param api_version (optional) 
     * @return OK
     */
    getCaseTimeline(caseId: string, api_version?: string | undefined): Observable<TimelineEntry[]>;
    /**
     * Invoke the action activity to trigger a business action for the case.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param body (optional) The action request.
     * @return No Content
     */
    triggerAction(caseId: string, api_version?: string | undefined, body?: ActionRequest | undefined): Observable<void>;
    /**
     * Get case types.
     * @param canCreate (optional) Differentiates between the case types that an admin user can 1) view and 2) select for a case creation
     * @param api_version (optional) 
     * @return Success
     */
    getCaseTypes(canCreate?: boolean | undefined, api_version?: string | undefined): Observable<CaseTypePartialResultSet>;
    /**
     * Create new case type.
     * @param api_version (optional) 
     * @param body (optional) 
     * @return No Content
     */
    createCaseType(api_version?: string | undefined, body?: CaseTypeRequest | undefined): Observable<void>;
    /**
     * Get a specific Case Type by Id.
     * @param caseTypeId The case type Id.
     * @param api_version (optional) 
     * @return Success
     */
    getCaseTypeById(caseTypeId: string, api_version?: string | undefined): Observable<CaseTypeDetails>;
    /**
     * Update a specific Case Type.
     * @param api_version (optional) 
     * @param body (optional) The new case type model.
     * @return Success
     */
    updateCaseType(caseTypeId: string, api_version?: string | undefined, body?: CaseTypeRequest | undefined): Observable<CaseTypeDetails>;
    /**
     * Delete a specific Case Type.
     * @param api_version (optional) 
     * @return No Content
     */
    deleteCaseType(caseTypeId: string, api_version?: string | undefined): Observable<void>;
    /**
     * Get Checkpoint types
     * @param api_version (optional) 
     * @return Success
     */
    getDistinctCheckpointNames(api_version?: string | undefined): Observable<string[]>;
    /**
     * Get Filters.
     * @param api_version (optional) 
     * @return Success
     */
    getFilters(api_version?: string | undefined): Observable<Filter[]>;
    /**
     * Save a new Filter.
     * @param api_version (optional) 
     * @param body (optional) 
     * @return No Content
     */
    saveFilter(api_version?: string | undefined, body?: SaveFilterRequest | undefined): Observable<void>;
    /**
     * Deletes a Filter.
     * @param filterId The id of the filter.
     * @param api_version (optional) 
     * @return No Content
     */
    deleteFilter(filterId: string, api_version?: string | undefined): Observable<void>;
    /**
     * Fetch customers.
     * @param customerId (optional) The Id of the customer as provided by the consumer/integrator.
     * @param caseTypeCode (optional) The case type code, used for filtering customers based on case type (implementantion on client code)
     * @param api_version (optional) 
     * @return Success
     */
    getCustomers(customerId?: string | undefined, caseTypeCode?: string | undefined, api_version?: string | undefined): Observable<CustomerDetails[]>;
    /**
     * Fetch customer data for a specific case type code.
     * @param customerId The Id of the customer to the integrator's system.
     * @param caseTypeCode The case type code.
     * @param api_version (optional) 
     * @return Success
     */
    getCustomerData(customerId: string, caseTypeCode: string, api_version?: string | undefined): Observable<CustomerData>;
    /**
     * Get a lookup by lookupName.
     * @param lookupName The lookup name to retrieve.
     * @param searchValues (optional) Any search values to filter the lookup results.
     * @param api_version (optional) 
     * @return Success
     */
    getLookup(lookupName: string, searchValues?: string | undefined, api_version?: string | undefined): Observable<LookupItemResultSet>;
    /**
     * Get the case type subscriptions of a user.
     * @param api_version (optional) 
     * @return Success
     */
    getCaseTypeNotificationSubscription(api_version?: string | undefined): Observable<CaseTypeSubscription>;
    /**
     * Create new case type subscription for a user.
     * @param api_version (optional) 
     * @return No Content
     */
    createCaseTypeNotificationSubscription(api_version?: string | undefined): Observable<void>;
    /**
     * Remove a case type subscription for a user.
     * @param api_version (optional) 
     * @return No Content
     */
    deleteCaseTypeNotificationSubscription(api_version?: string | undefined): Observable<void>;
    /**
     * Get the list of the customer's cases.
     * @param filter_CaseTypeTags (optional) The case type tag filter.
     * @param filter_PublicStatuses (optional) The case status filter.
     * @param filter_CaseTypeCodes (optional) The case type code filter.
     * @param filter_CreatedFrom (optional) The CreatedFrom filter.
     * @param filter_CreatedTo (optional) The CreatedTo filter.
     * @param filter_CompletedFrom (optional) The CompletedFrom filter.
     * @param filter_CompletedTo (optional) The CompletedTo filter.
     * @param filter_Checkpoints (optional) The Checkpoints filter.
     * @param filter_Data (optional) Construct filter clauses based on case data.
     * @param filter_Metadata (optional) Construct filter clauses based on case metadata.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param api_version (optional) 
     * @return Success
     */
    getMyCases(filter_CaseTypeTags?: string[] | undefined, filter_PublicStatuses?: CasePublicStatus[] | undefined, filter_CaseTypeCodes?: string[] | undefined, filter_CreatedFrom?: Date | undefined, filter_CreatedTo?: Date | undefined, filter_CompletedFrom?: Date | undefined, filter_CompletedTo?: Date | undefined, filter_Checkpoints?: string[] | undefined, filter_Data?: string[] | undefined, filter_Metadata?: string[] | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, api_version?: string | undefined): Observable<MyCasePartialResultSet>;
    /**
     * Create a new case in draft mode. That means no one will be able to edit it besides the creator of the case.
     * @param api_version (optional) 
     * @param body (optional) The draft.
     * @return Success
     */
    createDraftCase(api_version?: string | undefined, body?: CreateDraftCaseRequest | undefined): Observable<CreateCaseResponse>;
    /**
     * Get case details by Id.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @return Success
     */
    getMyCaseById(caseId: string, api_version?: string | undefined): Observable<CaseDetails>;
    /**
     * Update the case with the business data as defined at the specific case type
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param body (optional) The update request.
     * @return No Content
     */
    updateCase(caseId: string, api_version?: string | undefined, body?: UpdateCaseRequest | undefined): Observable<void>;
    /**
     * Add an attachment to an existing case regardless of its status and mode (draft or not).
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    uploadCaseAttachment(caseId: string, api_version?: string | undefined, contentType?: string | undefined, contentDisposition?: string | undefined, headers?: { [key: string]: string[]; } | undefined, length?: number | undefined, name?: string | undefined, fileName?: string | undefined): Observable<CasesAttachmentLink>;
    /**
     * Download case in a PDF format
     * @param api_version (optional) 
     * @return Success
     */
    downloadMyCasePdf(caseId: string, api_version?: string | undefined): Observable<FileResponse>;
    /**
     * Submit the case by removing the draft mode.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @return No Content
     */
    submitMyCase(caseId: string, api_version?: string | undefined): Observable<void>;
    /**
     * Gets case types.
     * @param filter_CaseTypeTags (optional) The case type tag filter.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param api_version (optional) 
     * @return Success
     */
    getCaseTypes2(filter_CaseTypeTags?: string[] | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, api_version?: string | undefined): Observable<CaseTypePartialResultSet>;
    /**
     * Gets a case type by its code.
     * @param caseTypeCode The case type code.
     * @param api_version (optional) 
     * @return Success
     */
    getCaseType(caseTypeCode: string, api_version?: string | undefined): Observable<CaseTypePartial>;
    /**
     * @param api_version (optional) 
     * @return Success
     */
    getEGovKycIdentityCaseImage(caseId: string, api_version?: string | undefined): Observable<CaseImage>;
}

@Injectable({
    providedIn: 'root'
})
export class CasesApiService implements ICasesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CASES_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Download attachment in a PDF format for back-office users.
     * @param api_version (optional) 
     * @return Success
     */
    downloadAttachment(attachmentId: string, api_version?: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/manage/attachments/{attachmentId}/download?";
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadAttachment(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Create a new case in draft mode.
     * @param api_version (optional) 
     * @param body (optional) The draft.
     * @return Success
     */
    createDraftAdminCase(api_version?: string | undefined, body?: CreateDraftCaseRequest | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/manage/cases?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDraftAdminCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDraftAdminCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateDraftAdminCase(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * Gets the list of all cases using the provided Indice.Types.ListOptions.
     * @param filter_CustomerId (optional) The Id of the customer to filter.
     * @param filter_CustomerName (optional) The name of the customer to filter.
     * @param filter_From (optional) The created date of the case, starting from, to filter.
     * @param filter_To (optional) The create date of the case, ending to, to filter.
     * @param filter_CaseTypeCodes (optional) The list of case type codes to filter.
     * @param filter_CheckpointTypeCodes (optional) The list of checkpoint type codes to filter.
     * @param filter_GroupIds (optional) The list of groupIds to filter.
     * @param filter_Metadata (optional) Construct filter clauses based on the metadata you are adding to the cases in your installation.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param api_version (optional) 
     * @return OK
     */
    getCases(filter_CustomerId?: string | undefined, filter_CustomerName?: string | undefined, filter_From?: Date | undefined, filter_To?: Date | undefined, filter_CaseTypeCodes?: string[] | undefined, filter_CheckpointTypeCodes?: string[] | undefined, filter_GroupIds?: string[] | undefined, filter_Metadata?: string[] | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, api_version?: string | undefined): Observable<CasePartialResultSet> {
        let url_ = this.baseUrl + "/api/manage/cases?";
        if (filter_CustomerId === null)
            throw new Error("The parameter 'filter_CustomerId' cannot be null.");
        else if (filter_CustomerId !== undefined)
            url_ += "Filter.CustomerId=" + encodeURIComponent("" + filter_CustomerId) + "&";
        if (filter_CustomerName === null)
            throw new Error("The parameter 'filter_CustomerName' cannot be null.");
        else if (filter_CustomerName !== undefined)
            url_ += "Filter.CustomerName=" + encodeURIComponent("" + filter_CustomerName) + "&";
        if (filter_From === null)
            throw new Error("The parameter 'filter_From' cannot be null.");
        else if (filter_From !== undefined)
            url_ += "Filter.From=" + encodeURIComponent(filter_From ? "" + filter_From.toISOString() : "") + "&";
        if (filter_To === null)
            throw new Error("The parameter 'filter_To' cannot be null.");
        else if (filter_To !== undefined)
            url_ += "Filter.To=" + encodeURIComponent(filter_To ? "" + filter_To.toISOString() : "") + "&";
        if (filter_CaseTypeCodes === null)
            throw new Error("The parameter 'filter_CaseTypeCodes' cannot be null.");
        else if (filter_CaseTypeCodes !== undefined)
            filter_CaseTypeCodes && filter_CaseTypeCodes.forEach(item => { url_ += "Filter.CaseTypeCodes=" + encodeURIComponent("" + item) + "&"; });
        if (filter_CheckpointTypeCodes === null)
            throw new Error("The parameter 'filter_CheckpointTypeCodes' cannot be null.");
        else if (filter_CheckpointTypeCodes !== undefined)
            filter_CheckpointTypeCodes && filter_CheckpointTypeCodes.forEach(item => { url_ += "Filter.CheckpointTypeCodes=" + encodeURIComponent("" + item) + "&"; });
        if (filter_GroupIds === null)
            throw new Error("The parameter 'filter_GroupIds' cannot be null.");
        else if (filter_GroupIds !== undefined)
            filter_GroupIds && filter_GroupIds.forEach(item => { url_ += "Filter.GroupIds=" + encodeURIComponent("" + item) + "&"; });
        if (filter_Metadata === null)
            throw new Error("The parameter 'filter_Metadata' cannot be null.");
        else if (filter_Metadata !== undefined)
            filter_Metadata && filter_Metadata.forEach(item => { url_ += "Filter.Metadata=" + encodeURIComponent("" + item) + "&"; });
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCases(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCases(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CasePartialResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CasePartialResultSet>;
        }));
    }

    protected processGetCases(response: HttpResponseBase): Observable<CasePartialResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CasePartialResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CasePartialResultSet>(null as any);
    }

    /**
     * Update the case with the business data as defined at the specific case type. This action is allowed only for draft cases.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param body (optional) The update request.
     * @return No Content
     */
    updateAdminCase(caseId: string, api_version?: string | undefined, body?: UpdateCaseRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAdminCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAdminCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAdminCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Gets a case with the specified id.
     * @param caseId The id of the case.
     * @param api_version (optional) 
     * @return OK
     */
    getCaseById(caseId: string, api_version?: string | undefined): Observable<CaseDetails> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseDetails>;
        }));
    }

    protected processGetCaseById(response: HttpResponseBase): Observable<CaseDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseDetails.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseDetails>(null as any);
    }

    /**
     * Deletes a draft case.
     * @param caseId The id of the case.
     * @param api_version (optional) 
     * @return No Content
     */
    deleteDraftCase(caseId: string, api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDraftCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDraftCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDraftCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Download case in a PDF format for backoffice users
     * @param api_version (optional) 
     * @return Success
     */
    downloadCasePdf(caseId: string, api_version?: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}.pdf?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/pdf"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadCasePdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadCasePdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadCasePdf(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Gets the cases actions (Approval, edit, assignments, etc) for a case Id. Actions differ based on user role.
     * @param caseId The id of the case.
     * @param api_version (optional) 
     * @return OK
     */
    getCaseActions(caseId: string, api_version?: string | undefined): Observable<CaseActions> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/actions?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseActions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseActions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseActions>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseActions>;
        }));
    }

    protected processGetCaseActions(response: HttpResponseBase): Observable<CaseActions> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseActions.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseActions>(null as any);
    }

    /**
     * Invoke the approval activity to approve or reject the case.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param body (optional) The approval request.
     * @return No Content
     */
    submitApproval(caseId: string, api_version?: string | undefined, body?: ApprovalRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/approve?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitApproval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitApproval(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitApproval(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Invoke the assign activity to assign the case to the caller user.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @return No Content
     */
    assignCase(caseId: string, api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/assign?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAssignCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get a list of Attachments for a CaseId
     * @param api_version (optional) 
     * @return Success
     */
    getCaseAttachments(caseId: string, api_version?: string | undefined): Observable<CaseAttachmentResultSet> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/attachments?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseAttachments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseAttachments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseAttachmentResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseAttachmentResultSet>;
        }));
    }

    protected processGetCaseAttachments(response: HttpResponseBase): Observable<CaseAttachmentResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseAttachmentResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseAttachmentResultSet>(null as any);
    }

    /**
     * Add an attachment to an existing case regardless of its status and mode (draft or not).
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param file (optional) 
     * @return Success
     */
    uploadAdminCaseAttachment(caseId: string, api_version?: string | undefined, file?: FileParameter | undefined): Observable<CasesAttachmentLink> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/attachments?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadAdminCaseAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadAdminCaseAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CasesAttachmentLink>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CasesAttachmentLink>;
        }));
    }

    protected processUploadAdminCaseAttachment(response: HttpResponseBase): Observable<CasesAttachmentLink> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CasesAttachmentLink.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CasesAttachmentLink>(null as any);
    }

    /**
     * Get an Case Attachment
     * @param api_version (optional) 
     * @return Success
     */
    getCaseAttachment(caseId: string, attachmentId: string, api_version?: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/attachments/{attachmentId}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (attachmentId === undefined || attachmentId === null)
            throw new Error("The parameter 'attachmentId' must be defined.");
        url_ = url_.replace("{attachmentId}", encodeURIComponent("" + attachmentId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetCaseAttachment(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Invoke the edit activity to edit the data of the case.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param body (optional) The case data in json format.
     * @return No Content
     */
    editCase(caseId: string, api_version?: string | undefined, body?: EditCaseRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/edit?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEditCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get the reject reasons for a case.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @return Success
     */
    getCaseRejectReasons(caseId: string, api_version?: string | undefined): Observable<RejectReason[]> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/reject-reasons?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseRejectReasons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseRejectReasons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RejectReason[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RejectReason[]>;
        }));
    }

    protected processGetCaseRejectReasons(response: HttpResponseBase): Observable<RejectReason[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RejectReason.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RejectReason[]>(null as any);
    }

    /**
     * Submit the case by removing the draft mode.
     * @param caseId The Id of the case.
     * @param data (optional) The data of the case.
     * @param api_version (optional) 
     * @return No Content
     */
    submitAdminCase(caseId: string, data?: string | undefined, api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/submit?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (data === null)
            throw new Error("The parameter 'data' cannot be null.");
        else if (data !== undefined)
            url_ += "data=" + encodeURIComponent("" + data) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitAdminCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitAdminCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitAdminCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Gets the timeline entries for a case.
     * @param caseId The id of the case.
     * @param api_version (optional) 
     * @return OK
     */
    getCaseTimeline(caseId: string, api_version?: string | undefined): Observable<TimelineEntry[]> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/timeline?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseTimeline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseTimeline(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimelineEntry[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimelineEntry[]>;
        }));
    }

    protected processGetCaseTimeline(response: HttpResponseBase): Observable<TimelineEntry[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TimelineEntry.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TimelineEntry[]>(null as any);
    }

    /**
     * Invoke the action activity to trigger a business action for the case.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param body (optional) The action request.
     * @return No Content
     */
    triggerAction(caseId: string, api_version?: string | undefined, body?: ActionRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/cases/{caseId}/trigger-action?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTriggerAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTriggerAction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTriggerAction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get case types.
     * @param canCreate (optional) Differentiates between the case types that an admin user can 1) view and 2) select for a case creation
     * @param api_version (optional) 
     * @return Success
     */
    getCaseTypes(canCreate?: boolean | undefined, api_version?: string | undefined): Observable<CaseTypePartialResultSet> {
        let url_ = this.baseUrl + "/api/manage/case-types?";
        if (canCreate === null)
            throw new Error("The parameter 'canCreate' cannot be null.");
        else if (canCreate !== undefined)
            url_ += "canCreate=" + encodeURIComponent("" + canCreate) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseTypePartialResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseTypePartialResultSet>;
        }));
    }

    protected processGetCaseTypes(response: HttpResponseBase): Observable<CaseTypePartialResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseTypePartialResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseTypePartialResultSet>(null as any);
    }

    /**
     * Create new case type.
     * @param api_version (optional) 
     * @param body (optional) 
     * @return No Content
     */
    createCaseType(api_version?: string | undefined, body?: CaseTypeRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/case-types?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCaseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCaseType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateCaseType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get a specific Case Type by Id.
     * @param caseTypeId The case type Id.
     * @param api_version (optional) 
     * @return Success
     */
    getCaseTypeById(caseTypeId: string, api_version?: string | undefined): Observable<CaseTypeDetails> {
        let url_ = this.baseUrl + "/api/manage/case-types/{caseTypeId}?";
        if (caseTypeId === undefined || caseTypeId === null)
            throw new Error("The parameter 'caseTypeId' must be defined.");
        url_ = url_.replace("{caseTypeId}", encodeURIComponent("" + caseTypeId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseTypeDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseTypeDetails>;
        }));
    }

    protected processGetCaseTypeById(response: HttpResponseBase): Observable<CaseTypeDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseTypeDetails.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseTypeDetails>(null as any);
    }

    /**
     * Update a specific Case Type.
     * @param api_version (optional) 
     * @param body (optional) The new case type model.
     * @return Success
     */
    updateCaseType(caseTypeId: string, api_version?: string | undefined, body?: CaseTypeRequest | undefined): Observable<CaseTypeDetails> {
        let url_ = this.baseUrl + "/api/manage/case-types/{caseTypeId}?";
        if (caseTypeId === undefined || caseTypeId === null)
            throw new Error("The parameter 'caseTypeId' must be defined.");
        url_ = url_.replace("{caseTypeId}", encodeURIComponent("" + caseTypeId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCaseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCaseType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseTypeDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseTypeDetails>;
        }));
    }

    protected processUpdateCaseType(response: HttpResponseBase): Observable<CaseTypeDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseTypeDetails.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseTypeDetails>(null as any);
    }

    /**
     * Delete a specific Case Type.
     * @param api_version (optional) 
     * @return No Content
     */
    deleteCaseType(caseTypeId: string, api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/case-types/{caseTypeId}?";
        if (caseTypeId === undefined || caseTypeId === null)
            throw new Error("The parameter 'caseTypeId' must be defined.");
        url_ = url_.replace("{caseTypeId}", encodeURIComponent("" + caseTypeId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCaseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCaseType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCaseType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get Checkpoint types
     * @param api_version (optional) 
     * @return Success
     */
    getDistinctCheckpointNames(api_version?: string | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/manage/checkpoint-types?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDistinctCheckpointNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDistinctCheckpointNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetDistinctCheckpointNames(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(null as any);
    }

    /**
     * Get Filters.
     * @param api_version (optional) 
     * @return Success
     */
    getFilters(api_version?: string | undefined): Observable<Filter[]> {
        let url_ = this.baseUrl + "/api/manage/filters?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFilters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFilters(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Filter[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Filter[]>;
        }));
    }

    protected processGetFilters(response: HttpResponseBase): Observable<Filter[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Filter.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Filter[]>(null as any);
    }

    /**
     * Save a new Filter.
     * @param api_version (optional) 
     * @param body (optional) 
     * @return No Content
     */
    saveFilter(api_version?: string | undefined, body?: SaveFilterRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/filters?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveFilter(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Deletes a Filter.
     * @param filterId The id of the filter.
     * @param api_version (optional) 
     * @return No Content
     */
    deleteFilter(filterId: string, api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/filters/{filterId}?";
        if (filterId === undefined || filterId === null)
            throw new Error("The parameter 'filterId' must be defined.");
        url_ = url_.replace("{filterId}", encodeURIComponent("" + filterId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteFilter(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Fetch customers.
     * @param customerId (optional) The Id of the customer as provided by the consumer/integrator.
     * @param caseTypeCode (optional) The case type code, used for filtering customers based on case type (implementantion on client code)
     * @param api_version (optional) 
     * @return Success
     */
    getCustomers(customerId?: string | undefined, caseTypeCode?: string | undefined, api_version?: string | undefined): Observable<CustomerDetails[]> {
        let url_ = this.baseUrl + "/api/manage/integrations/customers?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (caseTypeCode === null)
            throw new Error("The parameter 'caseTypeCode' cannot be null.");
        else if (caseTypeCode !== undefined)
            url_ += "CaseTypeCode=" + encodeURIComponent("" + caseTypeCode) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDetails[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDetails[]>;
        }));
    }

    protected processGetCustomers(response: HttpResponseBase): Observable<CustomerDetails[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerDetails.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDetails[]>(null as any);
    }

    /**
     * Fetch customer data for a specific case type code.
     * @param customerId The Id of the customer to the integrator's system.
     * @param caseTypeCode The case type code.
     * @param api_version (optional) 
     * @return Success
     */
    getCustomerData(customerId: string, caseTypeCode: string, api_version?: string | undefined): Observable<CustomerData> {
        let url_ = this.baseUrl + "/api/manage/integrations/customers/{customerId}/data/{caseTypeCode}?";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        if (caseTypeCode === undefined || caseTypeCode === null)
            throw new Error("The parameter 'caseTypeCode' must be defined.");
        url_ = url_.replace("{caseTypeCode}", encodeURIComponent("" + caseTypeCode));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerData>;
        }));
    }

    protected processGetCustomerData(response: HttpResponseBase): Observable<CustomerData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerData>(null as any);
    }

    /**
     * Get a lookup by lookupName.
     * @param lookupName The lookup name to retrieve.
     * @param searchValues (optional) Any search values to filter the lookup results.
     * @param api_version (optional) 
     * @return Success
     */
    getLookup(lookupName: string, searchValues?: string | undefined, api_version?: string | undefined): Observable<LookupItemResultSet> {
        let url_ = this.baseUrl + "/api/manage/lookups/{lookupName}?";
        if (lookupName === undefined || lookupName === null)
            throw new Error("The parameter 'lookupName' must be defined.");
        url_ = url_.replace("{lookupName}", encodeURIComponent("" + lookupName));
        if (searchValues === null)
            throw new Error("The parameter 'searchValues' cannot be null.");
        else if (searchValues !== undefined)
            url_ += "searchValues=" + encodeURIComponent("" + searchValues) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LookupItemResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LookupItemResultSet>;
        }));
    }

    protected processGetLookup(response: HttpResponseBase): Observable<LookupItemResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LookupItemResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupItemResultSet>(null as any);
    }

    /**
     * Get the case type subscriptions of a user.
     * @param api_version (optional) 
     * @return Success
     */
    getCaseTypeNotificationSubscription(api_version?: string | undefined): Observable<CaseTypeSubscription> {
        let url_ = this.baseUrl + "/api/manage/users/subscriptions?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseTypeNotificationSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseTypeNotificationSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseTypeSubscription>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseTypeSubscription>;
        }));
    }

    protected processGetCaseTypeNotificationSubscription(response: HttpResponseBase): Observable<CaseTypeSubscription> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseTypeSubscription.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseTypeSubscription>(null as any);
    }

    /**
     * Create new case type subscription for a user.
     * @param api_version (optional) 
     * @return No Content
     */
    createCaseTypeNotificationSubscription(api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/users/subscriptions?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCaseTypeNotificationSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCaseTypeNotificationSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateCaseTypeNotificationSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Remove a case type subscription for a user.
     * @param api_version (optional) 
     * @return No Content
     */
    deleteCaseTypeNotificationSubscription(api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/manage/users/subscriptions?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCaseTypeNotificationSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCaseTypeNotificationSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteCaseTypeNotificationSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get the list of the customer's cases.
     * @param filter_CaseTypeTags (optional) The case type tag filter.
     * @param filter_PublicStatuses (optional) The case status filter.
     * @param filter_CaseTypeCodes (optional) The case type code filter.
     * @param filter_CreatedFrom (optional) The CreatedFrom filter.
     * @param filter_CreatedTo (optional) The CreatedTo filter.
     * @param filter_CompletedFrom (optional) The CompletedFrom filter.
     * @param filter_CompletedTo (optional) The CompletedTo filter.
     * @param filter_Checkpoints (optional) The Checkpoints filter.
     * @param filter_Data (optional) Construct filter clauses based on case data.
     * @param filter_Metadata (optional) Construct filter clauses based on case metadata.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param api_version (optional) 
     * @return Success
     */
    getMyCases(filter_CaseTypeTags?: string[] | undefined, filter_PublicStatuses?: CasePublicStatus[] | undefined, filter_CaseTypeCodes?: string[] | undefined, filter_CreatedFrom?: Date | undefined, filter_CreatedTo?: Date | undefined, filter_CompletedFrom?: Date | undefined, filter_CompletedTo?: Date | undefined, filter_Checkpoints?: string[] | undefined, filter_Data?: string[] | undefined, filter_Metadata?: string[] | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, api_version?: string | undefined): Observable<MyCasePartialResultSet> {
        let url_ = this.baseUrl + "/api/my/cases?";
        if (filter_CaseTypeTags === null)
            throw new Error("The parameter 'filter_CaseTypeTags' cannot be null.");
        else if (filter_CaseTypeTags !== undefined)
            filter_CaseTypeTags && filter_CaseTypeTags.forEach(item => { url_ += "Filter.CaseTypeTags=" + encodeURIComponent("" + item) + "&"; });
        if (filter_PublicStatuses === null)
            throw new Error("The parameter 'filter_PublicStatuses' cannot be null.");
        else if (filter_PublicStatuses !== undefined)
            filter_PublicStatuses && filter_PublicStatuses.forEach(item => { url_ += "Filter.PublicStatuses=" + encodeURIComponent("" + item) + "&"; });
        if (filter_CaseTypeCodes === null)
            throw new Error("The parameter 'filter_CaseTypeCodes' cannot be null.");
        else if (filter_CaseTypeCodes !== undefined)
            filter_CaseTypeCodes && filter_CaseTypeCodes.forEach(item => { url_ += "Filter.CaseTypeCodes=" + encodeURIComponent("" + item) + "&"; });
        if (filter_CreatedFrom === null)
            throw new Error("The parameter 'filter_CreatedFrom' cannot be null.");
        else if (filter_CreatedFrom !== undefined)
            url_ += "Filter.CreatedFrom=" + encodeURIComponent(filter_CreatedFrom ? "" + filter_CreatedFrom.toISOString() : "") + "&";
        if (filter_CreatedTo === null)
            throw new Error("The parameter 'filter_CreatedTo' cannot be null.");
        else if (filter_CreatedTo !== undefined)
            url_ += "Filter.CreatedTo=" + encodeURIComponent(filter_CreatedTo ? "" + filter_CreatedTo.toISOString() : "") + "&";
        if (filter_CompletedFrom === null)
            throw new Error("The parameter 'filter_CompletedFrom' cannot be null.");
        else if (filter_CompletedFrom !== undefined)
            url_ += "Filter.CompletedFrom=" + encodeURIComponent(filter_CompletedFrom ? "" + filter_CompletedFrom.toISOString() : "") + "&";
        if (filter_CompletedTo === null)
            throw new Error("The parameter 'filter_CompletedTo' cannot be null.");
        else if (filter_CompletedTo !== undefined)
            url_ += "Filter.CompletedTo=" + encodeURIComponent(filter_CompletedTo ? "" + filter_CompletedTo.toISOString() : "") + "&";
        if (filter_Checkpoints === null)
            throw new Error("The parameter 'filter_Checkpoints' cannot be null.");
        else if (filter_Checkpoints !== undefined)
            filter_Checkpoints && filter_Checkpoints.forEach(item => { url_ += "Filter.Checkpoints=" + encodeURIComponent("" + item) + "&"; });
        if (filter_Data === null)
            throw new Error("The parameter 'filter_Data' cannot be null.");
        else if (filter_Data !== undefined)
            filter_Data && filter_Data.forEach(item => { url_ += "Filter.Data=" + encodeURIComponent("" + item) + "&"; });
        if (filter_Metadata === null)
            throw new Error("The parameter 'filter_Metadata' cannot be null.");
        else if (filter_Metadata !== undefined)
            filter_Metadata && filter_Metadata.forEach(item => { url_ += "Filter.Metadata=" + encodeURIComponent("" + item) + "&"; });
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyCases(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyCases(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MyCasePartialResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MyCasePartialResultSet>;
        }));
    }

    protected processGetMyCases(response: HttpResponseBase): Observable<MyCasePartialResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MyCasePartialResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MyCasePartialResultSet>(null as any);
    }

    /**
     * Create a new case in draft mode. That means no one will be able to edit it besides the creator of the case.
     * @param api_version (optional) 
     * @param body (optional) The draft.
     * @return Success
     */
    createDraftCase(api_version?: string | undefined, body?: CreateDraftCaseRequest | undefined): Observable<CreateCaseResponse> {
        let url_ = this.baseUrl + "/api/my/cases?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDraftCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDraftCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateCaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateCaseResponse>;
        }));
    }

    protected processCreateDraftCase(response: HttpResponseBase): Observable<CreateCaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateCaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateCaseResponse>(null as any);
    }

    /**
     * Get case details by Id.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @return Success
     */
    getMyCaseById(caseId: string, api_version?: string | undefined): Observable<CaseDetails> {
        let url_ = this.baseUrl + "/api/my/cases/{caseId}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyCaseById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyCaseById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseDetails>;
        }));
    }

    protected processGetMyCaseById(response: HttpResponseBase): Observable<CaseDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseDetails.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseDetails>(null as any);
    }

    /**
     * Update the case with the business data as defined at the specific case type
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param body (optional) The update request.
     * @return No Content
     */
    updateCase(caseId: string, api_version?: string | undefined, body?: UpdateCaseRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/my/cases/{caseId}?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Add an attachment to an existing case regardless of its status and mode (draft or not).
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @param contentType (optional) 
     * @param contentDisposition (optional) 
     * @param headers (optional) 
     * @param length (optional) 
     * @param name (optional) 
     * @param fileName (optional) 
     * @return Success
     */
    uploadCaseAttachment(caseId: string, api_version?: string | undefined, contentType?: string | undefined, contentDisposition?: string | undefined, headers?: { [key: string]: string[]; } | undefined, length?: number | undefined, name?: string | undefined, fileName?: string | undefined): Observable<CasesAttachmentLink> {
        let url_ = this.baseUrl + "/api/my/cases/{caseId}/attachments?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("ContentType", contentType.toString());
        if (contentDisposition === null || contentDisposition === undefined)
            throw new Error("The parameter 'contentDisposition' cannot be null.");
        else
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers === null || headers === undefined)
            throw new Error("The parameter 'headers' cannot be null.");
        else
            content_.append("Headers", JSON.stringify(headers));
        if (length === null || length === undefined)
            throw new Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (fileName === null || fileName === undefined)
            throw new Error("The parameter 'fileName' cannot be null.");
        else
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadCaseAttachment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadCaseAttachment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CasesAttachmentLink>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CasesAttachmentLink>;
        }));
    }

    protected processUploadCaseAttachment(response: HttpResponseBase): Observable<CasesAttachmentLink> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CasesAttachmentLink.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CasesAttachmentLink>(null as any);
    }

    /**
     * Download case in a PDF format
     * @param api_version (optional) 
     * @return Success
     */
    downloadMyCasePdf(caseId: string, api_version?: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/my/cases/{caseId}/download?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/pdf"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadMyCasePdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadMyCasePdf(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadMyCasePdf(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Submit the case by removing the draft mode.
     * @param caseId The Id of the case.
     * @param api_version (optional) 
     * @return No Content
     */
    submitMyCase(caseId: string, api_version?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/my/cases/{caseId}/submit?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitMyCase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitMyCase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSubmitMyCase(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Gets case types.
     * @param filter_CaseTypeTags (optional) The case type tag filter.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param api_version (optional) 
     * @return Success
     */
    getCaseTypes2(filter_CaseTypeTags?: string[] | undefined, page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, api_version?: string | undefined): Observable<CaseTypePartialResultSet> {
        let url_ = this.baseUrl + "/api/my/case-types?";
        if (filter_CaseTypeTags === null)
            throw new Error("The parameter 'filter_CaseTypeTags' cannot be null.");
        else if (filter_CaseTypeTags !== undefined)
            filter_CaseTypeTags && filter_CaseTypeTags.forEach(item => { url_ += "Filter.CaseTypeTags=" + encodeURIComponent("" + item) + "&"; });
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseTypes2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseTypes2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseTypePartialResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseTypePartialResultSet>;
        }));
    }

    protected processGetCaseTypes2(response: HttpResponseBase): Observable<CaseTypePartialResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseTypePartialResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseTypePartialResultSet>(null as any);
    }

    /**
     * Gets a case type by its code.
     * @param caseTypeCode The case type code.
     * @param api_version (optional) 
     * @return Success
     */
    getCaseType(caseTypeCode: string, api_version?: string | undefined): Observable<CaseTypePartial> {
        let url_ = this.baseUrl + "/api/my/case-types/{caseTypeCode}?";
        if (caseTypeCode === undefined || caseTypeCode === null)
            throw new Error("The parameter 'caseTypeCode' must be defined.");
        url_ = url_.replace("{caseTypeCode}", encodeURIComponent("" + caseTypeCode));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCaseType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCaseType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseTypePartial>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseTypePartial>;
        }));
    }

    protected processGetCaseType(response: HttpResponseBase): Observable<CaseTypePartial> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseTypePartial.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseTypePartial>(null as any);
    }

    /**
     * @param api_version (optional) 
     * @return Success
     */
    getEGovKycIdentityCaseImage(caseId: string, api_version?: string | undefined): Observable<CaseImage> {
        let url_ = this.baseUrl + "/case-details/{caseId}/e-gov-kyc-identity-image?";
        if (caseId === undefined || caseId === null)
            throw new Error("The parameter 'caseId' must be defined.");
        url_ = url_.replace("{caseId}", encodeURIComponent("" + caseId));
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEGovKycIdentityCaseImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEGovKycIdentityCaseImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CaseImage>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CaseImage>;
        }));
    }

    protected processGetEGovKycIdentityCaseImage(response: HttpResponseBase): Observable<CaseImage> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CaseImage.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CaseImage>(null as any);
    }
}

/** The request that triggers an action. */
export class ActionRequest implements IActionRequest {
    /** The Id of the action. */
    id?: string;
    /** The value of the action (non-required). */
    value?: string | undefined;

    constructor(data?: IActionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ActionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ActionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data;
    }
}

/** The request that triggers an action. */
export interface IActionRequest {
    /** The Id of the action. */
    id?: string;
    /** The value of the action (non-required). */
    value?: string | undefined;
}

/** The Approval action for a Case. */
export enum Approval {
    Approve = "Approve",
    Reject = "Reject",
}

/** The approval request to trigger the Indice.Features.Cases.Workflows.Activities.AwaitApprovalActivity */
export class ApprovalRequest implements IApprovalRequest {
    action?: Approval;
    /** User comment related to the action. */
    comment?: string | undefined;

    constructor(data?: IApprovalRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): ApprovalRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["comment"] = this.comment;
        return data;
    }
}

/** The approval request to trigger the Indice.Features.Cases.Workflows.Activities.AwaitApprovalActivity */
export interface IApprovalRequest {
    action?: Approval;
    /** User comment related to the action. */
    comment?: string | undefined;
}

/** Audit metadata related with the user principal that "did" the action. */
export class AuditMeta implements IAuditMeta {
    /** The Id of the user. */
    id?: string | undefined;
    /** The name of the user. */
    name?: string | undefined;
    /** The email of the user. */
    email?: string | undefined;
    /** The timestamp the audit happened. */
    when?: Date | undefined;

    constructor(data?: IAuditMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.when = _data["when"] ? new Date(_data["when"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditMeta {
        data = typeof data === 'object' ? data : {};
        let result = new AuditMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["when"] = this.when ? this.when.toISOString() : <any>undefined;
        return data;
    }
}

/** Audit metadata related with the user principal that "did" the action. */
export interface IAuditMeta {
    /** The Id of the user. */
    id?: string | undefined;
    /** The name of the user. */
    name?: string | undefined;
    /** The email of the user. */
    email?: string | undefined;
    /** The timestamp the audit happened. */
    when?: Date | undefined;
}

/** The available actions for a user, depending on his role and checkpoint of the case. */
export class CaseActions implements ICaseActions {
    /** User can assign the case to himself. */
    hasAssignment?: boolean;
    /** User can remove the assignment of the case. */
    hasUnassignment?: boolean;
    /** User can edit the case data. */
    hasEdit?: boolean;
    /** User can approve/reject the case. */
    hasApproval?: boolean;
    /** The list of custom action blocking activities that will generate the corresponding components. */
    customActions?: CustomCaseAction[] | undefined;

    constructor(data?: ICaseActions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hasAssignment = _data["hasAssignment"];
            this.hasUnassignment = _data["hasUnassignment"];
            this.hasEdit = _data["hasEdit"];
            this.hasApproval = _data["hasApproval"];
            if (Array.isArray(_data["customActions"])) {
                this.customActions = [] as any;
                for (let item of _data["customActions"])
                    this.customActions!.push(CustomCaseAction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CaseActions {
        data = typeof data === 'object' ? data : {};
        let result = new CaseActions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasAssignment"] = this.hasAssignment;
        data["hasUnassignment"] = this.hasUnassignment;
        data["hasEdit"] = this.hasEdit;
        data["hasApproval"] = this.hasApproval;
        if (Array.isArray(this.customActions)) {
            data["customActions"] = [];
            for (let item of this.customActions)
                data["customActions"].push(item.toJSON());
        }
        return data;
    }
}

/** The available actions for a user, depending on his role and checkpoint of the case. */
export interface ICaseActions {
    /** User can assign the case to himself. */
    hasAssignment?: boolean;
    /** User can remove the assignment of the case. */
    hasUnassignment?: boolean;
    /** User can edit the case data. */
    hasEdit?: boolean;
    /** User can approve/reject the case. */
    hasApproval?: boolean;
    /** The list of custom action blocking activities that will generate the corresponding components. */
    customActions?: CustomCaseAction[] | undefined;
}

/** Minimal Case Attachment response model. */
export class CaseAttachment implements ICaseAttachment {
    /** The Id of the attachment. */
    id?: string;
    /** The name of the attachment. */
    name?: string | undefined;
    /** The content type of the attachment. */
    contentType?: string | undefined;
    /** The extension of the attachment. */
    extension?: string | undefined;
    /** The binary data of the attachment. */
    data?: string | undefined;

    constructor(data?: ICaseAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.contentType = _data["contentType"];
            this.extension = _data["extension"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): CaseAttachment {
        data = typeof data === 'object' ? data : {};
        let result = new CaseAttachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["contentType"] = this.contentType;
        data["extension"] = this.extension;
        data["data"] = this.data;
        return data;
    }
}

/** Minimal Case Attachment response model. */
export interface ICaseAttachment {
    /** The Id of the attachment. */
    id?: string;
    /** The name of the attachment. */
    name?: string | undefined;
    /** The content type of the attachment. */
    contentType?: string | undefined;
    /** The extension of the attachment. */
    extension?: string | undefined;
    /** The binary data of the attachment. */
    data?: string | undefined;
}

export class CaseAttachmentResultSet implements ICaseAttachmentResultSet {
    count?: number;
    items?: CaseAttachment[] | undefined;

    constructor(data?: ICaseAttachmentResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CaseAttachment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CaseAttachmentResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new CaseAttachmentResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICaseAttachmentResultSet {
    count?: number;
    items?: CaseAttachment[] | undefined;
}

/** Models case details. */
export class CaseDetails implements ICaseDetails {
    /** The Id of the case. */
    id?: string;
    /** The current checkpoint of the case. */
    checkpointTypeId?: string;
    publicStatus?: CasePublicStatus;
    /** The Id of the customer as provided from integration services (core or 3rd party). */
    customerId?: string | undefined;
    /** The Id of the user as provided from our Identity server. */
    userId?: string | undefined;
    /** The full name of the customer. */
    customerName?: string | undefined;
    /** The created date of the case. */
    createdByWhen?: Date | undefined;
    /** The Id of the user that created the case. */
    createdById?: string | undefined;
    caseType?: CaseTypePartial;
    /** The case metadata as provided from the client or integrator. */
    metadata?: { [key: string]: string; } | undefined;
    /** The Id of the group the case belongs. */
    groupId?: string | undefined;
    /** The current checkpoint type code for the case. */
    checkpointTypeCode?: string | undefined;
    /** The json data of the case. */
    data?: string | undefined;
    /** The name of the user that has the case assigned. */
    assignedToName?: string | undefined;
    /** The channel of th case. */
    channel?: string | undefined;
    /** Indicate if the case is in draft mode. */
    draft?: boolean;
    /** The attachments of the case. */
    attachments?: CaseAttachment[] | undefined;
    /** The back-office users that approved the case. */
    approvers?: AuditMeta[] | undefined;

    constructor(data?: ICaseDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.checkpointTypeId = _data["checkpointTypeId"];
            this.publicStatus = _data["publicStatus"];
            this.customerId = _data["customerId"];
            this.userId = _data["userId"];
            this.customerName = _data["customerName"];
            this.createdByWhen = _data["createdByWhen"] ? new Date(_data["createdByWhen"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.caseType = _data["caseType"] ? CaseTypePartial.fromJS(_data["caseType"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.groupId = _data["groupId"];
            this.checkpointTypeCode = _data["checkpointTypeCode"];
            this.data = _data["data"];
            this.assignedToName = _data["assignedToName"];
            this.channel = _data["channel"];
            this.draft = _data["draft"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(CaseAttachment.fromJS(item));
            }
            if (Array.isArray(_data["approvers"])) {
                this.approvers = [] as any;
                for (let item of _data["approvers"])
                    this.approvers!.push(AuditMeta.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CaseDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CaseDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checkpointTypeId"] = this.checkpointTypeId;
        data["publicStatus"] = this.publicStatus;
        data["customerId"] = this.customerId;
        data["userId"] = this.userId;
        data["customerName"] = this.customerName;
        data["createdByWhen"] = this.createdByWhen ? this.createdByWhen.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["caseType"] = this.caseType ? this.caseType.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["groupId"] = this.groupId;
        data["checkpointTypeCode"] = this.checkpointTypeCode;
        data["data"] = this.data;
        data["assignedToName"] = this.assignedToName;
        data["channel"] = this.channel;
        data["draft"] = this.draft;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        if (Array.isArray(this.approvers)) {
            data["approvers"] = [];
            for (let item of this.approvers)
                data["approvers"].push(item.toJSON());
        }
        return data;
    }
}

/** Models case details. */
export interface ICaseDetails {
    /** The Id of the case. */
    id?: string;
    /** The current checkpoint of the case. */
    checkpointTypeId?: string;
    publicStatus?: CasePublicStatus;
    /** The Id of the customer as provided from integration services (core or 3rd party). */
    customerId?: string | undefined;
    /** The Id of the user as provided from our Identity server. */
    userId?: string | undefined;
    /** The full name of the customer. */
    customerName?: string | undefined;
    /** The created date of the case. */
    createdByWhen?: Date | undefined;
    /** The Id of the user that created the case. */
    createdById?: string | undefined;
    caseType?: CaseTypePartial;
    /** The case metadata as provided from the client or integrator. */
    metadata?: { [key: string]: string; } | undefined;
    /** The Id of the group the case belongs. */
    groupId?: string | undefined;
    /** The current checkpoint type code for the case. */
    checkpointTypeCode?: string | undefined;
    /** The json data of the case. */
    data?: string | undefined;
    /** The name of the user that has the case assigned. */
    assignedToName?: string | undefined;
    /** The channel of th case. */
    channel?: string | undefined;
    /** Indicate if the case is in draft mode. */
    draft?: boolean;
    /** The attachments of the case. */
    attachments?: CaseAttachment[] | undefined;
    /** The back-office users that approved the case. */
    approvers?: AuditMeta[] | undefined;
}

export class CaseImage implements ICaseImage {
    data?: string | undefined;
    mimeType?: string | undefined;

    constructor(data?: ICaseImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            this.mimeType = _data["mimeType"];
        }
    }

    static fromJS(data: any): CaseImage {
        data = typeof data === 'object' ? data : {};
        let result = new CaseImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["mimeType"] = this.mimeType;
        return data;
    }
}

export interface ICaseImage {
    data?: string | undefined;
    mimeType?: string | undefined;
}

/** The partial model of a case. */
export class CasePartial implements ICasePartial {
    /** The Id of the case. */
    id?: string;
    /** The current checkpoint of the case. */
    checkpointTypeId?: string;
    publicStatus?: CasePublicStatus;
    /** The Id of the customer as provided from integration services (core or 3rd party). */
    customerId?: string | undefined;
    /** The Id of the user as provided from our Identity server. */
    userId?: string | undefined;
    /** The full name of the customer. */
    customerName?: string | undefined;
    /** The created date of the case. */
    createdByWhen?: Date | undefined;
    /** The Id of the user that created the case. */
    createdById?: string | undefined;
    caseType?: CaseTypePartial;
    /** The case metadata as provided from the client or integrator. */
    metadata?: { [key: string]: string; } | undefined;
    /** The Id of the group the case belongs. */
    groupId?: string | undefined;
    /** The current checkpoint type code for the case. */
    checkpointTypeCode?: string | undefined;
    /** The json data of the case. */
    data?: string | undefined;
    /** The name of the user that has the case assigned. */
    assignedToName?: string | undefined;
    /** The channel of th case. */
    channel?: string | undefined;
    /** Indicate if the case is in draft mode. */
    draft?: boolean;

    constructor(data?: ICasePartial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.checkpointTypeId = _data["checkpointTypeId"];
            this.publicStatus = _data["publicStatus"];
            this.customerId = _data["customerId"];
            this.userId = _data["userId"];
            this.customerName = _data["customerName"];
            this.createdByWhen = _data["createdByWhen"] ? new Date(_data["createdByWhen"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.caseType = _data["caseType"] ? CaseTypePartial.fromJS(_data["caseType"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.groupId = _data["groupId"];
            this.checkpointTypeCode = _data["checkpointTypeCode"];
            this.data = _data["data"];
            this.assignedToName = _data["assignedToName"];
            this.channel = _data["channel"];
            this.draft = _data["draft"];
        }
    }

    static fromJS(data: any): CasePartial {
        data = typeof data === 'object' ? data : {};
        let result = new CasePartial();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checkpointTypeId"] = this.checkpointTypeId;
        data["publicStatus"] = this.publicStatus;
        data["customerId"] = this.customerId;
        data["userId"] = this.userId;
        data["customerName"] = this.customerName;
        data["createdByWhen"] = this.createdByWhen ? this.createdByWhen.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["caseType"] = this.caseType ? this.caseType.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["groupId"] = this.groupId;
        data["checkpointTypeCode"] = this.checkpointTypeCode;
        data["data"] = this.data;
        data["assignedToName"] = this.assignedToName;
        data["channel"] = this.channel;
        data["draft"] = this.draft;
        return data;
    }
}

/** The partial model of a case. */
export interface ICasePartial {
    /** The Id of the case. */
    id?: string;
    /** The current checkpoint of the case. */
    checkpointTypeId?: string;
    publicStatus?: CasePublicStatus;
    /** The Id of the customer as provided from integration services (core or 3rd party). */
    customerId?: string | undefined;
    /** The Id of the user as provided from our Identity server. */
    userId?: string | undefined;
    /** The full name of the customer. */
    customerName?: string | undefined;
    /** The created date of the case. */
    createdByWhen?: Date | undefined;
    /** The Id of the user that created the case. */
    createdById?: string | undefined;
    caseType?: CaseTypePartial;
    /** The case metadata as provided from the client or integrator. */
    metadata?: { [key: string]: string; } | undefined;
    /** The Id of the group the case belongs. */
    groupId?: string | undefined;
    /** The current checkpoint type code for the case. */
    checkpointTypeCode?: string | undefined;
    /** The json data of the case. */
    data?: string | undefined;
    /** The name of the user that has the case assigned. */
    assignedToName?: string | undefined;
    /** The channel of th case. */
    channel?: string | undefined;
    /** Indicate if the case is in draft mode. */
    draft?: boolean;
}

export class CasePartialResultSet implements ICasePartialResultSet {
    count?: number;
    items?: CasePartial[] | undefined;

    constructor(data?: ICasePartialResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CasePartial.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CasePartialResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new CasePartialResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICasePartialResultSet {
    count?: number;
    items?: CasePartial[] | undefined;
}

/** Define the status for the customer. It is defined at the Indice.Features.Cases.Data.Models.DbCheckpointType.PublicStatus. */
export enum CasePublicStatus {
    Submitted = "Submitted",
    InProgress = "InProgress",
    Completed = "Completed",
    Deleted = "Deleted",
    Rejected = "Rejected",
}

/** The case type details model. */
export class CaseTypeDetails implements ICaseTypeDetails {
    /** The Id of the case type. */
    id?: string;
    /** The case type code. */
    code?: string | undefined;
    /** The case type title. */
    title?: string | undefined;
    /** The case type description. */
    description?: string | undefined;
    /** The case type category. */
    category?: string | undefined;
    /** The case type json schema. */
    dataSchema?: string | undefined;
    /** The layout for the data schema. */
    layout?: string | undefined;
    /** The case type translations. */
    translations?: string | undefined;
    /** The layout translations. */
    layoutTranslations?: string | undefined;
    /** The case type tags. */
    tags?: string | undefined;
    /** The case type configuration. */
    config?: string | undefined;
    /** The allowed Roles that can create a new Case. */
    canCreateRoles?: string | undefined;
    /** The checkpoints for this case type. */
    checkpointTypes?: CheckpointTypeDetails[] | undefined;

    constructor(data?: ICaseTypeDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.dataSchema = _data["dataSchema"];
            this.layout = _data["layout"];
            this.translations = _data["translations"];
            this.layoutTranslations = _data["layoutTranslations"];
            this.tags = _data["tags"];
            this.config = _data["config"];
            this.canCreateRoles = _data["canCreateRoles"];
            if (Array.isArray(_data["checkpointTypes"])) {
                this.checkpointTypes = [] as any;
                for (let item of _data["checkpointTypes"])
                    this.checkpointTypes!.push(CheckpointTypeDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CaseTypeDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypeDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["title"] = this.title;
        data["description"] = this.description;
        data["category"] = this.category;
        data["dataSchema"] = this.dataSchema;
        data["layout"] = this.layout;
        data["translations"] = this.translations;
        data["layoutTranslations"] = this.layoutTranslations;
        data["tags"] = this.tags;
        data["config"] = this.config;
        data["canCreateRoles"] = this.canCreateRoles;
        if (Array.isArray(this.checkpointTypes)) {
            data["checkpointTypes"] = [];
            for (let item of this.checkpointTypes)
                data["checkpointTypes"].push(item.toJSON());
        }
        return data;
    }
}

/** The case type details model. */
export interface ICaseTypeDetails {
    /** The Id of the case type. */
    id?: string;
    /** The case type code. */
    code?: string | undefined;
    /** The case type title. */
    title?: string | undefined;
    /** The case type description. */
    description?: string | undefined;
    /** The case type category. */
    category?: string | undefined;
    /** The case type json schema. */
    dataSchema?: string | undefined;
    /** The layout for the data schema. */
    layout?: string | undefined;
    /** The case type translations. */
    translations?: string | undefined;
    /** The layout translations. */
    layoutTranslations?: string | undefined;
    /** The case type tags. */
    tags?: string | undefined;
    /** The case type configuration. */
    config?: string | undefined;
    /** The allowed Roles that can create a new Case. */
    canCreateRoles?: string | undefined;
    /** The checkpoints for this case type. */
    checkpointTypes?: CheckpointTypeDetails[] | undefined;
}

/** The case type partial model. */
export class CaseTypePartial implements ICaseTypePartial {
    /** The Id of the case type. */
    id?: string;
    /** The case type code. */
    code?: string | undefined;
    /** The case type title. */
    title?: string | undefined;
    /** The case type description. */
    description?: string | undefined;
    /** The case type category. */
    category?: string | undefined;
    /** The case type json schema. */
    dataSchema?: string | undefined;
    /** The layout for the data schema. */
    layout?: string | undefined;
    /** The layout translations for the data schema. */
    layoutTranslations?: string | undefined;
    /** The case type tags. */
    tags?: string | undefined;
    /** The case type configuration. */
    config?: string | undefined;
    /** The allowed Roles For case Creation. */
    canCreateRoles?: string[] | undefined;
    /** The translations for the case type metadata (eg title). */
    translations?: { [key: string]: CaseTypeTranslation; } | undefined;

    constructor(data?: ICaseTypePartial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.dataSchema = _data["dataSchema"];
            this.layout = _data["layout"];
            this.layoutTranslations = _data["layoutTranslations"];
            this.tags = _data["tags"];
            this.config = _data["config"];
            if (Array.isArray(_data["canCreateRoles"])) {
                this.canCreateRoles = [] as any;
                for (let item of _data["canCreateRoles"])
                    this.canCreateRoles!.push(item);
            }
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? CaseTypeTranslation.fromJS(_data["translations"][key]) : new CaseTypeTranslation();
                }
            }
        }
    }

    static fromJS(data: any): CaseTypePartial {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypePartial();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["title"] = this.title;
        data["description"] = this.description;
        data["category"] = this.category;
        data["dataSchema"] = this.dataSchema;
        data["layout"] = this.layout;
        data["layoutTranslations"] = this.layoutTranslations;
        data["tags"] = this.tags;
        data["config"] = this.config;
        if (Array.isArray(this.canCreateRoles)) {
            data["canCreateRoles"] = [];
            for (let item of this.canCreateRoles)
                data["canCreateRoles"].push(item);
        }
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** The case type partial model. */
export interface ICaseTypePartial {
    /** The Id of the case type. */
    id?: string;
    /** The case type code. */
    code?: string | undefined;
    /** The case type title. */
    title?: string | undefined;
    /** The case type description. */
    description?: string | undefined;
    /** The case type category. */
    category?: string | undefined;
    /** The case type json schema. */
    dataSchema?: string | undefined;
    /** The layout for the data schema. */
    layout?: string | undefined;
    /** The layout translations for the data schema. */
    layoutTranslations?: string | undefined;
    /** The case type tags. */
    tags?: string | undefined;
    /** The case type configuration. */
    config?: string | undefined;
    /** The allowed Roles For case Creation. */
    canCreateRoles?: string[] | undefined;
    /** The translations for the case type metadata (eg title). */
    translations?: { [key: string]: CaseTypeTranslation; } | undefined;
}

export class CaseTypePartialResultSet implements ICaseTypePartialResultSet {
    count?: number;
    items?: CaseTypePartial[] | undefined;

    constructor(data?: ICaseTypePartialResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CaseTypePartial.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CaseTypePartialResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypePartialResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICaseTypePartialResultSet {
    count?: number;
    items?: CaseTypePartial[] | undefined;
}

/** The case type request model. */
export class CaseTypeRequest implements ICaseTypeRequest {
    /** The Id of the case type. */
    id?: string | undefined;
    /** The Code of the case type. */
    code?: string | undefined;
    /** The Title of the case type. */
    title?: string | undefined;
    /** The case type description. */
    description?: string | undefined;
    /** The case type category. */
    category?: string | undefined;
    /** The Data Schema of the case type */
    dataSchema?: string | undefined;
    /** the Layout of the case type */
    layout?: string | undefined;
    /** The Translation for the case type */
    translations?: string | undefined;
    /** The Translation for the layout */
    layoutTranslations?: string | undefined;
    /** The list of checkpoints for the case type */
    checkpointTypes?: CheckpointTypeDetails[] | undefined;
    /** The case type tags. */
    tags?: string | undefined;
    /** The case type configuration. */
    config?: string | undefined;
    /** The allowed Roles that can create a new Case */
    canCreateRoles?: string | undefined;

    constructor(data?: ICaseTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.dataSchema = _data["dataSchema"];
            this.layout = _data["layout"];
            this.translations = _data["translations"];
            this.layoutTranslations = _data["layoutTranslations"];
            if (Array.isArray(_data["checkpointTypes"])) {
                this.checkpointTypes = [] as any;
                for (let item of _data["checkpointTypes"])
                    this.checkpointTypes!.push(CheckpointTypeDetails.fromJS(item));
            }
            this.tags = _data["tags"];
            this.config = _data["config"];
            this.canCreateRoles = _data["canCreateRoles"];
        }
    }

    static fromJS(data: any): CaseTypeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["title"] = this.title;
        data["description"] = this.description;
        data["category"] = this.category;
        data["dataSchema"] = this.dataSchema;
        data["layout"] = this.layout;
        data["translations"] = this.translations;
        data["layoutTranslations"] = this.layoutTranslations;
        if (Array.isArray(this.checkpointTypes)) {
            data["checkpointTypes"] = [];
            for (let item of this.checkpointTypes)
                data["checkpointTypes"].push(item.toJSON());
        }
        data["tags"] = this.tags;
        data["config"] = this.config;
        data["canCreateRoles"] = this.canCreateRoles;
        return data;
    }
}

/** The case type request model. */
export interface ICaseTypeRequest {
    /** The Id of the case type. */
    id?: string | undefined;
    /** The Code of the case type. */
    code?: string | undefined;
    /** The Title of the case type. */
    title?: string | undefined;
    /** The case type description. */
    description?: string | undefined;
    /** The case type category. */
    category?: string | undefined;
    /** The Data Schema of the case type */
    dataSchema?: string | undefined;
    /** the Layout of the case type */
    layout?: string | undefined;
    /** The Translation for the case type */
    translations?: string | undefined;
    /** The Translation for the layout */
    layoutTranslations?: string | undefined;
    /** The list of checkpoints for the case type */
    checkpointTypes?: CheckpointTypeDetails[] | undefined;
    /** The case type tags. */
    tags?: string | undefined;
    /** The case type configuration. */
    config?: string | undefined;
    /** The allowed Roles that can create a new Case */
    canCreateRoles?: string | undefined;
}

/** The DTO for the CaseTypeSubscriptions for a user. */
export class CaseTypeSubscription implements ICaseTypeSubscription {
    /** Indicates if the user is subscribed to the current group. */
    subscribed?: boolean;

    constructor(data?: ICaseTypeSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscribed = _data["subscribed"];
        }
    }

    static fromJS(data: any): CaseTypeSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypeSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscribed"] = this.subscribed;
        return data;
    }
}

/** The DTO for the CaseTypeSubscriptions for a user. */
export interface ICaseTypeSubscription {
    /** Indicates if the user is subscribed to the current group. */
    subscribed?: boolean;
}

/** The Translation of the case type. */
export class CaseTypeTranslation implements ICaseTypeTranslation {
    /** The title of the case type. */
    title?: string | undefined;
    /** The case type description. */
    description?: string | undefined;
    /** The case type category. */
    category?: string | undefined;

    constructor(data?: ICaseTypeTranslation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): CaseTypeTranslation {
        data = typeof data === 'object' ? data : {};
        let result = new CaseTypeTranslation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        data["category"] = this.category;
        return data;
    }
}

/** The Translation of the case type. */
export interface ICaseTypeTranslation {
    /** The title of the case type. */
    title?: string | undefined;
    /** The case type description. */
    description?: string | undefined;
    /** The case type category. */
    category?: string | undefined;
}

/** Models an attachment that is associated with a case. */
export class CasesAttachmentLink implements ICasesAttachmentLink {
    /** The id of the attachment. */
    id?: string;
    /** The unique file identifier. */
    fileGuid?: string;
    /** The URL to the file. */
    permaLink?: string | undefined;
    /** The label of the file. */
    label?: string | undefined;
    /** The file size in bytes. */
    size?: number;
    /** The file size in readable format. */
    readonly sizeText?: string | undefined;
    /** The content type of the file. */
    contentType?: string | undefined;

    constructor(data?: ICasesAttachmentLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileGuid = _data["fileGuid"];
            this.permaLink = _data["permaLink"];
            this.label = _data["label"];
            this.size = _data["size"];
            (<any>this).sizeText = _data["sizeText"];
            this.contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): CasesAttachmentLink {
        data = typeof data === 'object' ? data : {};
        let result = new CasesAttachmentLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileGuid"] = this.fileGuid;
        data["permaLink"] = this.permaLink;
        data["label"] = this.label;
        data["size"] = this.size;
        data["sizeText"] = this.sizeText;
        data["contentType"] = this.contentType;
        return data;
    }
}

/** Models an attachment that is associated with a case. */
export interface ICasesAttachmentLink {
    /** The id of the attachment. */
    id?: string;
    /** The unique file identifier. */
    fileGuid?: string;
    /** The URL to the file. */
    permaLink?: string | undefined;
    /** The label of the file. */
    label?: string | undefined;
    /** The file size in bytes. */
    size?: number;
    /** The file size in readable format. */
    sizeText?: string | undefined;
    /** The content type of the file. */
    contentType?: string | undefined;
}

/** The checkpoint entry for a case. */
export class Checkpoint implements ICheckpoint {
    /** The Id of the checkpoint. */
    id?: string;
    /** The checkpoint type code. This is the inner status the back-officer can see. */
    checkpointTypeCode?: string | undefined;
    publicStatus?: CasePublicStatus;
    /** The completed date of the checkpoint. */
    completedDate?: Date | undefined;
    /** Indicates if the checkpoint is private, which means not visible to the customer. */
    private?: boolean | undefined;
    /** The due date of the checkpoint. */
    dueDate?: Date | undefined;

    constructor(data?: ICheckpoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.checkpointTypeCode = _data["checkpointTypeCode"];
            this.publicStatus = _data["publicStatus"];
            this.completedDate = _data["completedDate"] ? new Date(_data["completedDate"].toString()) : <any>undefined;
            this.private = _data["private"];
            this.dueDate = _data["dueDate"] ? new Date(_data["dueDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Checkpoint {
        data = typeof data === 'object' ? data : {};
        let result = new Checkpoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["checkpointTypeCode"] = this.checkpointTypeCode;
        data["publicStatus"] = this.publicStatus;
        data["completedDate"] = this.completedDate ? this.completedDate.toISOString() : <any>undefined;
        data["private"] = this.private;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        return data;
    }
}

/** The checkpoint entry for a case. */
export interface ICheckpoint {
    /** The Id of the checkpoint. */
    id?: string;
    /** The checkpoint type code. This is the inner status the back-officer can see. */
    checkpointTypeCode?: string | undefined;
    publicStatus?: CasePublicStatus;
    /** The completed date of the checkpoint. */
    completedDate?: Date | undefined;
    /** Indicates if the checkpoint is private, which means not visible to the customer. */
    private?: boolean | undefined;
    /** The due date of the checkpoint. */
    dueDate?: Date | undefined;
}

/** The checkpoint type request model. */
export class CheckpointTypeDetails implements ICheckpointTypeDetails {
    /** The Id of the checkpoint type. */
    id?: string;
    /** The name of the checkpoint. */
    name?: string | undefined;
    /** The description of the checkpoint. */
    description?: string | undefined;
    publicStatus?: CasePublicStatus;
    /** Boolean for whether the checkpoint is private. */
    private?: boolean;
    /** The related roles for this checkpoint. */
    roles?: string[] | undefined;

    constructor(data?: ICheckpointTypeDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.publicStatus = _data["publicStatus"];
            this.private = _data["private"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CheckpointTypeDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CheckpointTypeDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["publicStatus"] = this.publicStatus;
        data["private"] = this.private;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

/** The checkpoint type request model. */
export interface ICheckpointTypeDetails {
    /** The Id of the checkpoint type. */
    id?: string;
    /** The name of the checkpoint. */
    name?: string | undefined;
    /** The description of the checkpoint. */
    description?: string | undefined;
    publicStatus?: CasePublicStatus;
    /** Boolean for whether the checkpoint is private. */
    private?: boolean;
    /** The related roles for this checkpoint. */
    roles?: string[] | undefined;
}

/** The comment entry for a case. */
export class Comment implements IComment {
    /** The Id of the comment. */
    id?: string;
    /** The comment text. */
    text?: string | undefined;
    /** Indicates if the comment is made by customer */
    isCustomer?: boolean | undefined;
    /** Indicates if the comment is private, which means not visible to the customer. */
    private?: boolean | undefined;
    attachment?: CasesAttachmentLink;
    replyToComment?: Comment;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.isCustomer = _data["isCustomer"];
            this.private = _data["private"];
            this.attachment = _data["attachment"] ? CasesAttachmentLink.fromJS(_data["attachment"]) : <any>undefined;
            this.replyToComment = _data["replyToComment"] ? Comment.fromJS(_data["replyToComment"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["isCustomer"] = this.isCustomer;
        data["private"] = this.private;
        data["attachment"] = this.attachment ? this.attachment.toJSON() : <any>undefined;
        data["replyToComment"] = this.replyToComment ? this.replyToComment.toJSON() : <any>undefined;
        return data;
    }
}

/** The comment entry for a case. */
export interface IComment {
    /** The Id of the comment. */
    id?: string;
    /** The comment text. */
    text?: string | undefined;
    /** Indicates if the comment is made by customer */
    isCustomer?: boolean | undefined;
    /** Indicates if the comment is private, which means not visible to the customer. */
    private?: boolean | undefined;
    attachment?: CasesAttachmentLink;
    replyToComment?: Comment;
}

/** The response payload when creating a case. */
export class CreateCaseResponse implements ICreateCaseResponse {
    /** The Id of the case that created. */
    id?: string;
    /** The created date of the case that created. */
    created?: Date;

    constructor(data?: ICreateCaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateCaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

/** The response payload when creating a case. */
export interface ICreateCaseResponse {
    /** The Id of the case that created. */
    id?: string;
    /** The created date of the case that created. */
    created?: Date;
}

/** The request payload for creating a new draft case. */
export class CreateDraftCaseRequest implements ICreateDraftCaseRequest {
    /** The Case type code of the case. */
    caseTypeCode?: string | undefined;
    /** The group this case belongs to, eg a customer's branch */
    groupId?: string | undefined;
    customer?: CustomerMeta;
    /** A list of case metadata in key value pairs */
    metadata?: { [key: string]: string; } | undefined;
    /** The channel that created the draft case */
    channel?: string | undefined;

    constructor(data?: ICreateDraftCaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.caseTypeCode = _data["caseTypeCode"];
            this.groupId = _data["groupId"];
            this.customer = _data["customer"] ? CustomerMeta.fromJS(_data["customer"]) : <any>undefined;
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.channel = _data["channel"];
        }
    }

    static fromJS(data: any): CreateDraftCaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDraftCaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caseTypeCode"] = this.caseTypeCode;
        data["groupId"] = this.groupId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["channel"] = this.channel;
        return data;
    }
}

/** The request payload for creating a new draft case. */
export interface ICreateDraftCaseRequest {
    /** The Case type code of the case. */
    caseTypeCode?: string | undefined;
    /** The group this case belongs to, eg a customer's branch */
    groupId?: string | undefined;
    customer?: CustomerMeta;
    /** A list of case metadata in key value pairs */
    metadata?: { [key: string]: string; } | undefined;
    /** The channel that created the draft case */
    channel?: string | undefined;
}

/** Custom action blocking activity that will generate the corresponding component. */
export class CustomCaseAction implements ICustomCaseAction {
    /** The Id to trigger the action. */
    id?: string | undefined;
    /** The name of the action. */
    name?: string | undefined;
    /** The label of the action. */
    label?: string | undefined;
    /** The class of the action. */
    class?: string | undefined;
    /** Determines whether at the end of the action the user will be redirected to Cases list of Back-office UI. */
    redirectToList?: boolean | undefined;
    successMessage?: SuccessMessage;
    /** The description of the action. */
    description?: string | undefined;
    /** The Default Value of action's input. */
    defaultValue?: string | undefined;
    /** Determines whether the action will have an input element. */
    hasInput?: boolean | undefined;

    constructor(data?: ICustomCaseAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.label = _data["label"];
            this.class = _data["class"];
            this.redirectToList = _data["redirectToList"];
            this.successMessage = _data["successMessage"] ? SuccessMessage.fromJS(_data["successMessage"]) : <any>undefined;
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
            this.hasInput = _data["hasInput"];
        }
    }

    static fromJS(data: any): CustomCaseAction {
        data = typeof data === 'object' ? data : {};
        let result = new CustomCaseAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["label"] = this.label;
        data["class"] = this.class;
        data["redirectToList"] = this.redirectToList;
        data["successMessage"] = this.successMessage ? this.successMessage.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["hasInput"] = this.hasInput;
        return data;
    }
}

/** Custom action blocking activity that will generate the corresponding component. */
export interface ICustomCaseAction {
    /** The Id to trigger the action. */
    id?: string | undefined;
    /** The name of the action. */
    name?: string | undefined;
    /** The label of the action. */
    label?: string | undefined;
    /** The class of the action. */
    class?: string | undefined;
    /** Determines whether at the end of the action the user will be redirected to Cases list of Back-office UI. */
    redirectToList?: boolean | undefined;
    successMessage?: SuccessMessage;
    /** The description of the action. */
    description?: string | undefined;
    /** The Default Value of action's input. */
    defaultValue?: string | undefined;
    /** Determines whether the action will have an input element. */
    hasInput?: boolean | undefined;
}

/** Customer Data as Json string */
export class CustomerData implements ICustomerData {
    /** The json data as string. */
    formData?: string | undefined;

    constructor(data?: ICustomerData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formData = _data["formData"];
        }
    }

    static fromJS(data: any): CustomerData {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formData"] = this.formData;
        return data;
    }
}

/** Customer Data as Json string */
export interface ICustomerData {
    /** The json data as string. */
    formData?: string | undefined;
}

/** The customer response object that contains information from the integration system. Properties that have no direct mapping to this model can be added to Indice.Features.Cases.Models.Responses.CustomerDetails.Metadata dictionary. */
export class CustomerDetails implements ICustomerDetails {
    /** The Id of the customer as created to our Identity provider. */
    userId?: string | undefined;
    /** The Id of the customer as provided by the consumer/integrator. */
    customerId?: string | undefined;
    /** The first name of the customer. */
    firstName?: string | undefined;
    /** The last name of the customer. */
    lastName?: string | undefined;
    /** The Id of the group the customer belongs. */
    groupId?: string | undefined;
    /** Any extra customer metadata with consumer/integrator business logic. */
    metadata?: { [key: string]: string; } | undefined;

    constructor(data?: ICustomerDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.customerId = _data["customerId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.groupId = _data["groupId"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
        }
    }

    static fromJS(data: any): CustomerDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["customerId"] = this.customerId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["groupId"] = this.groupId;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        return data;
    }
}

/** The customer response object that contains information from the integration system. Properties that have no direct mapping to this model can be added to Indice.Features.Cases.Models.Responses.CustomerDetails.Metadata dictionary. */
export interface ICustomerDetails {
    /** The Id of the customer as created to our Identity provider. */
    userId?: string | undefined;
    /** The Id of the customer as provided by the consumer/integrator. */
    customerId?: string | undefined;
    /** The first name of the customer. */
    firstName?: string | undefined;
    /** The last name of the customer. */
    lastName?: string | undefined;
    /** The Id of the group the customer belongs. */
    groupId?: string | undefined;
    /** Any extra customer metadata with consumer/integrator business logic. */
    metadata?: { [key: string]: string; } | undefined;
}

/** Customer metadata related to the Customer the case is created for. The customer may create the case himself or the case could be created on this customers behalf */
export class CustomerMeta implements ICustomerMeta {
    userId?: string | undefined;
    customerId?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    readonly fullName?: string | undefined;

    constructor(data?: ICustomerMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.customerId = _data["customerId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            (<any>this).fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): CustomerMeta {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerMeta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["customerId"] = this.customerId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        return data;
    }
}

/** Customer metadata related to the Customer the case is created for. The customer may create the case himself or the case could be created on this customers behalf */
export interface ICustomerMeta {
    userId?: string | undefined;
    customerId?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
}

/** The request payload with the edited data. */
export class EditCaseRequest implements IEditCaseRequest {
    /** The data in json string. */
    data?: string | undefined;

    constructor(data?: IEditCaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): EditCaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new EditCaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        return data;
    }
}

/** The request payload with the edited data. */
export interface IEditCaseRequest {
    /** The data in json string. */
    data?: string | undefined;
}

/** A custom-made that a Back-office user can create, delete etc. */
export class Filter implements IFilter {
    /** The Id of the Filter. */
    id?: string;
    /** The Name of the Filter. */
    name?: string | undefined;
    /** The Query Parameters of the Filter. */
    queryParameters?: string | undefined;

    constructor(data?: IFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.queryParameters = _data["queryParameters"];
        }
    }

    static fromJS(data: any): Filter {
        data = typeof data === 'object' ? data : {};
        let result = new Filter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["queryParameters"] = this.queryParameters;
        return data;
    }
}

/** A custom-made that a Back-office user can create, delete etc. */
export interface IFilter {
    /** The Id of the Filter. */
    id?: string;
    /** The Name of the Filter. */
    name?: string | undefined;
    /** The Query Parameters of the Filter. */
    queryParameters?: string | undefined;
}

/** The lookup item model. */
export class LookupItem implements ILookupItem {
    /** The name or the key of the look up item */
    name?: string | undefined;
    /** The value of the lookup item */
    value?: string | undefined;

    constructor(data?: ILookupItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): LookupItem {
        data = typeof data === 'object' ? data : {};
        let result = new LookupItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

/** The lookup item model. */
export interface ILookupItem {
    /** The name or the key of the look up item */
    name?: string | undefined;
    /** The value of the lookup item */
    value?: string | undefined;
}

export class LookupItemResultSet implements ILookupItemResultSet {
    count?: number;
    items?: LookupItem[] | undefined;

    constructor(data?: ILookupItemResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LookupItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LookupItemResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new LookupItemResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILookupItemResultSet {
    count?: number;
    items?: LookupItem[] | undefined;
}

/** The model for the customer with the minimum required properties. */
export class MyCasePartial implements IMyCasePartial {
    /** Id of the case. */
    id?: string;
    /** The date the case was created. */
    created?: Date | undefined;
    publicStatus?: CasePublicStatus;
    /** The case type code of the case. */
    caseTypeCode?: string | undefined;
    /** The case type title of the case. */
    title?: string | undefined;
    /** The checkpoint name of the case. */
    checkpoint?: string | undefined;
    /** The message that has been submitted from the backoffice. */
    message?: string | undefined;
    /** Translations. */
    translations?: { [key: string]: MyCasePartialTranslation; } | undefined;

    constructor(data?: IMyCasePartial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.publicStatus = _data["publicStatus"];
            this.caseTypeCode = _data["caseTypeCode"];
            this.title = _data["title"];
            this.checkpoint = _data["checkpoint"];
            this.message = _data["message"];
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? MyCasePartialTranslation.fromJS(_data["translations"][key]) : new MyCasePartialTranslation();
                }
            }
        }
    }

    static fromJS(data: any): MyCasePartial {
        data = typeof data === 'object' ? data : {};
        let result = new MyCasePartial();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["publicStatus"] = this.publicStatus;
        data["caseTypeCode"] = this.caseTypeCode;
        data["title"] = this.title;
        data["checkpoint"] = this.checkpoint;
        data["message"] = this.message;
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** The model for the customer with the minimum required properties. */
export interface IMyCasePartial {
    /** Id of the case. */
    id?: string;
    /** The date the case was created. */
    created?: Date | undefined;
    publicStatus?: CasePublicStatus;
    /** The case type code of the case. */
    caseTypeCode?: string | undefined;
    /** The case type title of the case. */
    title?: string | undefined;
    /** The checkpoint name of the case. */
    checkpoint?: string | undefined;
    /** The message that has been submitted from the backoffice. */
    message?: string | undefined;
    /** Translations. */
    translations?: { [key: string]: MyCasePartialTranslation; } | undefined;
}

export class MyCasePartialResultSet implements IMyCasePartialResultSet {
    count?: number;
    items?: MyCasePartial[] | undefined;

    constructor(data?: IMyCasePartialResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MyCasePartial.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MyCasePartialResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new MyCasePartialResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMyCasePartialResultSet {
    count?: number;
    items?: MyCasePartial[] | undefined;
}

/** The translation wrapper for Indice.Features.Cases.Models.Responses.MyCasePartial model. */
export class MyCasePartialTranslation implements IMyCasePartialTranslation {
    /** The title of the case type. */
    title?: string | undefined;

    constructor(data?: IMyCasePartialTranslation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): MyCasePartialTranslation {
        data = typeof data === 'object' ? data : {};
        let result = new MyCasePartialTranslation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data;
    }
}

/** The translation wrapper for Indice.Features.Cases.Models.Responses.MyCasePartial model. */
export interface IMyCasePartialTranslation {
    /** The title of the case type. */
    title?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

/** The reject reason dto. */
export class RejectReason implements IRejectReason {
    /** The key of the reject reason. This key will be used in resources. */
    key?: string | undefined;
    /** The value of the reject reason. This will be translated into request language. */
    value?: string | undefined;

    constructor(data?: IRejectReason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): RejectReason {
        data = typeof data === 'object' ? data : {};
        let result = new RejectReason();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

/** The reject reason dto. */
export interface IRejectReason {
    /** The key of the reject reason. This key will be used in resources. */
    key?: string | undefined;
    /** The value of the reject reason. This will be translated into request language. */
    value?: string | undefined;
}

/** The SaveFilter Request */
export class SaveFilterRequest implements ISaveFilterRequest {
    /** The Name of the request */
    name?: string | undefined;
    /** The Query Parameters of the request */
    queryParameters?: string | undefined;

    constructor(data?: ISaveFilterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.queryParameters = _data["queryParameters"];
        }
    }

    static fromJS(data: any): SaveFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SaveFilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["queryParameters"] = this.queryParameters;
        return data;
    }
}

/** The SaveFilter Request */
export interface ISaveFilterRequest {
    /** The Name of the request */
    name?: string | undefined;
    /** The Query Parameters of the request */
    queryParameters?: string | undefined;
}

/** A success response message. */
export class SuccessMessage implements ISuccessMessage {
    /** The message's Title. */
    title?: string | undefined;
    /** The message's Body. */
    body?: string | undefined;

    constructor(data?: ISuccessMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): SuccessMessage {
        data = typeof data === 'object' ? data : {};
        let result = new SuccessMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["body"] = this.body;
        return data;
    }
}

/** A success response message. */
export interface ISuccessMessage {
    /** The message's Title. */
    title?: string | undefined;
    /** The message's Body. */
    body?: string | undefined;
}

/** A class that represents a timeline entry for a case. */
export class TimelineEntry implements ITimelineEntry {
    /** The timestamp. */
    timestamp?: Date;
    createdBy?: AuditMeta;
    /** Checks if the entry is Checkpoint change. */
    readonly isCheckpoint?: boolean;
    checkpoint?: Checkpoint;
    comment?: Comment;

    constructor(data?: ITimelineEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"] ? AuditMeta.fromJS(_data["createdBy"]) : <any>undefined;
            (<any>this).isCheckpoint = _data["isCheckpoint"];
            this.checkpoint = _data["checkpoint"] ? Checkpoint.fromJS(_data["checkpoint"]) : <any>undefined;
            this.comment = _data["comment"] ? Comment.fromJS(_data["comment"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TimelineEntry {
        data = typeof data === 'object' ? data : {};
        let result = new TimelineEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["isCheckpoint"] = this.isCheckpoint;
        data["checkpoint"] = this.checkpoint ? this.checkpoint.toJSON() : <any>undefined;
        data["comment"] = this.comment ? this.comment.toJSON() : <any>undefined;
        return data;
    }
}

/** A class that represents a timeline entry for a case. */
export interface ITimelineEntry {
    /** The timestamp. */
    timestamp?: Date;
    createdBy?: AuditMeta;
    /** Checks if the entry is Checkpoint change. */
    isCheckpoint?: boolean;
    checkpoint?: Checkpoint;
    comment?: Comment;
}

/** The request to update the data of the case. */
export class UpdateCaseRequest implements IUpdateCaseRequest {
    /** The data in json string. */
    data?: string | undefined;

    constructor(data?: IUpdateCaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): UpdateCaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        return data;
    }
}

/** The request to update the data of the case. */
export interface IUpdateCaseRequest {
    /** The data in json string. */
    data?: string | undefined;
}

export class ValidationProblemDetails implements IValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    readonly errors?: { [key: string]: string[]; } | undefined;

    constructor(data?: IValidationProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["errors"]) {
                (<any>this).errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>(<any>this).errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        return data;
    }
}

export interface IValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}