//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const IDENTITY_API_BASE_URL = new InjectionToken<string>('IDENTITY_API_BASE_URL');

export interface IIdentityApiService {
    /**
     * Retrieves the supported calling codes.
     * @return OK
     */
    getSupportedCallingCodes(): Observable<CallingCode[]>;
    /**
     * Generates a password reset token and sends it to the user via email.
     * @return No Content
     */
    forgotPassword(body: ForgotPasswordRequest): Observable<void>;
    /**
     * Changes the password of the user confirming the code received during forgot password process.
     * @return No Content
     */
    forgotPasswordConfirmation(body: ForgotPasswordConfirmationRequest): Observable<void>;
    /**
     * Gets the password options that are applied when the user creates an account.
     * @return OK
     */
    getPasswordOptions(): Observable<PasswordOptions>;
    /**
     * Self-service user registration endpoint.
     * @return No Content
     */
    register(body: RegisterRequest): Observable<void>;
    /**
     * Checks if a username already exists in the database.
     * @return No Content
     */
    checkUserNameExists(body: ValidateUserNameRequest): Observable<void>;
    /**
     * Validates a user's password against one or more configured IPasswordValidator.
     * @return OK
     */
    validatePassword(body: ValidatePasswordRequest): Observable<CredentialsValidationInfo>;
    /**
     * Returns a list of AppSettingInfo objects containing the total number of application settings in the database and the data filtered according to the provided AppSettingInfo.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @return OK
     */
    getSettings(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined): Observable<AppSettingInfoResultSet>;
    /**
     * Creates a new application setting.
     * @return Created
     */
    createSetting(body: CreateAppSettingRequest): Observable<AppSettingInfo>;
    /**
     * Gets an application setting by it's key.
     * @return OK
     */
    getSettingByKey(key: string): Observable<AppSettingInfo>;
    /**
     * Updates an existing application setting.
     * @return OK
     */
    updateSetting(key: string, body: UpdateAppSettingRequest): Observable<AppSettingInfo>;
    /**
     * Permanently deletes an application setting.
     * @return No Content
     */
    deleteSetting(key: string): Observable<void>;
    /**
     * Loads the appsettings.json file and saves the configuration in the database.
     * @param hardRefresh (optional) 
     * @return No Content
     */
    loadFromAppSettingsJson(hardRefresh?: boolean | undefined): Observable<void>;
    /**
     * Returns a list of ClaimTypeInfo objects containing the total number of claim types in the database and the data filtered according to the provided ListOptions.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param required (optional) 
     * @return OK
     */
    getClaimTypes(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, required?: boolean | undefined): Observable<ClaimTypeInfoResultSet>;
    /**
     * Creates a new claim type.
     * @return Created
     */
    createClaimType(body: CreateClaimTypeRequest): Observable<ClaimTypeInfo>;
    /**
     * Gets a claim type by it's unique id.
     * @return OK
     */
    getClaimType(claimTypeId: string): Observable<ClaimTypeInfo>;
    /**
     * Updates an existing claim type.
     * @return OK
     */
    updateClaimType(claimTypeId: string, body: UpdateClaimTypeRequest): Observable<ClaimTypeInfo>;
    /**
     * Permanently deletes an existing claim type.
     * @return No Content
     */
    deleteClaimType(claimTypeId: string): Observable<void>;
    /**
     * Returns a list of ClientInfo objects containing the total number of claim types in the database and the data filtered according to the provided ListOptions.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @return OK
     */
    getClients(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined): Observable<ClientInfoResultSet>;
    /**
     * Creates a new client.
     * @return Created
     */
    createClient(body: CreateClientRequest): Observable<ClientInfo>;
    /**
     * Gets a client by it's unique id.
     * @return OK
     */
    getClient(clientId: string): Observable<SingleClientInfo>;
    /**
     * Updates an existing client.
     * @return No Content
     */
    updateClient(clientId: string, body: UpdateClientRequest): Observable<void>;
    /**
     * Permanently deletes an existing client.
     * @return No Content
     */
    deleteClient(clientId: string): Observable<void>;
    /**
     * Adds a new secret, from a certificate, to an existing client.
     * @param file (optional) File data
     * @param password (optional) Optional password in case this is a application/x-pkcs12
     * @return OK
     */
    uploadCertificate(clientId: string, file?: FileParameter | undefined, password?: string | null | undefined): Observable<SecretInfo>;
    /**
     * Downloads a client secret if it is a certificate.
     * @return OK
     */
    getCertificate(clientId: string, secretId: number): Observable<FileResponse>;
    /**
     * Adds a claim for the specified client.
     * @return OK
     */
    addClientClaim(clientId: string, body: CreateClaimRequest): Observable<ClaimInfo>;
    /**
     * Removes an identity resource from the specified client.
     * @return No Content
     */
    deleteClientClaim(clientId: string, claimId: number): Observable<void>;
    /**
     * Adds a grant type to the specified client.
     * @return OK
     */
    addClientGrantType(clientId: string, grantType: string): Observable<GrantTypeInfo>;
    /**
     * Removes a grant type from the specified client.
     * @return No Content
     */
    deleteClientGrantType(clientId: string, grantType: string): Observable<void>;
    /**
     * Adds an identity resource to the specified client.
     * @return No Content
     */
    addClientResources(clientId: string, body: string[]): Observable<void>;
    /**
     * Removes a range of identity resources from the specified client.
     * @return No Content
     */
    deleteClientResource(clientId: string, resources: string[]): Observable<void>;
    /**
     * Adds a new secret to an existing client.
     * @return OK
     */
    addClientSecret(clientId: string, body: CreateSecretRequest): Observable<SecretInfo>;
    /**
     * Removes a specified secret from a client.
     * @return No Content
     */
    deleteClientSecret(clientId: string, secretId: number): Observable<void>;
    /**
     * Gets the UI configuration for the specified client.
     * @return OK
     */
    getClientTheme(clientId: string): Observable<ClientThemeConfigResponse>;
    /**
     * Creates or updates the ui configuration for the specified client.
     * @return No Content
     */
    createOrUpdateClientTheme(clientId: string, body: ClientThemeConfigRequest): Observable<void>;
    /**
     * Renews the list of client urls (redirect cors etc).
     * @return No Content
     */
    updateClientUrls(clientId: string, body: UpdateClientUrls): Observable<void>;
    /**
     * Gets the metadata of a certificate for display.
     * @param file (optional) File data
     * @param password (optional) Optional password in case this is a application/x-pkcs12
     * @return OK
     */
    getCertificateMetadata(file?: FileParameter | undefined, password?: string | null | undefined): Observable<SecretInfoBase>;
    /**
     * Displays blog posts from the official IdentityServer blog.
     * @param page (optional) 
     * @param size (optional) 
     * @return OK
     */
    getNews(page?: number | undefined, size?: number | undefined): Observable<BlogItemInfoResultSet>;
    /**
     * Gets some useful information as a summary of the system.
     * @return OK
     */
    getSystemSummary(): Observable<SummaryInfo>;
    /**
     * Gets the UI features status.
     * @return OK
     */
    getUiFeatures(): Observable<UiFeaturesInfo>;
    /**
     * Sends a push notification.
     * @return No Content
     */
    sendPushNotification(body: SendPushNotificationRequest): Observable<void>;
    /**
     * Gets the list of available external providers.
     * @return OK
     */
    getExternalProviders(): Observable<ExternalProviderResultSet>;
    /**
     * Permanently deletes current user's account.
     * @return No Content
     */
    deleteAccount(): Observable<void>;
    /**
     * Blocks a user account.
     * @return No Content
     */
    blockAccount(body: SetUserBlockRequest): Observable<void>;
    /**
     * Gets the claims of the user.
     * @return OK
     */
    getClaims(): Observable<ClaimInfoResultSet>;
    /**
     * Adds the requested claims on the current user's account.
     * @return OK
     */
    addClaims(body: CreateClaimRequest[]): Observable<ClaimInfoResultSet>;
    /**
     * Upserts the requested claims on the current user's account.
     * @return OK
     */
    patchClaims(body: CreateClaimRequest[]): Observable<ClaimInfoResultSet>;
    /**
     * Updates the specified claim for the current user.
     * @return OK
     */
    updateClaim(claimId: number, body: UpdateUserClaimRequest): Observable<ClaimInfo>;
    /**
     * Updates the email of the current user.
     * @return No Content
     */
    updateEmail(body: UpdateUserEmailRequest): Observable<void>;
    /**
     * Confirms the email address of a given user.
     * @return No Content
     */
    confirmEmail(body: ConfirmEmailRequest): Observable<void>;
    /**
     * Gets the consents given by the user.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param consentType (optional) 
     * @param clientId (optional) 
     * @return OK
     */
    getConsents(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, consentType?: string | undefined, clientId?: string | undefined): Observable<UserConsentInfoResultSet>;
    /**
     * Updates the max devices count.
     * @return No Content
     */
    updateMaxDevicesCount(body: UpdateMaxDevicesCountRequest): Observable<void>;
    /**
     * Changes the password for the current user, but requires the old password to be present.
     * @return No Content
     */
    updatePassword(body: ChangePasswordRequest): Observable<void>;
    /**
     * Updates the password expiration policy.
     * @return No Content
     */
    updatePasswordExpirationPolicy(body: UpdatePasswordExpirationPolicyRequest): Observable<void>;
    /**
     * Requests a phone number change for the current user.
     * @return No Content
     */
    updatePhoneNumber(body: UpdateUserPhoneNumberRequest): Observable<void>;
    /**
     * Confirms the phone number of the user, using the OTP token.
     * @return No Content
     */
    confirmPhoneNumber(body: ConfirmPhoneNumberRequest): Observable<void>;
    /**
     * Create or update profile picture of the current user.
     * @param file (optional) File data
     * @param scale (optional) Zoom level. Defaults to 1.0
     * @param translateX (optional) offset X axis. Defaults to 0.
     * @param translateY (optional) offset Y axis. Defaults to 0
     * @param viewPort (optional) The side size of the viewport square used to crop the image source. 
    This is used as a reference for converting the Indice.Features.Identity.Server.Manager.Models.ImageUploadRequest.TranslateX and Indice.Features.Identity.Server.Manager.Models.ImageUploadRequest.TranslateY to the internal crop sqare the will be used as the final size of the picture.
    If left empty it is asumed as if it is the same as the size of the internal crop square.
     * @return No Content
     */
    saveMyPicture(file?: FileParameter | undefined, scale?: number | null | undefined, translateX?: number | null | undefined, translateY?: number | null | undefined, viewPort?: number | null | undefined): Observable<void>;
    /**
     * Clear profile picture from the current user.
     * @return No Content
     */
    clearMyPicture(): Observable<void>;
    /**
     * Get my profile picture.
     * @param size (optional) 
     * @param d (optional) 
     */
    getMyPicture(size?: number | undefined, d?: string | undefined): Observable<void>;
    /**
     * Get my profile picture.
     * @param size (optional) 
     * @param d (optional) 
     */
    getMyPictureFormat(format: string, size?: number | undefined, d?: string | undefined): Observable<void>;
    /**
     * Get my profile picture.
     * @param d (optional) 
     */
    getMyPictureSize(size: number, d?: string | undefined): Observable<void>;
    /**
     * Get my profile picture.
     * @param d (optional) 
     */
    getMyPictureSizeFormat(size: number, format: string, d?: string | undefined): Observable<void>;
    /**
     * Changes the username for the current user.
     * @return No Content
     */
    updateUserName(body: UpdateUserNameRequest): Observable<void>;
    /**
     * Returns a list of registered user devices.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param isPushNotificationEnabled (optional) 
     * @param isTrusted (optional) 
     * @param blocked (optional) 
     * @param clientType (optional) 
     * @param isPendingTrustActivation (optional) 
     * @param isMfaSessionExpired (optional) 
     * @return OK
     */
    getDevices(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, isPushNotificationEnabled?: boolean | undefined, isTrusted?: boolean | undefined, blocked?: boolean | undefined, clientType?: string | undefined, isPendingTrustActivation?: boolean | undefined, isMfaSessionExpired?: boolean | undefined): Observable<DeviceInfoResultSet>;
    /**
     * Creates a new device and optionally registers for push notifications.
     * @return Created
     */
    createDevice(body: RegisterDeviceRequest): Observable<DeviceInfo>;
    /**
     * Gets a device by it's unique id.
     * @return OK
     */
    getDeviceById(deviceId: string): Observable<DeviceInfo>;
    /**
     * Updates a device.
     * @return No Content
     */
    updateDevice(deviceId: string, body: UpdateDeviceRequest): Observable<void>;
    /**
     * Deletes the device.
     * @return No Content
     */
    deleteDevice(deviceId: string): Observable<void>;
    /**
     * Starts the process of trusting a device.
     * @return No Content
     */
    trustDevice(deviceId: string, body: TrustDeviceRequest): Observable<void>;
    /**
     * Sets a device as untrusted.
     * @return No Content
     */
    untrustDevice(deviceId: string): Observable<void>;
    /**
     * Gets the list of sign in logs for the current user.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @param applicationId (optional) 
     * @param signInType (optional) 
     * @return OK
     */
    getMySignInLogs(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, from?: Date | undefined, to?: Date | undefined, applicationId?: string | undefined, signInType?: string | undefined): Observable<SignInLogEntryResultSet>;
    /**
     * Returns a list of IdentityResourceInfo objects containing the total number of identity resources in the database and the data filtered according to the provided ListOptions.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @return OK
     */
    getIdentityResources(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined): Observable<IdentityResourceInfoResultSet>;
    /**
     * Gets an identity resource by it's unique id.
     * @return OK
     */
    getIdentityResource(resourceId: number): Observable<IdentityResourceInfo>;
    /**
     * Creates a new identity resource.
     * @return Created
     */
    createIdentityResource(body: CreateResourceRequest): Observable<IdentityResourceInfo>;
    /**
     * Updates an identity resource.
     * @return No Content
     */
    updateIdentityResource(resourceId: number, body: UpdateIdentityResourceRequest): Observable<void>;
    /**
     * Permanently deletes an identity resource.
     * @return No Content
     */
    deleteIdentityResource(resourceId: number): Observable<void>;
    /**
     * Adds claims to an identity resource.
     * @return No Content
     */
    addIdentityResourceClaims(resourceId: number, body: string[]): Observable<void>;
    /**
     * Removes a specified claim from an identity resource.
     * @return No Content
     */
    deleteIdentityResourceClaim(resourceId: number, claim: string): Observable<void>;
    /**
     * Returns a list of ApiResourceInfo objects containing the total number of API resources in the database and the data filtered according to the provided ListOptions.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @return OK
     */
    getApiResources(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined): Observable<ApiResourceInfoResultSet>;
    /**
     * Creates a new API resource.
     * @return Created
     */
    createApiResource(body: CreateResourceRequest): Observable<ApiResourceInfo>;
    /**
     * Gets an API resource by it's unique id.
     * @return OK
     */
    getApiResource(resourceId: number): Observable<ApiResourceInfo>;
    /**
     * Updates an API resource.
     * @return No Content
     */
    updateApiResource(resourceId: number, body: UpdateApiResourceRequest): Observable<void>;
    /**
     * Permanently deletes an API resource.
     * @return No Content
     */
    deleteApiResource(resourceId: number): Observable<void>;
    /**
     * Adds claims to an API resource.
     * @return No Content
     */
    addApiResourceClaims(resourceId: number, body: string[]): Observable<void>;
    /**
     * Removes a specified claim from an API resource.
     * @return No Content
     */
    deleteApiResourceClaim(resourceId: number, claim: string): Observable<void>;
    /**
     * Adds a new scope to an existing API resource.
     * @return OK
     */
    addApiResourceScope(resourceId: number, body: CreateApiScopeRequest): Observable<ApiScopeInfo>;
    /**
     * Updates a specified scope of an API resource.
     * @return No Content
     */
    updateApiResourceScope(resourceId: number, scopeId: number, body: UpdateApiScopeRequest): Observable<void>;
    /**
     * Deletes a specified scope from an API resource.
     * @return No Content
     */
    deleteApiResourceScope(resourceId: number, scopeId: number): Observable<void>;
    /**
     * Adds claims to an API scope of a protected resource.
     * @return No Content
     */
    addApiResourceScopeClaims(resourceId: number, scopeId: number, body: string[]): Observable<void>;
    /**
     * Deletes a claim from an API scope of a protected resource.
     * @return No Content
     */
    deleteApiResourceScopeClaim(resourceId: number, scopeId: number, claim: string): Observable<void>;
    /**
     * Adds a new scope to an existing API resource.
     * @return OK
     */
    addApiResourceSecret(resourceId: number, body: CreateSecretRequest): Observable<SecretInfo>;
    /**
     * Removes a specified claim from an API resource.
     * @return No Content
     */
    deleteApiResourceSecret(resourceId: number, secretId: number): Observable<void>;
    /**
     * Returns a list of ApiResourceInfo objects containing the total number of API resources in the database and the data filtered according to the provided ListOptions.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @return OK
     */
    getApiScopes(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined): Observable<ApiScopeInfoResultSet>;
    /**
     * Returns a list of RoleInfo objects containing the total number of roles in the database and the data filtered according to the provided ListOptions.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @return OK
     */
    getRoles(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined): Observable<RoleInfoResultSet>;
    /**
     * Creates a new role.
     * @return Created
     */
    createRole(body: CreateRoleRequest): Observable<RoleInfo>;
    /**
     * Gets a role by it's unique id.
     * @return OK
     */
    getRole(roleId: string): Observable<RoleInfo>;
    /**
     * Updates an existing role.
     * @return OK
     */
    updateRole(roleId: string, body: UpdateRoleRequest): Observable<RoleInfo>;
    /**
     * Permanently deletes an existing role.
     * @return No Content
     */
    deleteRole(roleId: string): Observable<void>;
    /**
     * Gets the list of sign in logs produced by the Identity system.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param subject (optional) 
     * @param sessionId (optional) 
     * @param markForReview (optional) 
     * @param succeeded (optional) 
     * @param actionName (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @param applicationId (optional) 
     * @param signInType (optional) 
     * @return OK
     */
    getSignInLogs(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, subject?: string | undefined, sessionId?: string | undefined, markForReview?: boolean | undefined, succeeded?: boolean | undefined, actionName?: string | undefined, from?: Date | undefined, to?: Date | undefined, applicationId?: string | undefined, signInType?: string | undefined): Observable<SignInLogEntryResultSet>;
    /**
     * Patches the specified log entry by updating the properties given in the request.
     * @return No Content
     */
    patchSignInLog(rowId: string, body: SignInLogEntryRequest): Observable<void>;
    /**
     * Sends a new code via the selected channel.
     * @return No Content
     */
    send(body: TotpRequest): Observable<void>;
    /**
     * Verify the code received.
     * @return No Content
     */
    verify(body: TotpVerificationRequest): Observable<void>;
    /**
     * Returns a list of UserInfo objects containing the total number of users in the database and the data filtered according to the provided ListOptions.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param claimType (optional) 
     * @param claimValue (optional) 
     * @param userId (optional) 
     * @param expandClaims (optional) 
     * @return OK
     */
    getUsers(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, claimType?: string | undefined, claimValue?: string | undefined, userId?: string[] | undefined, expandClaims?: string[] | undefined): Observable<UserInfoResultSet>;
    /**
     * Creates a new user.
     * @return Created
     */
    createUser(body: CreateUserRequest): Observable<SingleUserInfo>;
    /**
     * Gets a user by it's unique id.
     * @return OK
     */
    getUser(userId: string): Observable<SingleUserInfo>;
    /**
     * Updates an existing user.
     * @return OK
     */
    updateUser(userId: string, body: UpdateUserRequest): Observable<SingleUserInfo>;
    /**
     * Permanently deletes an existing user.
     * @return No Content
     */
    deleteUser(userId: string): Observable<void>;
    /**
     * Gets a list of the applications the user has given consent to or currently has IdentityServer side tokens for.
     * @return OK
     */
    getUserApplications(userId: string): Observable<UserClientInfoResultSet>;
    /**
     * Toggles user block state.
     * @return No Content
     */
    setUserBlock(userId: string, body: SetUserBlockRequest): Observable<void>;
    /**
     * Adds a claim for the specified user.
     * @return Created
     */
    addUserClaim(userId: string, body: CreateClaimRequest): Observable<ClaimInfo>;
    /**
     * Gets a specified claim for a given user.
     * @return OK
     */
    getUserClaim(userId: string, claimId: number): Observable<BasicClaimInfo>;
    /**
     * Updates an existing user claim.
     * @return OK
     */
    updateUserClaim(userId: string, claimId: number, body: UpdateUserClaimRequest): Observable<ClaimInfo>;
    /**
     * Permanently deletes a specified claim from a user.
     * @return No Content
     */
    deleteUserClaim(claimId: number, userId: string): Observable<void>;
    /**
     * Gets a list of the devices of the specified user.
     * @return OK
     */
    getUserDevices(userId: string): Observable<DeviceInfoResultSet>;
    /**
     * Resends the confirmation email for a given user.
     * @return No Content
     */
    resendConfirmationEmail(userId: string): Observable<void>;
    /**
     * Gets a list of the external login providers for the specified user.
     * @return OK
     */
    getUserExternalLogins(userId: string): Observable<UserLoginProviderInfoResultSet>;
    /**
     * Permanently deletes a specified login provider association from a user.
     * @return No Content
     */
    deleteUserExternalLogin(userId: string, provider: string): Observable<void>;
    /**
     * Create or update profile picture of the given user.
     * @param file (optional) File data
     * @param scale (optional) Zoom level. Defaults to 1.0
     * @param translateX (optional) offset X axis. Defaults to 0.
     * @param translateY (optional) offset Y axis. Defaults to 0
     * @param viewPort (optional) The side size of the viewport square used to crop the image source. 
    This is used as a reference for converting the Indice.Features.Identity.Server.Manager.Models.ImageUploadRequest.TranslateX and Indice.Features.Identity.Server.Manager.Models.ImageUploadRequest.TranslateY to the internal crop sqare the will be used as the final size of the picture.
    If left empty it is asumed as if it is the same as the size of the internal crop square.
     * @return No Content
     */
    saveUserPicture(userId: string, file?: FileParameter | undefined, scale?: number | null | undefined, translateX?: number | null | undefined, translateY?: number | null | undefined, viewPort?: number | null | undefined): Observable<void>;
    /**
     * Clear profile picture from the given user.
     * @return No Content
     */
    clearUserPicture(userId: string): Observable<void>;
    /**
     * Get user's profile picture.
     * @param size (optional) 
     * @param d (optional) 
     */
    getUserPicture(userId: string, size?: number | undefined, d?: string | undefined): Observable<void>;
    /**
     * Get user's profile picture.
     * @param size (optional) 
     * @param d (optional) 
     */
    getUserPictureFormat(userId: string, format: string, size?: number | undefined, d?: string | undefined): Observable<void>;
    /**
     * Get user's profile picture.
     * @param d (optional) 
     */
    getUserPictureSize(userId: string, size: number, d?: string | undefined): Observable<void>;
    /**
     * Get user's profile picture.
     * @param d (optional) 
     */
    getUserPictureSizeFormat(userId: string, size: number, format: string, d?: string | undefined): Observable<void>;
    /**
     * Adds a new role to the specified user.
     * @return No Content
     */
    addUserRole(userId: string, roleId: string): Observable<void>;
    /**
     * Removes an existing role from the specified user.
     * @return No Content
     */
    deleteUserRole(userId: string, roleId: string): Observable<void>;
    /**
     * Sets the password for a given user.
     * @return No Content
     */
    setPassword(userId: string, body: SetPasswordRequest): Observable<void>;
    /**
     * Unlocks a user.
     * @return No Content
     */
    unlockUser(userId: string): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class IdentityApiService implements IIdentityApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(IDENTITY_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Retrieves the supported calling codes.
     * @return OK
     */
    getSupportedCallingCodes(): Observable<CallingCode[]> {
        let url_ = this.baseUrl + "/api/account/calling-codes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupportedCallingCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupportedCallingCodes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CallingCode[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CallingCode[]>;
        }));
    }

    protected processGetSupportedCallingCodes(response: HttpResponseBase): Observable<CallingCode[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CallingCode.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Generates a password reset token and sends it to the user via email.
     * @return No Content
     */
    forgotPassword(body: ForgotPasswordRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/account/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Changes the password of the user confirming the code received during forgot password process.
     * @return No Content
     */
    forgotPasswordConfirmation(body: ForgotPasswordConfirmationRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/account/forgot-password/confirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPasswordConfirmation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPasswordConfirmation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processForgotPasswordConfirmation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the password options that are applied when the user creates an account.
     * @return OK
     */
    getPasswordOptions(): Observable<PasswordOptions> {
        let url_ = this.baseUrl + "/api/account/password-options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordOptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordOptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PasswordOptions>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PasswordOptions>;
        }));
    }

    protected processGetPasswordOptions(response: HttpResponseBase): Observable<PasswordOptions> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PasswordOptions.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Self-service user registration endpoint.
     * @return No Content
     */
    register(body: RegisterRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/account/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Checks if a username already exists in the database.
     * @return No Content
     */
    checkUserNameExists(body: ValidateUserNameRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/account/username-exists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUserNameExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUserNameExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCheckUserNameExists(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 410) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result410: any = null;
            let resultData410 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result410 = ProblemDetails.fromJS(resultData410);
            return throwException("Gone", status, _responseText, _headers, result410);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Validates a user's password against one or more configured IPasswordValidator.
     * @return OK
     */
    validatePassword(body: ValidatePasswordRequest): Observable<CredentialsValidationInfo> {
        let url_ = this.baseUrl + "/api/account/validate-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidatePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidatePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CredentialsValidationInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CredentialsValidationInfo>;
        }));
    }

    protected processValidatePassword(response: HttpResponseBase): Observable<CredentialsValidationInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CredentialsValidationInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Returns a list of AppSettingInfo objects containing the total number of application settings in the database and the data filtered according to the provided AppSettingInfo.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @return OK
     */
    getSettings(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined): Observable<AppSettingInfoResultSet> {
        let url_ = this.baseUrl + "/api/app-settings?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppSettingInfoResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppSettingInfoResultSet>;
        }));
    }

    protected processGetSettings(response: HttpResponseBase): Observable<AppSettingInfoResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingInfoResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Creates a new application setting.
     * @return Created
     */
    createSetting(body: CreateAppSettingRequest): Observable<AppSettingInfo> {
        let url_ = this.baseUrl + "/api/app-settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppSettingInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppSettingInfo>;
        }));
    }

    protected processCreateSetting(response: HttpResponseBase): Observable<AppSettingInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AppSettingInfo.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets an application setting by it's key.
     * @return OK
     */
    getSettingByKey(key: string): Observable<AppSettingInfo> {
        let url_ = this.baseUrl + "/api/app-settings/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettingByKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettingByKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppSettingInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppSettingInfo>;
        }));
    }

    protected processGetSettingByKey(response: HttpResponseBase): Observable<AppSettingInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates an existing application setting.
     * @return OK
     */
    updateSetting(key: string, body: UpdateAppSettingRequest): Observable<AppSettingInfo> {
        let url_ = this.baseUrl + "/api/app-settings/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppSettingInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppSettingInfo>;
        }));
    }

    protected processUpdateSetting(response: HttpResponseBase): Observable<AppSettingInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permanently deletes an application setting.
     * @return No Content
     */
    deleteSetting(key: string): Observable<void> {
        let url_ = this.baseUrl + "/api/app-settings/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteSetting(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Loads the appsettings.json file and saves the configuration in the database.
     * @param hardRefresh (optional) 
     * @return No Content
     */
    loadFromAppSettingsJson(hardRefresh?: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/app-settings/load?";
        if (hardRefresh === null)
            throw new Error("The parameter 'hardRefresh' cannot be null.");
        else if (hardRefresh !== undefined)
            url_ += "hardRefresh=" + encodeURIComponent("" + hardRefresh) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoadFromAppSettingsJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoadFromAppSettingsJson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLoadFromAppSettingsJson(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Returns a list of ClaimTypeInfo objects containing the total number of claim types in the database and the data filtered according to the provided ListOptions.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param required (optional) 
     * @return OK
     */
    getClaimTypes(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, required?: boolean | undefined): Observable<ClaimTypeInfoResultSet> {
        let url_ = this.baseUrl + "/api/claim-types?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (required === null)
            throw new Error("The parameter 'required' cannot be null.");
        else if (required !== undefined)
            url_ += "Required=" + encodeURIComponent("" + required) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaimTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaimTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimTypeInfoResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimTypeInfoResultSet>;
        }));
    }

    protected processGetClaimTypes(response: HttpResponseBase): Observable<ClaimTypeInfoResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimTypeInfoResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Creates a new claim type.
     * @return Created
     */
    createClaimType(body: CreateClaimTypeRequest): Observable<ClaimTypeInfo> {
        let url_ = this.baseUrl + "/api/claim-types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateClaimType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateClaimType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimTypeInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimTypeInfo>;
        }));
    }

    protected processCreateClaimType(response: HttpResponseBase): Observable<ClaimTypeInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ClaimTypeInfo.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a claim type by it's unique id.
     * @return OK
     */
    getClaimType(claimTypeId: string): Observable<ClaimTypeInfo> {
        let url_ = this.baseUrl + "/api/claim-types/{claimTypeId}";
        if (claimTypeId === undefined || claimTypeId === null)
            throw new Error("The parameter 'claimTypeId' must be defined.");
        url_ = url_.replace("{claimTypeId}", encodeURIComponent("" + claimTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaimType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaimType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimTypeInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimTypeInfo>;
        }));
    }

    protected processGetClaimType(response: HttpResponseBase): Observable<ClaimTypeInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimTypeInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates an existing claim type.
     * @return OK
     */
    updateClaimType(claimTypeId: string, body: UpdateClaimTypeRequest): Observable<ClaimTypeInfo> {
        let url_ = this.baseUrl + "/api/claim-types/{claimTypeId}";
        if (claimTypeId === undefined || claimTypeId === null)
            throw new Error("The parameter 'claimTypeId' must be defined.");
        url_ = url_.replace("{claimTypeId}", encodeURIComponent("" + claimTypeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClaimType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClaimType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimTypeInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimTypeInfo>;
        }));
    }

    protected processUpdateClaimType(response: HttpResponseBase): Observable<ClaimTypeInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimTypeInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permanently deletes an existing claim type.
     * @return No Content
     */
    deleteClaimType(claimTypeId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/claim-types/{claimTypeId}";
        if (claimTypeId === undefined || claimTypeId === null)
            throw new Error("The parameter 'claimTypeId' must be defined.");
        url_ = url_.replace("{claimTypeId}", encodeURIComponent("" + claimTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClaimType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClaimType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteClaimType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Returns a list of ClientInfo objects containing the total number of claim types in the database and the data filtered according to the provided ListOptions.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @return OK
     */
    getClients(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined): Observable<ClientInfoResultSet> {
        let url_ = this.baseUrl + "/api/clients?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientInfoResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientInfoResultSet>;
        }));
    }

    protected processGetClients(response: HttpResponseBase): Observable<ClientInfoResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientInfoResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Creates a new client.
     * @return Created
     */
    createClient(body: CreateClientRequest): Observable<ClientInfo> {
        let url_ = this.baseUrl + "/api/clients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateClient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientInfo>;
        }));
    }

    protected processCreateClient(response: HttpResponseBase): Observable<ClientInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ClientInfo.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a client by it's unique id.
     * @return OK
     */
    getClient(clientId: string): Observable<SingleClientInfo> {
        let url_ = this.baseUrl + "/api/clients/{clientId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SingleClientInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SingleClientInfo>;
        }));
    }

    protected processGetClient(response: HttpResponseBase): Observable<SingleClientInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SingleClientInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates an existing client.
     * @return No Content
     */
    updateClient(clientId: string, body: UpdateClientRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/clients/{clientId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateClient(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permanently deletes an existing client.
     * @return No Content
     */
    deleteClient(clientId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/clients/{clientId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteClient(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Adds a new secret, from a certificate, to an existing client.
     * @param file (optional) File data
     * @param password (optional) Optional password in case this is a application/x-pkcs12
     * @return OK
     */
    uploadCertificate(clientId: string, file?: FileParameter | undefined, password?: string | null | undefined): Observable<SecretInfo> {
        let url_ = this.baseUrl + "/api/clients/{clientId}/certificates";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (password !== null && password !== undefined)
            content_.append("password", password.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadCertificate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecretInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecretInfo>;
        }));
    }

    protected processUploadCertificate(response: HttpResponseBase): Observable<SecretInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecretInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Downloads a client secret if it is a certificate.
     * @return OK
     */
    getCertificate(clientId: string, secretId: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/clients/{clientId}/certificates/{secretId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (secretId === undefined || secretId === null)
            throw new Error("The parameter 'secretId' must be defined.");
        url_ = url_.replace("{secretId}", encodeURIComponent("" + secretId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/x-x509-user-cert"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCertificate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetCertificate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Adds a claim for the specified client.
     * @return OK
     */
    addClientClaim(clientId: string, body: CreateClaimRequest): Observable<ClaimInfo> {
        let url_ = this.baseUrl + "/api/clients/{clientId}/claims";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddClientClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddClientClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimInfo>;
        }));
    }

    protected processAddClientClaim(response: HttpResponseBase): Observable<ClaimInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Removes an identity resource from the specified client.
     * @return No Content
     */
    deleteClientClaim(clientId: string, claimId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/clients/{clientId}/claims/{claimId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (claimId === undefined || claimId === null)
            throw new Error("The parameter 'claimId' must be defined.");
        url_ = url_.replace("{claimId}", encodeURIComponent("" + claimId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClientClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClientClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteClientClaim(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Adds a grant type to the specified client.
     * @return OK
     */
    addClientGrantType(clientId: string, grantType: string): Observable<GrantTypeInfo> {
        let url_ = this.baseUrl + "/api/clients/{clientId}/grant-types/{grantType}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (grantType === undefined || grantType === null)
            throw new Error("The parameter 'grantType' must be defined.");
        url_ = url_.replace("{grantType}", encodeURIComponent("" + grantType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddClientGrantType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddClientGrantType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GrantTypeInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GrantTypeInfo>;
        }));
    }

    protected processAddClientGrantType(response: HttpResponseBase): Observable<GrantTypeInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GrantTypeInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Removes a grant type from the specified client.
     * @return No Content
     */
    deleteClientGrantType(clientId: string, grantType: string): Observable<void> {
        let url_ = this.baseUrl + "/api/clients/{clientId}/grant-types/{grantType}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (grantType === undefined || grantType === null)
            throw new Error("The parameter 'grantType' must be defined.");
        url_ = url_.replace("{grantType}", encodeURIComponent("" + grantType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClientGrantType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClientGrantType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteClientGrantType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Adds an identity resource to the specified client.
     * @return No Content
     */
    addClientResources(clientId: string, body: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/clients/{clientId}/resources";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddClientResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddClientResources(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddClientResources(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Removes a range of identity resources from the specified client.
     * @return No Content
     */
    deleteClientResource(clientId: string, resources: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/clients/{clientId}/resources?";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (resources === undefined || resources === null)
            throw new Error("The parameter 'resources' must be defined and cannot be null.");
        else
            resources && resources.forEach(item => { url_ += "resources=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClientResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClientResource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteClientResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Adds a new secret to an existing client.
     * @return OK
     */
    addClientSecret(clientId: string, body: CreateSecretRequest): Observable<SecretInfo> {
        let url_ = this.baseUrl + "/api/clients/{clientId}/secrets";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddClientSecret(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddClientSecret(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecretInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecretInfo>;
        }));
    }

    protected processAddClientSecret(response: HttpResponseBase): Observable<SecretInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecretInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Removes a specified secret from a client.
     * @return No Content
     */
    deleteClientSecret(clientId: string, secretId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/clients/{clientId}/secrets/{secretId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        if (secretId === undefined || secretId === null)
            throw new Error("The parameter 'secretId' must be defined.");
        url_ = url_.replace("{secretId}", encodeURIComponent("" + secretId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteClientSecret(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteClientSecret(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteClientSecret(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the UI configuration for the specified client.
     * @return OK
     */
    getClientTheme(clientId: string): Observable<ClientThemeConfigResponse> {
        let url_ = this.baseUrl + "/api/clients/{clientId}/theme";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientThemeConfigResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientThemeConfigResponse>;
        }));
    }

    protected processGetClientTheme(response: HttpResponseBase): Observable<ClientThemeConfigResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientThemeConfigResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Creates or updates the ui configuration for the specified client.
     * @return No Content
     */
    createOrUpdateClientTheme(clientId: string, body: ClientThemeConfigRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/clients/{clientId}/theme";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateClientTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateClientTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateClientTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Renews the list of client urls (redirect cors etc).
     * @return No Content
     */
    updateClientUrls(clientId: string, body: UpdateClientUrls): Observable<void> {
        let url_ = this.baseUrl + "/api/clients/{clientId}/urls";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClientUrls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClientUrls(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateClientUrls(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the metadata of a certificate for display.
     * @param file (optional) File data
     * @param password (optional) Optional password in case this is a application/x-pkcs12
     * @return OK
     */
    getCertificateMetadata(file?: FileParameter | undefined, password?: string | null | undefined): Observable<SecretInfoBase> {
        let url_ = this.baseUrl + "/api/clients/certificates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (password !== null && password !== undefined)
            content_.append("password", password.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCertificateMetadata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCertificateMetadata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecretInfoBase>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecretInfoBase>;
        }));
    }

    protected processGetCertificateMetadata(response: HttpResponseBase): Observable<SecretInfoBase> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecretInfoBase.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Displays blog posts from the official IdentityServer blog.
     * @param page (optional) 
     * @param size (optional) 
     * @return OK
     */
    getNews(page?: number | undefined, size?: number | undefined): Observable<BlogItemInfoResultSet> {
        let url_ = this.baseUrl + "/api/dashboard/news?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNews(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BlogItemInfoResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BlogItemInfoResultSet>;
        }));
    }

    protected processGetNews(response: HttpResponseBase): Observable<BlogItemInfoResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BlogItemInfoResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets some useful information as a summary of the system.
     * @return OK
     */
    getSystemSummary(): Observable<SummaryInfo> {
        let url_ = this.baseUrl + "/api/dashboard/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSystemSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSystemSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SummaryInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SummaryInfo>;
        }));
    }

    protected processGetSystemSummary(response: HttpResponseBase): Observable<SummaryInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SummaryInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the UI features status.
     * @return OK
     */
    getUiFeatures(): Observable<UiFeaturesInfo> {
        let url_ = this.baseUrl + "/api/dashboard/ui";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiFeatures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UiFeaturesInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UiFeaturesInfo>;
        }));
    }

    protected processGetUiFeatures(response: HttpResponseBase): Observable<UiFeaturesInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UiFeaturesInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Sends a push notification.
     * @return No Content
     */
    sendPushNotification(body: SendPushNotificationRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/devices/push";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPushNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPushNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendPushNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the list of available external providers.
     * @return OK
     */
    getExternalProviders(): Observable<ExternalProviderResultSet> {
        let url_ = this.baseUrl + "/api/lookups/external-providers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalProviderResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalProviderResultSet>;
        }));
    }

    protected processGetExternalProviders(response: HttpResponseBase): Observable<ExternalProviderResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalProviderResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permanently deletes current user's account.
     * @return No Content
     */
    deleteAccount(): Observable<void> {
        let url_ = this.baseUrl + "/api/my/account";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Blocks a user account.
     * @return No Content
     */
    blockAccount(body: SetUserBlockRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/my/account/block";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBlockAccount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the claims of the user.
     * @return OK
     */
    getClaims(): Observable<ClaimInfoResultSet> {
        let url_ = this.baseUrl + "/api/my/account/claims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClaims(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimInfoResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimInfoResultSet>;
        }));
    }

    protected processGetClaims(response: HttpResponseBase): Observable<ClaimInfoResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimInfoResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Adds the requested claims on the current user's account.
     * @return OK
     */
    addClaims(body: CreateClaimRequest[]): Observable<ClaimInfoResultSet> {
        let url_ = this.baseUrl + "/api/my/account/claims";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddClaims(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimInfoResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimInfoResultSet>;
        }));
    }

    protected processAddClaims(response: HttpResponseBase): Observable<ClaimInfoResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimInfoResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Upserts the requested claims on the current user's account.
     * @return OK
     */
    patchClaims(body: CreateClaimRequest[]): Observable<ClaimInfoResultSet> {
        let url_ = this.baseUrl + "/api/my/account/claims";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatchClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatchClaims(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimInfoResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimInfoResultSet>;
        }));
    }

    protected processPatchClaims(response: HttpResponseBase): Observable<ClaimInfoResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimInfoResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates the specified claim for the current user.
     * @return OK
     */
    updateClaim(claimId: number, body: UpdateUserClaimRequest): Observable<ClaimInfo> {
        let url_ = this.baseUrl + "/api/my/account/claims/{claimId}";
        if (claimId === undefined || claimId === null)
            throw new Error("The parameter 'claimId' must be defined.");
        url_ = url_.replace("{claimId}", encodeURIComponent("" + claimId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimInfo>;
        }));
    }

    protected processUpdateClaim(response: HttpResponseBase): Observable<ClaimInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates the email of the current user.
     * @return No Content
     */
    updateEmail(body: UpdateUserEmailRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/my/account/email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Confirms the email address of a given user.
     * @return No Content
     */
    confirmEmail(body: ConfirmEmailRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/my/account/email/confirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConfirmEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the consents given by the user.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param consentType (optional) 
     * @param clientId (optional) 
     * @return OK
     */
    getConsents(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, consentType?: string | undefined, clientId?: string | undefined): Observable<UserConsentInfoResultSet> {
        let url_ = this.baseUrl + "/api/my/account/grants?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (consentType === null)
            throw new Error("The parameter 'consentType' cannot be null.");
        else if (consentType !== undefined)
            url_ += "ConsentType=" + encodeURIComponent("" + consentType) + "&";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConsents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConsents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserConsentInfoResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserConsentInfoResultSet>;
        }));
    }

    protected processGetConsents(response: HttpResponseBase): Observable<UserConsentInfoResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserConsentInfoResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates the max devices count.
     * @return No Content
     */
    updateMaxDevicesCount(body: UpdateMaxDevicesCountRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/my/account/max-devices-count";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMaxDevicesCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMaxDevicesCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateMaxDevicesCount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Changes the password for the current user, but requires the old password to be present.
     * @return No Content
     */
    updatePassword(body: ChangePasswordRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/my/account/password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates the password expiration policy.
     * @return No Content
     */
    updatePasswordExpirationPolicy(body: UpdatePasswordExpirationPolicyRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/my/account/password-expiration-policy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePasswordExpirationPolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePasswordExpirationPolicy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePasswordExpirationPolicy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Requests a phone number change for the current user.
     * @return No Content
     */
    updatePhoneNumber(body: UpdateUserPhoneNumberRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/my/account/phone-number";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePhoneNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePhoneNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdatePhoneNumber(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Confirms the phone number of the user, using the OTP token.
     * @return No Content
     */
    confirmPhoneNumber(body: ConfirmPhoneNumberRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/my/account/phone-number/confirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPhoneNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPhoneNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConfirmPhoneNumber(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create or update profile picture of the current user.
     * @param file (optional) File data
     * @param scale (optional) Zoom level. Defaults to 1.0
     * @param translateX (optional) offset X axis. Defaults to 0.
     * @param translateY (optional) offset Y axis. Defaults to 0
     * @param viewPort (optional) The side size of the viewport square used to crop the image source. 
    This is used as a reference for converting the Indice.Features.Identity.Server.Manager.Models.ImageUploadRequest.TranslateX and Indice.Features.Identity.Server.Manager.Models.ImageUploadRequest.TranslateY to the internal crop sqare the will be used as the final size of the picture.
    If left empty it is asumed as if it is the same as the size of the internal crop square.
     * @return No Content
     */
    saveMyPicture(file?: FileParameter | undefined, scale?: number | null | undefined, translateX?: number | null | undefined, translateY?: number | null | undefined, viewPort?: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/my/account/picture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (scale !== null && scale !== undefined)
            content_.append("scale", scale.toString());
        if (translateX !== null && translateX !== undefined)
            content_.append("translateX", translateX.toString());
        if (translateY !== null && translateY !== undefined)
            content_.append("translateY", translateY.toString());
        if (viewPort !== null && viewPort !== undefined)
            content_.append("viewPort", viewPort.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveMyPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveMyPicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveMyPicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Clear profile picture from the current user.
     * @return No Content
     */
    clearMyPicture(): Observable<void> {
        let url_ = this.baseUrl + "/api/my/account/picture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearMyPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearMyPicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearMyPicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get my profile picture.
     * @param size (optional) 
     * @param d (optional) 
     */
    getMyPicture(size?: number | undefined, d?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/my/account/picture?";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (d === null)
            throw new Error("The parameter 'd' cannot be null.");
        else if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyPicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetMyPicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get my profile picture.
     * @param size (optional) 
     * @param d (optional) 
     */
    getMyPictureFormat(format: string, size?: number | undefined, d?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/my/account/picture.{format}?";
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined.");
        url_ = url_.replace("{format}", encodeURIComponent("" + format));
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (d === null)
            throw new Error("The parameter 'd' cannot be null.");
        else if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyPictureFormat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyPictureFormat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetMyPictureFormat(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get my profile picture.
     * @param d (optional) 
     */
    getMyPictureSize(size: number, d?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/my/account/picture/{size}?";
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined.");
        url_ = url_.replace("{size}", encodeURIComponent("" + size));
        if (d === null)
            throw new Error("The parameter 'd' cannot be null.");
        else if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyPictureSize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyPictureSize(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetMyPictureSize(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get my profile picture.
     * @param d (optional) 
     */
    getMyPictureSizeFormat(size: number, format: string, d?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/my/account/picture/{size}.{format}?";
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined.");
        url_ = url_.replace("{size}", encodeURIComponent("" + size));
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined.");
        url_ = url_.replace("{format}", encodeURIComponent("" + format));
        if (d === null)
            throw new Error("The parameter 'd' cannot be null.");
        else if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyPictureSizeFormat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyPictureSizeFormat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetMyPictureSizeFormat(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Changes the username for the current user.
     * @return No Content
     */
    updateUserName(body: UpdateUserNameRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/my/account/username";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserName(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Returns a list of registered user devices.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param isPushNotificationEnabled (optional) 
     * @param isTrusted (optional) 
     * @param blocked (optional) 
     * @param clientType (optional) 
     * @param isPendingTrustActivation (optional) 
     * @param isMfaSessionExpired (optional) 
     * @return OK
     */
    getDevices(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, isPushNotificationEnabled?: boolean | undefined, isTrusted?: boolean | undefined, blocked?: boolean | undefined, clientType?: string | undefined, isPendingTrustActivation?: boolean | undefined, isMfaSessionExpired?: boolean | undefined): Observable<DeviceInfoResultSet> {
        let url_ = this.baseUrl + "/api/my/devices?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (isPushNotificationEnabled === null)
            throw new Error("The parameter 'isPushNotificationEnabled' cannot be null.");
        else if (isPushNotificationEnabled !== undefined)
            url_ += "IsPushNotificationEnabled=" + encodeURIComponent("" + isPushNotificationEnabled) + "&";
        if (isTrusted === null)
            throw new Error("The parameter 'isTrusted' cannot be null.");
        else if (isTrusted !== undefined)
            url_ += "IsTrusted=" + encodeURIComponent("" + isTrusted) + "&";
        if (blocked === null)
            throw new Error("The parameter 'blocked' cannot be null.");
        else if (blocked !== undefined)
            url_ += "Blocked=" + encodeURIComponent("" + blocked) + "&";
        if (clientType === null)
            throw new Error("The parameter 'clientType' cannot be null.");
        else if (clientType !== undefined)
            url_ += "ClientType=" + encodeURIComponent("" + clientType) + "&";
        if (isPendingTrustActivation === null)
            throw new Error("The parameter 'isPendingTrustActivation' cannot be null.");
        else if (isPendingTrustActivation !== undefined)
            url_ += "IsPendingTrustActivation=" + encodeURIComponent("" + isPendingTrustActivation) + "&";
        if (isMfaSessionExpired === null)
            throw new Error("The parameter 'isMfaSessionExpired' cannot be null.");
        else if (isMfaSessionExpired !== undefined)
            url_ += "IsMfaSessionExpired=" + encodeURIComponent("" + isMfaSessionExpired) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDevices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeviceInfoResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeviceInfoResultSet>;
        }));
    }

    protected processGetDevices(response: HttpResponseBase): Observable<DeviceInfoResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceInfoResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Creates a new device and optionally registers for push notifications.
     * @return Created
     */
    createDevice(body: RegisterDeviceRequest): Observable<DeviceInfo> {
        let url_ = this.baseUrl + "/api/my/devices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDevice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeviceInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeviceInfo>;
        }));
    }

    protected processCreateDevice(response: HttpResponseBase): Observable<DeviceInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = DeviceInfo.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a device by it's unique id.
     * @return OK
     */
    getDeviceById(deviceId: string): Observable<DeviceInfo> {
        let url_ = this.baseUrl + "/api/my/devices/{deviceId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeviceInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeviceInfo>;
        }));
    }

    protected processGetDeviceById(response: HttpResponseBase): Observable<DeviceInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates a device.
     * @return No Content
     */
    updateDevice(deviceId: string, body: UpdateDeviceRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/my/devices/{deviceId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDevice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Deletes the device.
     * @return No Content
     */
    deleteDevice(deviceId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/my/devices/{deviceId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDevice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Starts the process of trusting a device.
     * @return No Content
     */
    trustDevice(deviceId: string, body: TrustDeviceRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/my/devices/{deviceId}/trust";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTrustDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTrustDevice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTrustDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Sets a device as untrusted.
     * @return No Content
     */
    untrustDevice(deviceId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/my/devices/{deviceId}/untrust";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUntrustDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUntrustDevice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUntrustDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the list of sign in logs for the current user.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @param applicationId (optional) 
     * @param signInType (optional) 
     * @return OK
     */
    getMySignInLogs(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, from?: Date | undefined, to?: Date | undefined, applicationId?: string | undefined, signInType?: string | undefined): Observable<SignInLogEntryResultSet> {
        let url_ = this.baseUrl + "/api/my/sign-in-logs?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === null)
            throw new Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (applicationId === null)
            throw new Error("The parameter 'applicationId' cannot be null.");
        else if (applicationId !== undefined)
            url_ += "ApplicationId=" + encodeURIComponent("" + applicationId) + "&";
        if (signInType === null)
            throw new Error("The parameter 'signInType' cannot be null.");
        else if (signInType !== undefined)
            url_ += "SignInType=" + encodeURIComponent("" + signInType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMySignInLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMySignInLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SignInLogEntryResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SignInLogEntryResultSet>;
        }));
    }

    protected processGetMySignInLogs(response: HttpResponseBase): Observable<SignInLogEntryResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SignInLogEntryResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Returns a list of IdentityResourceInfo objects containing the total number of identity resources in the database and the data filtered according to the provided ListOptions.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @return OK
     */
    getIdentityResources(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined): Observable<IdentityResourceInfoResultSet> {
        let url_ = this.baseUrl + "/api/resources/identity?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIdentityResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIdentityResources(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentityResourceInfoResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentityResourceInfoResultSet>;
        }));
    }

    protected processGetIdentityResources(response: HttpResponseBase): Observable<IdentityResourceInfoResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityResourceInfoResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets an identity resource by it's unique id.
     * @return OK
     */
    getIdentityResource(resourceId: number): Observable<IdentityResourceInfo> {
        let url_ = this.baseUrl + "/api/resources/identity/{resourceId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIdentityResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIdentityResource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentityResourceInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentityResourceInfo>;
        }));
    }

    protected processGetIdentityResource(response: HttpResponseBase): Observable<IdentityResourceInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityResourceInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Creates a new identity resource.
     * @return Created
     */
    createIdentityResource(body: CreateResourceRequest): Observable<IdentityResourceInfo> {
        let url_ = this.baseUrl + "/api/resources/identity/{resourceId}";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateIdentityResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateIdentityResource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdentityResourceInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdentityResourceInfo>;
        }));
    }

    protected processCreateIdentityResource(response: HttpResponseBase): Observable<IdentityResourceInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = IdentityResourceInfo.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates an identity resource.
     * @return No Content
     */
    updateIdentityResource(resourceId: number, body: UpdateIdentityResourceRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/resources/identity/{resourceId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIdentityResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIdentityResource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateIdentityResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permanently deletes an identity resource.
     * @return No Content
     */
    deleteIdentityResource(resourceId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/resources/identity/{resourceId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteIdentityResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteIdentityResource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteIdentityResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Adds claims to an identity resource.
     * @return No Content
     */
    addIdentityResourceClaims(resourceId: number, body: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/resources/identity/{resourceId}/claims";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddIdentityResourceClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddIdentityResourceClaims(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddIdentityResourceClaims(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Removes a specified claim from an identity resource.
     * @return No Content
     */
    deleteIdentityResourceClaim(resourceId: number, claim: string): Observable<void> {
        let url_ = this.baseUrl + "/api/resources/identity/{resourceId}/claims/{claim}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (claim === undefined || claim === null)
            throw new Error("The parameter 'claim' must be defined.");
        url_ = url_.replace("{claim}", encodeURIComponent("" + claim));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteIdentityResourceClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteIdentityResourceClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteIdentityResourceClaim(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Returns a list of ApiResourceInfo objects containing the total number of API resources in the database and the data filtered according to the provided ListOptions.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @return OK
     */
    getApiResources(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined): Observable<ApiResourceInfoResultSet> {
        let url_ = this.baseUrl + "/api/resources/protected?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiResources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiResources(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResourceInfoResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResourceInfoResultSet>;
        }));
    }

    protected processGetApiResources(response: HttpResponseBase): Observable<ApiResourceInfoResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResourceInfoResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Creates a new API resource.
     * @return Created
     */
    createApiResource(body: CreateResourceRequest): Observable<ApiResourceInfo> {
        let url_ = this.baseUrl + "/api/resources/protected";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateApiResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateApiResource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResourceInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResourceInfo>;
        }));
    }

    protected processCreateApiResource(response: HttpResponseBase): Observable<ApiResourceInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApiResourceInfo.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets an API resource by it's unique id.
     * @return OK
     */
    getApiResource(resourceId: number): Observable<ApiResourceInfo> {
        let url_ = this.baseUrl + "/api/resources/protected/{resourceId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiResource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResourceInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResourceInfo>;
        }));
    }

    protected processGetApiResource(response: HttpResponseBase): Observable<ApiResourceInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResourceInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates an API resource.
     * @return No Content
     */
    updateApiResource(resourceId: number, body: UpdateApiResourceRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/resources/protected/{resourceId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateApiResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateApiResource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateApiResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permanently deletes an API resource.
     * @return No Content
     */
    deleteApiResource(resourceId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/resources/protected/{resourceId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiResource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiResource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiResource(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Adds claims to an API resource.
     * @return No Content
     */
    addApiResourceClaims(resourceId: number, body: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/resources/protected/{resourceId}/claims";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddApiResourceClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddApiResourceClaims(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddApiResourceClaims(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Removes a specified claim from an API resource.
     * @return No Content
     */
    deleteApiResourceClaim(resourceId: number, claim: string): Observable<void> {
        let url_ = this.baseUrl + "/api/resources/protected/{resourceId}/claims/{claim}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (claim === undefined || claim === null)
            throw new Error("The parameter 'claim' must be defined.");
        url_ = url_.replace("{claim}", encodeURIComponent("" + claim));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiResourceClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiResourceClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiResourceClaim(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Adds a new scope to an existing API resource.
     * @return OK
     */
    addApiResourceScope(resourceId: number, body: CreateApiScopeRequest): Observable<ApiScopeInfo> {
        let url_ = this.baseUrl + "/api/resources/protected/{resourceId}/scopes";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddApiResourceScope(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddApiResourceScope(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiScopeInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiScopeInfo>;
        }));
    }

    protected processAddApiResourceScope(response: HttpResponseBase): Observable<ApiScopeInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiScopeInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates a specified scope of an API resource.
     * @return No Content
     */
    updateApiResourceScope(resourceId: number, scopeId: number, body: UpdateApiScopeRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/resources/protected/{resourceId}/scopes/{scopeId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (scopeId === undefined || scopeId === null)
            throw new Error("The parameter 'scopeId' must be defined.");
        url_ = url_.replace("{scopeId}", encodeURIComponent("" + scopeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateApiResourceScope(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateApiResourceScope(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateApiResourceScope(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Deletes a specified scope from an API resource.
     * @return No Content
     */
    deleteApiResourceScope(resourceId: number, scopeId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/resources/protected/{resourceId}/scopes/{scopeId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (scopeId === undefined || scopeId === null)
            throw new Error("The parameter 'scopeId' must be defined.");
        url_ = url_.replace("{scopeId}", encodeURIComponent("" + scopeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiResourceScope(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiResourceScope(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiResourceScope(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Adds claims to an API scope of a protected resource.
     * @return No Content
     */
    addApiResourceScopeClaims(resourceId: number, scopeId: number, body: string[]): Observable<void> {
        let url_ = this.baseUrl + "/api/resources/protected/{resourceId}/scopes/{scopeId}/claims";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (scopeId === undefined || scopeId === null)
            throw new Error("The parameter 'scopeId' must be defined.");
        url_ = url_.replace("{scopeId}", encodeURIComponent("" + scopeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddApiResourceScopeClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddApiResourceScopeClaims(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddApiResourceScopeClaims(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Deletes a claim from an API scope of a protected resource.
     * @return No Content
     */
    deleteApiResourceScopeClaim(resourceId: number, scopeId: number, claim: string): Observable<void> {
        let url_ = this.baseUrl + "/api/resources/protected/{resourceId}/scopes/{scopeId}/claims/{claim}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (scopeId === undefined || scopeId === null)
            throw new Error("The parameter 'scopeId' must be defined.");
        url_ = url_.replace("{scopeId}", encodeURIComponent("" + scopeId));
        if (claim === undefined || claim === null)
            throw new Error("The parameter 'claim' must be defined.");
        url_ = url_.replace("{claim}", encodeURIComponent("" + claim));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiResourceScopeClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiResourceScopeClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiResourceScopeClaim(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Adds a new scope to an existing API resource.
     * @return OK
     */
    addApiResourceSecret(resourceId: number, body: CreateSecretRequest): Observable<SecretInfo> {
        let url_ = this.baseUrl + "/api/resources/protected/{resourceId}/secrets";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddApiResourceSecret(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddApiResourceSecret(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecretInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecretInfo>;
        }));
    }

    protected processAddApiResourceSecret(response: HttpResponseBase): Observable<SecretInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecretInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Removes a specified claim from an API resource.
     * @return No Content
     */
    deleteApiResourceSecret(resourceId: number, secretId: number): Observable<void> {
        let url_ = this.baseUrl + "/api/resources/protected/{resourceId}/secrets/{secretId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (secretId === undefined || secretId === null)
            throw new Error("The parameter 'secretId' must be defined.");
        url_ = url_.replace("{secretId}", encodeURIComponent("" + secretId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteApiResourceSecret(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteApiResourceSecret(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteApiResourceSecret(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Returns a list of ApiResourceInfo objects containing the total number of API resources in the database and the data filtered according to the provided ListOptions.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @return OK
     */
    getApiScopes(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined): Observable<ApiScopeInfoResultSet> {
        let url_ = this.baseUrl + "/api/resources/protected/scopes?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetApiScopes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetApiScopes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiScopeInfoResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiScopeInfoResultSet>;
        }));
    }

    protected processGetApiScopes(response: HttpResponseBase): Observable<ApiScopeInfoResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiScopeInfoResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Returns a list of RoleInfo objects containing the total number of roles in the database and the data filtered according to the provided ListOptions.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @return OK
     */
    getRoles(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined): Observable<RoleInfoResultSet> {
        let url_ = this.baseUrl + "/api/roles?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleInfoResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleInfoResultSet>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleInfoResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleInfoResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Creates a new role.
     * @return Created
     */
    createRole(body: CreateRoleRequest): Observable<RoleInfo> {
        let url_ = this.baseUrl + "/api/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleInfo>;
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<RoleInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = RoleInfo.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a role by it's unique id.
     * @return OK
     */
    getRole(roleId: string): Observable<RoleInfo> {
        let url_ = this.baseUrl + "/api/roles/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleInfo>;
        }));
    }

    protected processGetRole(response: HttpResponseBase): Observable<RoleInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates an existing role.
     * @return OK
     */
    updateRole(roleId: string, body: UpdateRoleRequest): Observable<RoleInfo> {
        let url_ = this.baseUrl + "/api/roles/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleInfo>;
        }));
    }

    protected processUpdateRole(response: HttpResponseBase): Observable<RoleInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permanently deletes an existing role.
     * @return No Content
     */
    deleteRole(roleId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/roles/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets the list of sign in logs produced by the Identity system.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param subject (optional) 
     * @param sessionId (optional) 
     * @param markForReview (optional) 
     * @param succeeded (optional) 
     * @param actionName (optional) 
     * @param from (optional) 
     * @param to (optional) 
     * @param applicationId (optional) 
     * @param signInType (optional) 
     * @return OK
     */
    getSignInLogs(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, subject?: string | undefined, sessionId?: string | undefined, markForReview?: boolean | undefined, succeeded?: boolean | undefined, actionName?: string | undefined, from?: Date | undefined, to?: Date | undefined, applicationId?: string | undefined, signInType?: string | undefined): Observable<SignInLogEntryResultSet> {
        let url_ = this.baseUrl + "/api/sign-in-logs?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (subject === null)
            throw new Error("The parameter 'subject' cannot be null.");
        else if (subject !== undefined)
            url_ += "Subject=" + encodeURIComponent("" + subject) + "&";
        if (sessionId === null)
            throw new Error("The parameter 'sessionId' cannot be null.");
        else if (sessionId !== undefined)
            url_ += "SessionId=" + encodeURIComponent("" + sessionId) + "&";
        if (markForReview === null)
            throw new Error("The parameter 'markForReview' cannot be null.");
        else if (markForReview !== undefined)
            url_ += "MarkForReview=" + encodeURIComponent("" + markForReview) + "&";
        if (succeeded === null)
            throw new Error("The parameter 'succeeded' cannot be null.");
        else if (succeeded !== undefined)
            url_ += "Succeeded=" + encodeURIComponent("" + succeeded) + "&";
        if (actionName === null)
            throw new Error("The parameter 'actionName' cannot be null.");
        else if (actionName !== undefined)
            url_ += "ActionName=" + encodeURIComponent("" + actionName) + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "From=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === null)
            throw new Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "To=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (applicationId === null)
            throw new Error("The parameter 'applicationId' cannot be null.");
        else if (applicationId !== undefined)
            url_ += "ApplicationId=" + encodeURIComponent("" + applicationId) + "&";
        if (signInType === null)
            throw new Error("The parameter 'signInType' cannot be null.");
        else if (signInType !== undefined)
            url_ += "SignInType=" + encodeURIComponent("" + signInType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSignInLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSignInLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SignInLogEntryResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SignInLogEntryResultSet>;
        }));
    }

    protected processGetSignInLogs(response: HttpResponseBase): Observable<SignInLogEntryResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SignInLogEntryResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Patches the specified log entry by updating the properties given in the request.
     * @return No Content
     */
    patchSignInLog(rowId: string, body: SignInLogEntryRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/sign-in-logs/{rowId}";
        if (rowId === undefined || rowId === null)
            throw new Error("The parameter 'rowId' must be defined.");
        url_ = url_.replace("{rowId}", encodeURIComponent("" + rowId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatchSignInLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatchSignInLog(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPatchSignInLog(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Sends a new code via the selected channel.
     * @return No Content
     */
    send(body: TotpRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/totp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 405) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result405: any = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = ProblemDetails.fromJS(resultData405);
            return throwException("Method Not Allowed", status, _responseText, _headers, result405);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Verify the code received.
     * @return No Content
     */
    verify(body: TotpVerificationRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/totp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerify(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVerify(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Returns a list of UserInfo objects containing the total number of users in the database and the data filtered according to the provided ListOptions.
     * @param page (optional) 
     * @param size (optional) 
     * @param sort (optional) 
     * @param search (optional) 
     * @param claimType (optional) 
     * @param claimValue (optional) 
     * @param userId (optional) 
     * @param expandClaims (optional) 
     * @return OK
     */
    getUsers(page?: number | undefined, size?: number | undefined, sort?: string | undefined, search?: string | undefined, claimType?: string | undefined, claimValue?: string | undefined, userId?: string[] | undefined, expandClaims?: string[] | undefined): Observable<UserInfoResultSet> {
        let url_ = this.baseUrl + "/api/users?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (claimType === null)
            throw new Error("The parameter 'claimType' cannot be null.");
        else if (claimType !== undefined)
            url_ += "ClaimType=" + encodeURIComponent("" + claimType) + "&";
        if (claimValue === null)
            throw new Error("The parameter 'claimValue' cannot be null.");
        else if (claimValue !== undefined)
            url_ += "ClaimValue=" + encodeURIComponent("" + claimValue) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            userId && userId.forEach(item => { url_ += "UserId=" + encodeURIComponent("" + item) + "&"; });
        if (expandClaims === null)
            throw new Error("The parameter 'expandClaims' cannot be null.");
        else if (expandClaims !== undefined)
            expandClaims && expandClaims.forEach(item => { url_ += "expandClaims=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInfoResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInfoResultSet>;
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<UserInfoResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInfoResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Creates a new user.
     * @return Created
     */
    createUser(body: CreateUserRequest): Observable<SingleUserInfo> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SingleUserInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SingleUserInfo>;
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<SingleUserInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SingleUserInfo.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a user by it's unique id.
     * @return OK
     */
    getUser(userId: string): Observable<SingleUserInfo> {
        let url_ = this.baseUrl + "/api/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SingleUserInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SingleUserInfo>;
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<SingleUserInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SingleUserInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates an existing user.
     * @return OK
     */
    updateUser(userId: string, body: UpdateUserRequest): Observable<SingleUserInfo> {
        let url_ = this.baseUrl + "/api/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SingleUserInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SingleUserInfo>;
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<SingleUserInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SingleUserInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permanently deletes an existing user.
     * @return No Content
     */
    deleteUser(userId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a list of the applications the user has given consent to or currently has IdentityServer side tokens for.
     * @return OK
     */
    getUserApplications(userId: string): Observable<UserClientInfoResultSet> {
        let url_ = this.baseUrl + "/api/users/{userId}/applications";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserApplications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserApplications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserClientInfoResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserClientInfoResultSet>;
        }));
    }

    protected processGetUserApplications(response: HttpResponseBase): Observable<UserClientInfoResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserClientInfoResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Toggles user block state.
     * @return No Content
     */
    setUserBlock(userId: string, body: SetUserBlockRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{userId}/block";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetUserBlock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetUserBlock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetUserBlock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Adds a claim for the specified user.
     * @return Created
     */
    addUserClaim(userId: string, body: CreateClaimRequest): Observable<ClaimInfo> {
        let url_ = this.baseUrl + "/api/users/{userId}/claims";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimInfo>;
        }));
    }

    protected processAddUserClaim(response: HttpResponseBase): Observable<ClaimInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ClaimInfo.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a specified claim for a given user.
     * @return OK
     */
    getUserClaim(userId: string, claimId: number): Observable<BasicClaimInfo> {
        let url_ = this.baseUrl + "/api/users/{userId}/claims/{claimId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (claimId === undefined || claimId === null)
            throw new Error("The parameter 'claimId' must be defined.");
        url_ = url_.replace("{claimId}", encodeURIComponent("" + claimId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BasicClaimInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BasicClaimInfo>;
        }));
    }

    protected processGetUserClaim(response: HttpResponseBase): Observable<BasicClaimInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BasicClaimInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Updates an existing user claim.
     * @return OK
     */
    updateUserClaim(userId: string, claimId: number, body: UpdateUserClaimRequest): Observable<ClaimInfo> {
        let url_ = this.baseUrl + "/api/users/{userId}/claims/{claimId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (claimId === undefined || claimId === null)
            throw new Error("The parameter 'claimId' must be defined.");
        url_ = url_.replace("{claimId}", encodeURIComponent("" + claimId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClaimInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClaimInfo>;
        }));
    }

    protected processUpdateUserClaim(response: HttpResponseBase): Observable<ClaimInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClaimInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permanently deletes a specified claim from a user.
     * @return No Content
     */
    deleteUserClaim(claimId: number, userId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{userId}/claims/{claimId}";
        if (claimId === undefined || claimId === null)
            throw new Error("The parameter 'claimId' must be defined.");
        url_ = url_.replace("{claimId}", encodeURIComponent("" + claimId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserClaim(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserClaim(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUserClaim(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a list of the devices of the specified user.
     * @return OK
     */
    getUserDevices(userId: string): Observable<DeviceInfoResultSet> {
        let url_ = this.baseUrl + "/api/users/{userId}/devices";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDevices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DeviceInfoResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DeviceInfoResultSet>;
        }));
    }

    protected processGetUserDevices(response: HttpResponseBase): Observable<DeviceInfoResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceInfoResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Resends the confirmation email for a given user.
     * @return No Content
     */
    resendConfirmationEmail(userId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{userId}/email/confirmation";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResendConfirmationEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResendConfirmationEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResendConfirmationEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Gets a list of the external login providers for the specified user.
     * @return OK
     */
    getUserExternalLogins(userId: string): Observable<UserLoginProviderInfoResultSet> {
        let url_ = this.baseUrl + "/api/users/{userId}/external-logins";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserExternalLogins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserExternalLogins(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserLoginProviderInfoResultSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserLoginProviderInfoResultSet>;
        }));
    }

    protected processGetUserExternalLogins(response: HttpResponseBase): Observable<UserLoginProviderInfoResultSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserLoginProviderInfoResultSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Permanently deletes a specified login provider association from a user.
     * @return No Content
     */
    deleteUserExternalLogin(userId: string, provider: string): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{userId}/external-logins/{provider}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (provider === undefined || provider === null)
            throw new Error("The parameter 'provider' must be defined.");
        url_ = url_.replace("{provider}", encodeURIComponent("" + provider));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserExternalLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserExternalLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUserExternalLogin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create or update profile picture of the given user.
     * @param file (optional) File data
     * @param scale (optional) Zoom level. Defaults to 1.0
     * @param translateX (optional) offset X axis. Defaults to 0.
     * @param translateY (optional) offset Y axis. Defaults to 0
     * @param viewPort (optional) The side size of the viewport square used to crop the image source. 
    This is used as a reference for converting the Indice.Features.Identity.Server.Manager.Models.ImageUploadRequest.TranslateX and Indice.Features.Identity.Server.Manager.Models.ImageUploadRequest.TranslateY to the internal crop sqare the will be used as the final size of the picture.
    If left empty it is asumed as if it is the same as the size of the internal crop square.
     * @return No Content
     */
    saveUserPicture(userId: string, file?: FileParameter | undefined, scale?: number | null | undefined, translateX?: number | null | undefined, translateY?: number | null | undefined, viewPort?: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{userId}/picture";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (scale !== null && scale !== undefined)
            content_.append("scale", scale.toString());
        if (translateX !== null && translateX !== undefined)
            content_.append("translateX", translateX.toString());
        if (translateY !== null && translateY !== undefined)
            content_.append("translateY", translateY.toString());
        if (viewPort !== null && viewPort !== undefined)
            content_.append("viewPort", viewPort.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserPicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSaveUserPicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Clear profile picture from the given user.
     * @return No Content
     */
    clearUserPicture(userId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{userId}/picture";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearUserPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearUserPicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearUserPicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get user's profile picture.
     * @param size (optional) 
     * @param d (optional) 
     */
    getUserPicture(userId: string, size?: number | undefined, d?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{userId}/picture?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (d === null)
            throw new Error("The parameter 'd' cannot be null.");
        else if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetUserPicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get user's profile picture.
     * @param size (optional) 
     * @param d (optional) 
     */
    getUserPictureFormat(userId: string, format: string, size?: number | undefined, d?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{userId}/picture.{format}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined.");
        url_ = url_.replace("{format}", encodeURIComponent("" + format));
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (d === null)
            throw new Error("The parameter 'd' cannot be null.");
        else if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPictureFormat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPictureFormat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetUserPictureFormat(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get user's profile picture.
     * @param d (optional) 
     */
    getUserPictureSize(userId: string, size: number, d?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{userId}/picture/{size}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined.");
        url_ = url_.replace("{size}", encodeURIComponent("" + size));
        if (d === null)
            throw new Error("The parameter 'd' cannot be null.");
        else if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPictureSize(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPictureSize(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetUserPictureSize(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Get user's profile picture.
     * @param d (optional) 
     */
    getUserPictureSizeFormat(userId: string, size: number, format: string, d?: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{userId}/picture/{size}.{format}?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined.");
        url_ = url_.replace("{size}", encodeURIComponent("" + size));
        if (format === undefined || format === null)
            throw new Error("The parameter 'format' must be defined.");
        url_ = url_.replace("{format}", encodeURIComponent("" + format));
        if (d === null)
            throw new Error("The parameter 'd' cannot be null.");
        else if (d !== undefined)
            url_ += "d=" + encodeURIComponent("" + d) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPictureSizeFormat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPictureSizeFormat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetUserPictureSizeFormat(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Adds a new role to the specified user.
     * @return No Content
     */
    addUserRole(userId: string, roleId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{userId}/roles/{roleId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddUserRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Removes an existing role from the specified user.
     * @return No Content
     */
    deleteUserRole(userId: string, roleId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{userId}/roles/{roleId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUserRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Sets the password for a given user.
     * @return No Content
     */
    setPassword(userId: string, body: SetPasswordRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{userId}/set-password";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Unlocks a user.
     * @return No Content
     */
    unlockUser(userId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/users/{userId}/unlock";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("Not Found", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export enum AccessTokenType {
    Jwt = "Jwt",
    Reference = "Reference",
}

/** Models an API resource for the application. */
export class ApiResourceInfo implements IApiResourceInfo {
    /** Unique identifier for the API resource. */
    id?: number;
    /** The name of the resource. */
    name?: string | undefined;
    /** The display name of the resource. */
    displayName?: string | undefined;
    /** The description of the resource. */
    description?: string | undefined;
    /** Determines whether this resource is enabled or not. */
    enabled?: boolean;
    /** Determines whether this resource is editable or not. */
    nonEditable?: boolean;
    /** List of associated claims that should be included when this resource is requested. */
    allowedClaims?: string[] | undefined;
    /** List of all scopes included in the resource. At least one scope must be included. */
    scopes?: ApiScopeInfo[] | undefined;
    secrets?: ApiSecretInfo[] | undefined;

    constructor(data?: IApiResourceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.enabled = _data["enabled"];
            this.nonEditable = _data["nonEditable"];
            if (Array.isArray(_data["allowedClaims"])) {
                this.allowedClaims = [] as any;
                for (let item of _data["allowedClaims"])
                    this.allowedClaims!.push(item);
            }
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(ApiScopeInfo.fromJS(item));
            }
            if (Array.isArray(_data["secrets"])) {
                this.secrets = [] as any;
                for (let item of _data["secrets"])
                    this.secrets!.push(ApiSecretInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResourceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResourceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["enabled"] = this.enabled;
        data["nonEditable"] = this.nonEditable;
        if (Array.isArray(this.allowedClaims)) {
            data["allowedClaims"] = [];
            for (let item of this.allowedClaims)
                data["allowedClaims"].push(item);
        }
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item.toJSON());
        }
        if (Array.isArray(this.secrets)) {
            data["secrets"] = [];
            for (let item of this.secrets)
                data["secrets"].push(item.toJSON());
        }
        return data;
    }
}

/** Models an API resource for the application. */
export interface IApiResourceInfo {
    /** Unique identifier for the API resource. */
    id?: number;
    /** The name of the resource. */
    name?: string | undefined;
    /** The display name of the resource. */
    displayName?: string | undefined;
    /** The description of the resource. */
    description?: string | undefined;
    /** Determines whether this resource is enabled or not. */
    enabled?: boolean;
    /** Determines whether this resource is editable or not. */
    nonEditable?: boolean;
    /** List of associated claims that should be included when this resource is requested. */
    allowedClaims?: string[] | undefined;
    /** List of all scopes included in the resource. At least one scope must be included. */
    scopes?: ApiScopeInfo[] | undefined;
    secrets?: ApiSecretInfo[] | undefined;
}

export class ApiResourceInfoResultSet implements IApiResourceInfoResultSet {
    count?: number;
    items?: ApiResourceInfo[] | undefined;

    constructor(data?: IApiResourceInfoResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApiResourceInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResourceInfoResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResourceInfoResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiResourceInfoResultSet {
    count?: number;
    items?: ApiResourceInfo[] | undefined;
}

/** Models access to an API resource. */
export class ApiScopeInfo implements IApiScopeInfo {
    /** Unique identifier for the scope. */
    id?: number;
    /** The name of the scope. */
    name?: string | undefined;
    /** The display name of the scope. */
    displayName?: string | undefined;
    /** The description of the resource. */
    description?: string | undefined;
    /** Determines whether this scope should be displayed emphasized or not. */
    emphasize?: boolean | undefined;
    /** Determines whether this scope should be displayed in the discovery document or not. */
    showInDiscoveryDocument?: boolean | undefined;
    /** Translations. */
    translations?: { [key: string]: ApiScopeTranslation; } | undefined;
    /** List of associated user claims that should be included when a resource is requested. */
    userClaims?: string[] | undefined;

    constructor(data?: IApiScopeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.emphasize = _data["emphasize"];
            this.showInDiscoveryDocument = _data["showInDiscoveryDocument"];
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? ApiScopeTranslation.fromJS(_data["translations"][key]) : new ApiScopeTranslation();
                }
            }
            if (Array.isArray(_data["userClaims"])) {
                this.userClaims = [] as any;
                for (let item of _data["userClaims"])
                    this.userClaims!.push(item);
            }
        }
    }

    static fromJS(data: any): ApiScopeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ApiScopeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["emphasize"] = this.emphasize;
        data["showInDiscoveryDocument"] = this.showInDiscoveryDocument;
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.userClaims)) {
            data["userClaims"] = [];
            for (let item of this.userClaims)
                data["userClaims"].push(item);
        }
        return data;
    }
}

/** Models access to an API resource. */
export interface IApiScopeInfo {
    /** Unique identifier for the scope. */
    id?: number;
    /** The name of the scope. */
    name?: string | undefined;
    /** The display name of the scope. */
    displayName?: string | undefined;
    /** The description of the resource. */
    description?: string | undefined;
    /** Determines whether this scope should be displayed emphasized or not. */
    emphasize?: boolean | undefined;
    /** Determines whether this scope should be displayed in the discovery document or not. */
    showInDiscoveryDocument?: boolean | undefined;
    /** Translations. */
    translations?: { [key: string]: ApiScopeTranslation; } | undefined;
    /** List of associated user claims that should be included when a resource is requested. */
    userClaims?: string[] | undefined;
}

export class ApiScopeInfoResultSet implements IApiScopeInfoResultSet {
    count?: number;
    items?: ApiScopeInfo[] | undefined;

    constructor(data?: IApiScopeInfoResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApiScopeInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiScopeInfoResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new ApiScopeInfoResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiScopeInfoResultSet {
    count?: number;
    items?: ApiScopeInfo[] | undefined;
}

/** Translation object for type Indice.Features.Identity.Server.Manager.Models.ApiScopeInfo. */
export class ApiScopeTranslation implements IApiScopeTranslation {
    /** The display name of the scope. */
    displayName?: string | undefined;
    /** The description of the resource. */
    description?: string | undefined;

    constructor(data?: IApiScopeTranslation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ApiScopeTranslation {
        data = typeof data === 'object' ? data : {};
        let result = new ApiScopeTranslation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }
}

/** Translation object for type Indice.Features.Identity.Server.Manager.Models.ApiScopeInfo. */
export interface IApiScopeTranslation {
    /** The display name of the scope. */
    displayName?: string | undefined;
    /** The description of the resource. */
    description?: string | undefined;
}

/** Models an API secret used for the introspection endpoint. The API can authenticate with introspection using the API name and secret. */
export class ApiSecretInfo implements IApiSecretInfo {
    /** Description of client secret. */
    description?: string | undefined;
    /** The value of client secret. */
    value?: string | undefined;
    /** Optional expiration of client secret. */
    expiration?: Date | undefined;
    /** The type of client secret. */
    type?: string | undefined;
    /** The identifier for the API secret. */
    id?: number;
    /** Indicates if the secret is expired. */
    readonly isExpired?: boolean;

    constructor(data?: IApiSecretInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.value = _data["value"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.id = _data["id"];
            (<any>this).isExpired = _data["isExpired"];
        }
    }

    static fromJS(data: any): ApiSecretInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ApiSecretInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["value"] = this.value;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["id"] = this.id;
        data["isExpired"] = this.isExpired;
        return data;
    }
}

/** Models an API secret used for the introspection endpoint. The API can authenticate with introspection using the API name and secret. */
export interface IApiSecretInfo {
    /** Description of client secret. */
    description?: string | undefined;
    /** The value of client secret. */
    value?: string | undefined;
    /** Optional expiration of client secret. */
    expiration?: Date | undefined;
    /** The type of client secret. */
    type?: string | undefined;
    /** The identifier for the API secret. */
    id?: number;
    /** Indicates if the secret is expired. */
    isExpired?: boolean;
}

/** Models an application setting persisted in the database. */
export class AppSettingInfo implements IAppSettingInfo {
    /** The key of application setting. */
    key?: string | undefined;
    /** The value of application setting. */
    value?: string | undefined;

    constructor(data?: IAppSettingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AppSettingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

/** Models an application setting persisted in the database. */
export interface IAppSettingInfo {
    /** The key of application setting. */
    key?: string | undefined;
    /** The value of application setting. */
    value?: string | undefined;
}

export class AppSettingInfoResultSet implements IAppSettingInfoResultSet {
    count?: number;
    items?: AppSettingInfo[] | undefined;

    constructor(data?: IAppSettingInfoResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AppSettingInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingInfoResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingInfoResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAppSettingInfoResultSet {
    count?: number;
    items?: AppSettingInfo[] | undefined;
}

/** Models a claim. */
export class BasicClaimInfo implements IBasicClaimInfo {
    /** The type of the claim. */
    type?: string | undefined;
    /** The value of the claim. */
    value?: string | undefined;

    constructor(data?: IBasicClaimInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): BasicClaimInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BasicClaimInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

/** Models a claim. */
export interface IBasicClaimInfo {
    /** The type of the claim. */
    type?: string | undefined;
    /** The value of the claim. */
    value?: string | undefined;
}

/** Describes a blog post item. */
export class BlogItemInfo implements IBlogItemInfo {
    /** Title of the post. */
    title?: string | undefined;
    /** Original link to the post. */
    link?: string | undefined;
    /** The datetime that the post was published. */
    publishDate?: Date | undefined;
    /** A small description for the post. */
    description?: string | undefined;

    constructor(data?: IBlogItemInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.link = _data["link"];
            this.publishDate = _data["publishDate"] ? new Date(_data["publishDate"].toString()) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): BlogItemInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BlogItemInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["link"] = this.link;
        data["publishDate"] = this.publishDate ? this.publishDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        return data;
    }
}

/** Describes a blog post item. */
export interface IBlogItemInfo {
    /** Title of the post. */
    title?: string | undefined;
    /** Original link to the post. */
    link?: string | undefined;
    /** The datetime that the post was published. */
    publishDate?: Date | undefined;
    /** A small description for the post. */
    description?: string | undefined;
}

export class BlogItemInfoResultSet implements IBlogItemInfoResultSet {
    count?: number;
    items?: BlogItemInfo[] | undefined;

    constructor(data?: IBlogItemInfoResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BlogItemInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BlogItemInfoResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new BlogItemInfoResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBlogItemInfoResultSet {
    count?: number;
    items?: BlogItemInfo[] | undefined;
}

export class CallingCode implements ICallingCode {
    code?: string | undefined;
    readonly displayName?: string | undefined;
    readonly twoLetterCountryCode?: string | undefined;
    countryName?: string | undefined;
    pattern?: string | undefined;

    constructor(data?: ICallingCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            (<any>this).displayName = _data["displayName"];
            (<any>this).twoLetterCountryCode = _data["twoLetterCountryCode"];
            this.countryName = _data["countryName"];
            this.pattern = _data["pattern"];
        }
    }

    static fromJS(data: any): CallingCode {
        data = typeof data === 'object' ? data : {};
        let result = new CallingCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["twoLetterCountryCode"] = this.twoLetterCountryCode;
        data["countryName"] = this.countryName;
        data["pattern"] = this.pattern;
        return data;
    }
}

export interface ICallingCode {
    code?: string | undefined;
    displayName?: string | undefined;
    twoLetterCountryCode?: string | undefined;
    countryName?: string | undefined;
    pattern?: string | undefined;
}

/** Certificate upload request with optional password. */
export class CertificateUploadRequest implements ICertificateUploadRequest {
    /** File data */
    file!: string;
    /** Optional password in case this is a application/x-pkcs12 */
    password?: string | undefined;

    constructor(data?: ICertificateUploadRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file = _data["file"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CertificateUploadRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateUploadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file;
        data["password"] = this.password;
        return data;
    }
}

/** Certificate upload request with optional password. */
export interface ICertificateUploadRequest {
    /** File data */
    file: string;
    /** Optional password in case this is a application/x-pkcs12 */
    password?: string | undefined;
}

/** Models a password change request by the user. */
export class ChangePasswordRequest implements IChangePasswordRequest {
    /** The current password of the user. */
    oldPassword!: string;
    /** The new password of the user. */
    newPassword!: string;
    /** The new password confirmation. */
    newPasswordConfirmation?: string | undefined;

    constructor(data?: IChangePasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
            this.newPasswordConfirmation = _data["newPasswordConfirmation"];
        }
    }

    static fromJS(data: any): ChangePasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        data["newPasswordConfirmation"] = this.newPasswordConfirmation;
        return data;
    }
}

/** Models a password change request by the user. */
export interface IChangePasswordRequest {
    /** The current password of the user. */
    oldPassword: string;
    /** The new password of the user. */
    newPassword: string;
    /** The new password confirmation. */
    newPasswordConfirmation?: string | undefined;
}

/** Models a claim. */
export class ClaimInfo implements IClaimInfo {
    /** The type of the claim. */
    type?: string | undefined;
    /** The value of the claim. */
    value?: string | undefined;
    /** The id of the user claim entry. */
    id?: number;
    /** The display name of the claim. */
    displayName?: string | undefined;

    constructor(data?: IClaimInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"];
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): ClaimInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

/** Models a claim. */
export interface IClaimInfo {
    /** The type of the claim. */
    type?: string | undefined;
    /** The value of the claim. */
    value?: string | undefined;
    /** The id of the user claim entry. */
    id?: number;
    /** The display name of the claim. */
    displayName?: string | undefined;
}

export class ClaimInfoResultSet implements IClaimInfoResultSet {
    count?: number;
    items?: ClaimInfo[] | undefined;

    constructor(data?: IClaimInfoResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClaimInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClaimInfoResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimInfoResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClaimInfoResultSet {
    count?: number;
    items?: ClaimInfo[] | undefined;
}

/** Models an application claim type. */
export class ClaimTypeInfo implements IClaimTypeInfo {
    /** The unique id of the claim. */
    id?: string | undefined;
    /** The name. */
    name?: string | undefined;
    /** The name used for display purposes. */
    displayName?: string | undefined;
    /** A description. */
    description?: string | undefined;
    /** Determines whether this claim is required to create new users. */
    required?: boolean;
    /** Determines whether this is a system reserved claim. */
    reserved?: boolean;
    /** Determines whether this claim will be editable by a user if exposed through a public API. */
    userEditable?: boolean;
    /** A regex rule that constraints the values of the claim. */
    rule?: string | undefined;
    valueType?: ClaimValueType;

    constructor(data?: IClaimTypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.required = _data["required"];
            this.reserved = _data["reserved"];
            this.userEditable = _data["userEditable"];
            this.rule = _data["rule"];
            this.valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): ClaimTypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimTypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["required"] = this.required;
        data["reserved"] = this.reserved;
        data["userEditable"] = this.userEditable;
        data["rule"] = this.rule;
        data["valueType"] = this.valueType;
        return data;
    }
}

/** Models an application claim type. */
export interface IClaimTypeInfo {
    /** The unique id of the claim. */
    id?: string | undefined;
    /** The name. */
    name?: string | undefined;
    /** The name used for display purposes. */
    displayName?: string | undefined;
    /** A description. */
    description?: string | undefined;
    /** Determines whether this claim is required to create new users. */
    required?: boolean;
    /** Determines whether this is a system reserved claim. */
    reserved?: boolean;
    /** Determines whether this claim will be editable by a user if exposed through a public API. */
    userEditable?: boolean;
    /** A regex rule that constraints the values of the claim. */
    rule?: string | undefined;
    valueType?: ClaimValueType;
}

export class ClaimTypeInfoResultSet implements IClaimTypeInfoResultSet {
    count?: number;
    items?: ClaimTypeInfo[] | undefined;

    constructor(data?: IClaimTypeInfoResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClaimTypeInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClaimTypeInfoResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimTypeInfoResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClaimTypeInfoResultSet {
    count?: number;
    items?: ClaimTypeInfo[] | undefined;
}

export enum ClaimValueType {
    Boolean = "Boolean",
    DateTime = "DateTime",
    Int = "Int",
    String = "String",
}

/** Models a system client. */
export class ClientInfo implements IClientInfo {
    /** The unique identifier for this application. */
    clientId?: string | undefined;
    /** Application name that will be seen on consent screens. */
    clientName?: string | undefined;
    /** Application description. */
    description?: string | undefined;
    /** Determines whether this application is enabled or not. */
    enabled?: boolean | undefined;
    /** Specifies whether a consent screen is required. */
    requireConsent?: boolean | undefined;
    /** Specifies whether consent screen is remembered after having been given. */
    allowRememberConsent?: boolean | undefined;
    /** Application logo that will be seen on consent screens. */
    logoUri?: string | undefined;
    /** Application URL that will be seen on consent screens. */
    clientUri?: string | undefined;
    /** Specifies whether the client can be edited or not. */
    nonEditable?: boolean;

    constructor(data?: IClientInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.description = _data["description"];
            this.enabled = _data["enabled"];
            this.requireConsent = _data["requireConsent"];
            this.allowRememberConsent = _data["allowRememberConsent"];
            this.logoUri = _data["logoUri"];
            this.clientUri = _data["clientUri"];
            this.nonEditable = _data["nonEditable"];
        }
    }

    static fromJS(data: any): ClientInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ClientInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["description"] = this.description;
        data["enabled"] = this.enabled;
        data["requireConsent"] = this.requireConsent;
        data["allowRememberConsent"] = this.allowRememberConsent;
        data["logoUri"] = this.logoUri;
        data["clientUri"] = this.clientUri;
        data["nonEditable"] = this.nonEditable;
        return data;
    }
}

/** Models a system client. */
export interface IClientInfo {
    /** The unique identifier for this application. */
    clientId?: string | undefined;
    /** Application name that will be seen on consent screens. */
    clientName?: string | undefined;
    /** Application description. */
    description?: string | undefined;
    /** Determines whether this application is enabled or not. */
    enabled?: boolean | undefined;
    /** Specifies whether a consent screen is required. */
    requireConsent?: boolean | undefined;
    /** Specifies whether consent screen is remembered after having been given. */
    allowRememberConsent?: boolean | undefined;
    /** Application logo that will be seen on consent screens. */
    logoUri?: string | undefined;
    /** Application URL that will be seen on consent screens. */
    clientUri?: string | undefined;
    /** Specifies whether the client can be edited or not. */
    nonEditable?: boolean;
}

export class ClientInfoResultSet implements IClientInfoResultSet {
    count?: number;
    items?: ClientInfo[] | undefined;

    constructor(data?: IClientInfoResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClientInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientInfoResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new ClientInfoResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientInfoResultSet {
    count?: number;
    items?: ClientInfo[] | undefined;
}

/** Models an Client secret used in flows that require this. */
export class ClientSecretInfo implements IClientSecretInfo {
    /** Description of client secret. */
    description?: string | undefined;
    /** The value of client secret. */
    value?: string | undefined;
    /** Optional expiration of client secret. */
    expiration?: Date | undefined;
    /** The type of client secret. */
    type?: string | undefined;
    /** The identifier for the API secret. */
    id?: number;
    /** Indicates if the secret is expired. */
    readonly isExpired?: boolean;

    constructor(data?: IClientSecretInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.value = _data["value"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.id = _data["id"];
            (<any>this).isExpired = _data["isExpired"];
        }
    }

    static fromJS(data: any): ClientSecretInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSecretInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["value"] = this.value;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["id"] = this.id;
        data["isExpired"] = this.isExpired;
        return data;
    }
}

/** Models an Client secret used in flows that require this. */
export interface IClientSecretInfo {
    /** Description of client secret. */
    description?: string | undefined;
    /** The value of client secret. */
    value?: string | undefined;
    /** Optional expiration of client secret. */
    expiration?: Date | undefined;
    /** The type of client secret. */
    type?: string | undefined;
    /** The identifier for the API secret. */
    id?: number;
    /** Indicates if the secret is expired. */
    isExpired?: boolean;
}

/** Identity Server UI configuration for the specified client. */
export class ClientThemeConfigRequest implements IClientThemeConfigRequest {
    /** The URL of the background image. */
    backgroundImage?: string | undefined;
    /** The background color. */
    accentColor?: string | undefined;
    /** A primary color. */
    primaryColor?: string | undefined;
    /** A secondary color. */
    secondaryColor?: string | undefined;

    constructor(data?: IClientThemeConfigRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.backgroundImage = _data["backgroundImage"];
            this.accentColor = _data["accentColor"];
            this.primaryColor = _data["primaryColor"];
            this.secondaryColor = _data["secondaryColor"];
        }
    }

    static fromJS(data: any): ClientThemeConfigRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ClientThemeConfigRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["backgroundImage"] = this.backgroundImage;
        data["accentColor"] = this.accentColor;
        data["primaryColor"] = this.primaryColor;
        data["secondaryColor"] = this.secondaryColor;
        return data;
    }
}

/** Identity Server UI configuration for the specified client. */
export interface IClientThemeConfigRequest {
    /** The URL of the background image. */
    backgroundImage?: string | undefined;
    /** The background color. */
    accentColor?: string | undefined;
    /** A primary color. */
    primaryColor?: string | undefined;
    /** A secondary color. */
    secondaryColor?: string | undefined;
}

/** Identity Server UI configuration for the specified client. */
export class ClientThemeConfigResponse implements IClientThemeConfigResponse {
    /** JSON schema describing the properties to configure for the UI. */
    schema?: any | undefined;
    data?: DefaultClientThemeConfig;

    constructor(data?: IClientThemeConfigResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.schema = _data["schema"];
            this.data = _data["data"] ? DefaultClientThemeConfig.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientThemeConfigResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClientThemeConfigResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["schema"] = this.schema;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

/** Identity Server UI configuration for the specified client. */
export interface IClientThemeConfigResponse {
    /** JSON schema describing the properties to configure for the UI. */
    schema?: any | undefined;
    data?: DefaultClientThemeConfig;
}

/** Translation object for type Indice.Features.Identity.Server.Manager.Models.SingleClientInfo. */
export class ClientTranslation implements IClientTranslation {
    /** The name of the client. */
    clientName?: string | undefined;
    /** The description of the client. */
    description?: string | undefined;

    constructor(data?: IClientTranslation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientName = _data["clientName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ClientTranslation {
        data = typeof data === 'object' ? data : {};
        let result = new ClientTranslation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientName"] = this.clientName;
        data["description"] = this.description;
        return data;
    }
}

/** Translation object for type Indice.Features.Identity.Server.Manager.Models.SingleClientInfo. */
export interface IClientTranslation {
    /** The name of the client. */
    clientName?: string | undefined;
    /** The description of the client. */
    description?: string | undefined;
}

/** Models an OAuth client type. */
export enum ClientType {
    SPA = "SPA",
    WebApp = "WebApp",
    Native = "Native",
    Machine = "Machine",
    Device = "Device",
    SPALegacy = "SPALegacy",
}

/** Models the request of a user for email confirmation. */
export class ConfirmEmailRequest implements IConfirmEmailRequest {
    /** The token. */
    token!: string;

    constructor(data?: IConfirmEmailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ConfirmEmailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmEmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

/** Models the request of a user for email confirmation. */
export interface IConfirmEmailRequest {
    /** The token. */
    token: string;
}

/** Models the request of a user for phone number confirmation. */
export class ConfirmPhoneNumberRequest implements IConfirmPhoneNumberRequest {
    /** The OTP token. */
    token!: string;

    constructor(data?: IConfirmPhoneNumberRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ConfirmPhoneNumberRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmPhoneNumberRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

/** Models the request of a user for phone number confirmation. */
export interface IConfirmPhoneNumberRequest {
    /** The OTP token. */
    token: string;
}

/** Models an API scope that will be created on the server. */
export class CreateApiScopeRequest implements ICreateApiScopeRequest {
    /** Display name of the resource. */
    displayName?: string | undefined;
    /** Description of the resource. */
    description?: string | undefined;
    /** The unique name of the resource. */
    name?: string | undefined;
    /** List of allowed signing algorithms for access token. If empty, will use the server default signing algorithm. */
    allowedAccessTokenSigningAlgorithms?: string | undefined;
    /** List of associated user claims that should be included when this resource is requested. */
    userClaims?: string[] | undefined;
    /** Translations. */
    translations?: { [key: string]: ApiScopeTranslation; } | undefined;
    /** Determines whether this scope is required or not. */
    required?: boolean;
    /** Determines whether this scope should be displayed emphasized or not. */
    emphasize?: boolean;
    /** Determines whether this scope should be displayed in the discovery document or not. */
    showInDiscoveryDocument?: boolean;

    constructor(data?: ICreateApiScopeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.allowedAccessTokenSigningAlgorithms = _data["allowedAccessTokenSigningAlgorithms"];
            if (Array.isArray(_data["userClaims"])) {
                this.userClaims = [] as any;
                for (let item of _data["userClaims"])
                    this.userClaims!.push(item);
            }
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? ApiScopeTranslation.fromJS(_data["translations"][key]) : new ApiScopeTranslation();
                }
            }
            this.required = _data["required"];
            this.emphasize = _data["emphasize"];
            this.showInDiscoveryDocument = _data["showInDiscoveryDocument"];
        }
    }

    static fromJS(data: any): CreateApiScopeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApiScopeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["allowedAccessTokenSigningAlgorithms"] = this.allowedAccessTokenSigningAlgorithms;
        if (Array.isArray(this.userClaims)) {
            data["userClaims"] = [];
            for (let item of this.userClaims)
                data["userClaims"].push(item);
        }
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        data["required"] = this.required;
        data["emphasize"] = this.emphasize;
        data["showInDiscoveryDocument"] = this.showInDiscoveryDocument;
        return data;
    }
}

/** Models an API scope that will be created on the server. */
export interface ICreateApiScopeRequest {
    /** Display name of the resource. */
    displayName?: string | undefined;
    /** Description of the resource. */
    description?: string | undefined;
    /** The unique name of the resource. */
    name?: string | undefined;
    /** List of allowed signing algorithms for access token. If empty, will use the server default signing algorithm. */
    allowedAccessTokenSigningAlgorithms?: string | undefined;
    /** List of associated user claims that should be included when this resource is requested. */
    userClaims?: string[] | undefined;
    /** Translations. */
    translations?: { [key: string]: ApiScopeTranslation; } | undefined;
    /** Determines whether this scope is required or not. */
    required?: boolean;
    /** Determines whether this scope should be displayed emphasized or not. */
    emphasize?: boolean;
    /** Determines whether this scope should be displayed in the discovery document or not. */
    showInDiscoveryDocument?: boolean;
}

/** Models an application setting persisted in the database. */
export class CreateAppSettingRequest implements ICreateAppSettingRequest {
    /** The key of application setting. */
    key!: string;
    /** The value of application setting. */
    value!: string;

    constructor(data?: ICreateAppSettingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CreateAppSettingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAppSettingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

/** Models an application setting persisted in the database. */
export interface ICreateAppSettingRequest {
    /** The key of application setting. */
    key: string;
    /** The value of application setting. */
    value: string;
}

/** Models a request to create a claim for an entity (e.x user or client). */
export class CreateClaimRequest implements ICreateClaimRequest {
    /** The type of the claim. */
    type?: string | undefined;
    /** The value of the claim. */
    value?: string | undefined;

    constructor(data?: ICreateClaimRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CreateClaimRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClaimRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

/** Models a request to create a claim for an entity (e.x user or client). */
export interface ICreateClaimRequest {
    /** The type of the claim. */
    type?: string | undefined;
    /** The value of the claim. */
    value?: string | undefined;
}

/** Models a claim type that will be created on the server. */
export class CreateClaimTypeRequest implements ICreateClaimTypeRequest {
    /** The name. */
    name!: string;
    /** The name used for display purposes. If not set, Indice.Features.Identity.Server.Manager.Models.CreateClaimTypeRequest.Name is used. */
    displayName?: string | undefined;
    /** A description. */
    description?: string | undefined;
    /** Determines whether this claim is required to create new users. */
    required?: boolean;
    /** Determines whether this claim will be editable by a user if exposed through a public API. */
    userEditable?: boolean;
    /** A regex rule that constraints the values of the claim. */
    rule?: string | undefined;
    valueType?: ClaimValueType;

    constructor(data?: ICreateClaimTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.required = _data["required"];
            this.userEditable = _data["userEditable"];
            this.rule = _data["rule"];
            this.valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): CreateClaimTypeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClaimTypeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["required"] = this.required;
        data["userEditable"] = this.userEditable;
        data["rule"] = this.rule;
        data["valueType"] = this.valueType;
        return data;
    }
}

/** Models a claim type that will be created on the server. */
export interface ICreateClaimTypeRequest {
    /** The name. */
    name: string;
    /** The name used for display purposes. If not set, Indice.Features.Identity.Server.Manager.Models.CreateClaimTypeRequest.Name is used. */
    displayName?: string | undefined;
    /** A description. */
    description?: string | undefined;
    /** Determines whether this claim is required to create new users. */
    required?: boolean;
    /** Determines whether this claim will be editable by a user if exposed through a public API. */
    userEditable?: boolean;
    /** A regex rule that constraints the values of the claim. */
    rule?: string | undefined;
    valueType?: ClaimValueType;
}

/** Models a client that will be created on the server. */
export class CreateClientRequest implements ICreateClientRequest {
    /** Application name that will be seen on consent screens. */
    clientName?: string | undefined;
    /** Application URL that will be seen on consent screens. */
    clientUri?: string | undefined;
    /** Application logo that will be seen on consent screens. */
    logoUri?: string | undefined;
    /** Application description. */
    description?: string | undefined;
    /** Specifies whether a consent screen is required. */
    requireConsent?: boolean;
    /** Translations. */
    translations?: { [key: string]: ClientTranslation; } | undefined;
    clientType?: ClientType;
    /** The unique identifier for this application. */
    clientId?: string | undefined;
    /** Allowed URL to return after logging in. */
    redirectUri?: string | undefined;
    /** Allowed URL to return after logout. */
    postLogoutRedirectUri?: string | undefined;
    /** The client secrets. */
    secrets?: CreateSecretRequest[] | undefined;
    /** The list of identity resources allowed by the client. */
    identityResources?: string[] | undefined;
    /** The list of API resources allowed by the client. */
    apiResources?: string[] | undefined;

    constructor(data?: ICreateClientRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientName = _data["clientName"];
            this.clientUri = _data["clientUri"];
            this.logoUri = _data["logoUri"];
            this.description = _data["description"];
            this.requireConsent = _data["requireConsent"];
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? ClientTranslation.fromJS(_data["translations"][key]) : new ClientTranslation();
                }
            }
            this.clientType = _data["clientType"];
            this.clientId = _data["clientId"];
            this.redirectUri = _data["redirectUri"];
            this.postLogoutRedirectUri = _data["postLogoutRedirectUri"];
            if (Array.isArray(_data["secrets"])) {
                this.secrets = [] as any;
                for (let item of _data["secrets"])
                    this.secrets!.push(CreateSecretRequest.fromJS(item));
            }
            if (Array.isArray(_data["identityResources"])) {
                this.identityResources = [] as any;
                for (let item of _data["identityResources"])
                    this.identityResources!.push(item);
            }
            if (Array.isArray(_data["apiResources"])) {
                this.apiResources = [] as any;
                for (let item of _data["apiResources"])
                    this.apiResources!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateClientRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClientRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientName"] = this.clientName;
        data["clientUri"] = this.clientUri;
        data["logoUri"] = this.logoUri;
        data["description"] = this.description;
        data["requireConsent"] = this.requireConsent;
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        data["clientType"] = this.clientType;
        data["clientId"] = this.clientId;
        data["redirectUri"] = this.redirectUri;
        data["postLogoutRedirectUri"] = this.postLogoutRedirectUri;
        if (Array.isArray(this.secrets)) {
            data["secrets"] = [];
            for (let item of this.secrets)
                data["secrets"].push(item.toJSON());
        }
        if (Array.isArray(this.identityResources)) {
            data["identityResources"] = [];
            for (let item of this.identityResources)
                data["identityResources"].push(item);
        }
        if (Array.isArray(this.apiResources)) {
            data["apiResources"] = [];
            for (let item of this.apiResources)
                data["apiResources"].push(item);
        }
        return data;
    }
}

/** Models a client that will be created on the server. */
export interface ICreateClientRequest {
    /** Application name that will be seen on consent screens. */
    clientName?: string | undefined;
    /** Application URL that will be seen on consent screens. */
    clientUri?: string | undefined;
    /** Application logo that will be seen on consent screens. */
    logoUri?: string | undefined;
    /** Application description. */
    description?: string | undefined;
    /** Specifies whether a consent screen is required. */
    requireConsent?: boolean;
    /** Translations. */
    translations?: { [key: string]: ClientTranslation; } | undefined;
    clientType?: ClientType;
    /** The unique identifier for this application. */
    clientId?: string | undefined;
    /** Allowed URL to return after logging in. */
    redirectUri?: string | undefined;
    /** Allowed URL to return after logout. */
    postLogoutRedirectUri?: string | undefined;
    /** The client secrets. */
    secrets?: CreateSecretRequest[] | undefined;
    /** The list of identity resources allowed by the client. */
    identityResources?: string[] | undefined;
    /** The list of API resources allowed by the client. */
    apiResources?: string[] | undefined;
}

/** Models a resource (API or identity) that will be created on the server. */
export class CreateResourceRequest implements ICreateResourceRequest {
    /** Display name of the resource. */
    displayName?: string | undefined;
    /** Description of the resource. */
    description?: string | undefined;
    /** The unique name of the resource. */
    name?: string | undefined;
    /** List of allowed signing algorithms for access token. If empty, will use the server default signing algorithm. */
    allowedAccessTokenSigningAlgorithms?: string | undefined;
    /** List of associated user claims that should be included when this resource is requested. */
    userClaims?: string[] | undefined;
    /** Translations. */
    translations?: { [key: string]: ApiScopeTranslation; } | undefined;

    constructor(data?: ICreateResourceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.allowedAccessTokenSigningAlgorithms = _data["allowedAccessTokenSigningAlgorithms"];
            if (Array.isArray(_data["userClaims"])) {
                this.userClaims = [] as any;
                for (let item of _data["userClaims"])
                    this.userClaims!.push(item);
            }
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? ApiScopeTranslation.fromJS(_data["translations"][key]) : new ApiScopeTranslation();
                }
            }
        }
    }

    static fromJS(data: any): CreateResourceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateResourceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["allowedAccessTokenSigningAlgorithms"] = this.allowedAccessTokenSigningAlgorithms;
        if (Array.isArray(this.userClaims)) {
            data["userClaims"] = [];
            for (let item of this.userClaims)
                data["userClaims"].push(item);
        }
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Models a resource (API or identity) that will be created on the server. */
export interface ICreateResourceRequest {
    /** Display name of the resource. */
    displayName?: string | undefined;
    /** Description of the resource. */
    description?: string | undefined;
    /** The unique name of the resource. */
    name?: string | undefined;
    /** List of allowed signing algorithms for access token. If empty, will use the server default signing algorithm. */
    allowedAccessTokenSigningAlgorithms?: string | undefined;
    /** List of associated user claims that should be included when this resource is requested. */
    userClaims?: string[] | undefined;
    /** Translations. */
    translations?: { [key: string]: ApiScopeTranslation; } | undefined;
}

/** Models a role that will be created on the server. */
export class CreateRoleRequest implements ICreateRoleRequest {
    /** The name of the role. */
    name!: string;
    /** A description for the role. */
    description?: string | undefined;

    constructor(data?: ICreateRoleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateRoleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

/** Models a role that will be created on the server. */
export interface ICreateRoleRequest {
    /** The name of the role. */
    name: string;
    /** A description for the role. */
    description?: string | undefined;
}

/** Models a client or API secret that will be created on the server. */
export class CreateSecretRequest implements ICreateSecretRequest {
    /** Description of client secret. */
    description?: string | undefined;
    /** The value of client secret. */
    value?: string | undefined;
    /** Optional expiration of client secret. */
    expiration?: Date | undefined;

    constructor(data?: ICreateSecretRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.value = _data["value"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateSecretRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSecretRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["value"] = this.value;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        return data;
    }
}

/** Models a client or API secret that will be created on the server. */
export interface ICreateSecretRequest {
    /** Description of client secret. */
    description?: string | undefined;
    /** The value of client secret. */
    value?: string | undefined;
    /** Optional expiration of client secret. */
    expiration?: Date | undefined;
}

/** Models a new user that will be created on the server. */
export class CreateUserRequest implements ICreateUserRequest {
    /** The first name of the user. */
    firstName?: string | undefined;
    /** The last name of the user. */
    lastName?: string | undefined;
    /** The username used to login. */
    userName!: string;
    /** The email of the user. */
    email?: string | undefined;
    /** Gets or sets a flag indicating if a user has confirmed their email address. */
    emailConfirmed?: boolean | undefined;
    /** The initial password of the user. */
    password?: string | undefined;
    /** User's phone number. */
    phoneNumber?: string | undefined;
    /** Gets or sets a flag indicating if a user has confirmed their telephone address. */
    phoneNumberConfirmed?: boolean | undefined;
    passwordExpirationPolicy?: PasswordExpirationPolicy;
    /** Forces the user to change his password after created by the system admin. */
    changePasswordAfterFirstSignIn?: boolean | undefined;
    /** Bypasses all password validation rules. */
    bypassPasswordValidation?: boolean | undefined;
    /** Gets or sets a flag indicating if two factor authentication is enabled for this user. */
    twoFactorEnabled?: boolean | undefined;
    /** Dynamic claims that have been marked as required. */
    claims?: BasicClaimInfo[] | undefined;
    /** The names of the roles that the user will be added to. */
    roles?: string[] | undefined;

    constructor(data?: ICreateUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.password = _data["password"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.passwordExpirationPolicy = _data["passwordExpirationPolicy"];
            this.changePasswordAfterFirstSignIn = _data["changePasswordAfterFirstSignIn"];
            this.bypassPasswordValidation = _data["bypassPasswordValidation"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(BasicClaimInfo.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["password"] = this.password;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["passwordExpirationPolicy"] = this.passwordExpirationPolicy;
        data["changePasswordAfterFirstSignIn"] = this.changePasswordAfterFirstSignIn;
        data["bypassPasswordValidation"] = this.bypassPasswordValidation;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

/** Models a new user that will be created on the server. */
export interface ICreateUserRequest {
    /** The first name of the user. */
    firstName?: string | undefined;
    /** The last name of the user. */
    lastName?: string | undefined;
    /** The username used to login. */
    userName: string;
    /** The email of the user. */
    email?: string | undefined;
    /** Gets or sets a flag indicating if a user has confirmed their email address. */
    emailConfirmed?: boolean | undefined;
    /** The initial password of the user. */
    password?: string | undefined;
    /** User's phone number. */
    phoneNumber?: string | undefined;
    /** Gets or sets a flag indicating if a user has confirmed their telephone address. */
    phoneNumberConfirmed?: boolean | undefined;
    passwordExpirationPolicy?: PasswordExpirationPolicy;
    /** Forces the user to change his password after created by the system admin. */
    changePasswordAfterFirstSignIn?: boolean | undefined;
    /** Bypasses all password validation rules. */
    bypassPasswordValidation?: boolean | undefined;
    /** Gets or sets a flag indicating if two factor authentication is enabled for this user. */
    twoFactorEnabled?: boolean | undefined;
    /** Dynamic claims that have been marked as required. */
    claims?: BasicClaimInfo[] | undefined;
    /** The names of the roles that the user will be added to. */
    roles?: string[] | undefined;
}

/** Models the result of validating a user's credentials. */
export class CredentialsValidationInfo implements ICredentialsValidationInfo {
    /** Contains the results of checking various password validation rules. */
    passwordRules?: PasswordRuleInfo[] | undefined;

    constructor(data?: ICredentialsValidationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["passwordRules"])) {
                this.passwordRules = [] as any;
                for (let item of _data["passwordRules"])
                    this.passwordRules!.push(PasswordRuleInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CredentialsValidationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CredentialsValidationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.passwordRules)) {
            data["passwordRules"] = [];
            for (let item of this.passwordRules)
                data["passwordRules"].push(item.toJSON());
        }
        return data;
    }
}

/** Models the result of validating a user's credentials. */
export interface ICredentialsValidationInfo {
    /** Contains the results of checking various password validation rules. */
    passwordRules?: PasswordRuleInfo[] | undefined;
}

export class DefaultClientThemeConfig implements IDefaultClientThemeConfig {
    backgroundImage?: string | undefined;
    accentColor?: string | undefined;
    primaryColor?: string | undefined;
    secondaryColor?: string | undefined;

    constructor(data?: IDefaultClientThemeConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.backgroundImage = _data["backgroundImage"];
            this.accentColor = _data["accentColor"];
            this.primaryColor = _data["primaryColor"];
            this.secondaryColor = _data["secondaryColor"];
        }
    }

    static fromJS(data: any): DefaultClientThemeConfig {
        data = typeof data === 'object' ? data : {};
        let result = new DefaultClientThemeConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["backgroundImage"] = this.backgroundImage;
        data["accentColor"] = this.accentColor;
        data["primaryColor"] = this.primaryColor;
        data["secondaryColor"] = this.secondaryColor;
        return data;
    }
}

export interface IDefaultClientThemeConfig {
    backgroundImage?: string | undefined;
    accentColor?: string | undefined;
    primaryColor?: string | undefined;
    secondaryColor?: string | undefined;
}

export enum DeviceClientType {
    Browser = "Browser",
    Native = "Native",
}

/** Models a user device. */
export class DeviceInfo implements IDeviceInfo {
    /** The primary key. */
    registrationId?: string;
    /** Device id. */
    deviceId?: string | undefined;
    platform?: DevicePlatform;
    /** Device name. */
    name?: string | undefined;
    /** Device model. */
    model?: string | undefined;
    /** Device OS version. */
    osVersion?: string | undefined;
    /** The date this device was created. */
    dateCreated?: Date;
    /** Gets or sets the date and time, in UTC, when the device last signed in. */
    lastSignInDate?: Date | undefined;
    /** Flag that determines if push notifications are enabled for this device. */
    isPushNotificationsEnabled?: boolean;
    /** Flag for pin support. */
    supportsPinLogin?: boolean;
    /** Flag for fingerprint support. */
    supportsFingerprintLogin?: boolean;
    /** Indicates whether the device is blocked. */
    requiresPassword?: boolean;
    /** The date that the device can be activated for trust. */
    trustActivationDate?: Date | undefined;
    /** Indicates whether the device is a trusted device (i.e. capable of strong customer authentication scenarios). */
    isTrusted?: boolean;
    /** Indicates whether the user can activate device trust after waiting for the specified delay. */
    readonly canActivateDeviceTrust?: boolean;
    /** Extra metadata for the device. */
    data?: any | undefined;
    clientType?: DeviceClientType;
    /** The date until the client is remembered by the system and MFA is not asked. */
    mfaSessionExpirationDate?: Date | undefined;
    /** Indicates whether device is blocked for any action. */
    blocked?: boolean;
    /** Device tags. */
    tags?: string[] | undefined;

    constructor(data?: IDeviceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.registrationId = _data["registrationId"];
            this.deviceId = _data["deviceId"];
            this.platform = _data["platform"];
            this.name = _data["name"];
            this.model = _data["model"];
            this.osVersion = _data["osVersion"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.lastSignInDate = _data["lastSignInDate"] ? new Date(_data["lastSignInDate"].toString()) : <any>undefined;
            this.isPushNotificationsEnabled = _data["isPushNotificationsEnabled"];
            this.supportsPinLogin = _data["supportsPinLogin"];
            this.supportsFingerprintLogin = _data["supportsFingerprintLogin"];
            this.requiresPassword = _data["requiresPassword"];
            this.trustActivationDate = _data["trustActivationDate"] ? new Date(_data["trustActivationDate"].toString()) : <any>undefined;
            this.isTrusted = _data["isTrusted"];
            (<any>this).canActivateDeviceTrust = _data["canActivateDeviceTrust"];
            this.data = _data["data"];
            this.clientType = _data["clientType"];
            this.mfaSessionExpirationDate = _data["mfaSessionExpirationDate"] ? new Date(_data["mfaSessionExpirationDate"].toString()) : <any>undefined;
            this.blocked = _data["blocked"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): DeviceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["registrationId"] = this.registrationId;
        data["deviceId"] = this.deviceId;
        data["platform"] = this.platform;
        data["name"] = this.name;
        data["model"] = this.model;
        data["osVersion"] = this.osVersion;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["lastSignInDate"] = this.lastSignInDate ? this.lastSignInDate.toISOString() : <any>undefined;
        data["isPushNotificationsEnabled"] = this.isPushNotificationsEnabled;
        data["supportsPinLogin"] = this.supportsPinLogin;
        data["supportsFingerprintLogin"] = this.supportsFingerprintLogin;
        data["requiresPassword"] = this.requiresPassword;
        data["trustActivationDate"] = this.trustActivationDate ? this.trustActivationDate.toISOString() : <any>undefined;
        data["isTrusted"] = this.isTrusted;
        data["canActivateDeviceTrust"] = this.canActivateDeviceTrust;
        data["data"] = this.data;
        data["clientType"] = this.clientType;
        data["mfaSessionExpirationDate"] = this.mfaSessionExpirationDate ? this.mfaSessionExpirationDate.toISOString() : <any>undefined;
        data["blocked"] = this.blocked;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

/** Models a user device. */
export interface IDeviceInfo {
    /** The primary key. */
    registrationId?: string;
    /** Device id. */
    deviceId?: string | undefined;
    platform?: DevicePlatform;
    /** Device name. */
    name?: string | undefined;
    /** Device model. */
    model?: string | undefined;
    /** Device OS version. */
    osVersion?: string | undefined;
    /** The date this device was created. */
    dateCreated?: Date;
    /** Gets or sets the date and time, in UTC, when the device last signed in. */
    lastSignInDate?: Date | undefined;
    /** Flag that determines if push notifications are enabled for this device. */
    isPushNotificationsEnabled?: boolean;
    /** Flag for pin support. */
    supportsPinLogin?: boolean;
    /** Flag for fingerprint support. */
    supportsFingerprintLogin?: boolean;
    /** Indicates whether the device is blocked. */
    requiresPassword?: boolean;
    /** The date that the device can be activated for trust. */
    trustActivationDate?: Date | undefined;
    /** Indicates whether the device is a trusted device (i.e. capable of strong customer authentication scenarios). */
    isTrusted?: boolean;
    /** Indicates whether the user can activate device trust after waiting for the specified delay. */
    canActivateDeviceTrust?: boolean;
    /** Extra metadata for the device. */
    data?: any | undefined;
    clientType?: DeviceClientType;
    /** The date until the client is remembered by the system and MFA is not asked. */
    mfaSessionExpirationDate?: Date | undefined;
    /** Indicates whether device is blocked for any action. */
    blocked?: boolean;
    /** Device tags. */
    tags?: string[] | undefined;
}

export class DeviceInfoResultSet implements IDeviceInfoResultSet {
    count?: number;
    items?: DeviceInfo[] | undefined;

    constructor(data?: IDeviceInfoResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DeviceInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeviceInfoResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceInfoResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDeviceInfoResultSet {
    count?: number;
    items?: DeviceInfo[] | undefined;
}

export enum DevicePlatform {
    None = "None",
    Android = "Android",
    IOS = "iOS",
    Windows = "Windows",
    Linux = "Linux",
    MacOS = "MacOS",
}

/** the external provider model */
export class ExternalProvider implements IExternalProvider {
    /** The display name */
    displayName?: string | undefined;
    /** The authentication scheme for the cookie */
    authenticationScheme?: string | undefined;

    constructor(data?: IExternalProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.authenticationScheme = _data["authenticationScheme"];
        }
    }

    static fromJS(data: any): ExternalProvider {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["authenticationScheme"] = this.authenticationScheme;
        return data;
    }
}

/** the external provider model */
export interface IExternalProvider {
    /** The display name */
    displayName?: string | undefined;
    /** The authentication scheme for the cookie */
    authenticationScheme?: string | undefined;
}

export class ExternalProviderResultSet implements IExternalProviderResultSet {
    count?: number;
    items?: ExternalProvider[] | undefined;

    constructor(data?: IExternalProviderResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExternalProvider.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalProviderResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalProviderResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExternalProviderResultSet {
    count?: number;
    items?: ExternalProvider[] | undefined;
}

/** Completes the password reset process. Maybe we need to retire one of them. They only differ by their use of the Email or username fields for user retrieval. */
export class ForgotPasswordConfirmationRequest implements IForgotPasswordConfirmationRequest {
    /** The token. */
    token?: string | undefined;
    /** The user's email. */
    email!: string;
    /** The new password. */
    newPassword!: string;
    /** The new password confirmed (optional). */
    newPasswordConfirmation!: string;
    /** The url to return to. */
    returnUrl?: string | undefined;

    constructor(data?: IForgotPasswordConfirmationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.email = _data["email"];
            this.newPassword = _data["newPassword"];
            this.newPasswordConfirmation = _data["newPasswordConfirmation"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): ForgotPasswordConfirmationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordConfirmationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["email"] = this.email;
        data["newPassword"] = this.newPassword;
        data["newPasswordConfirmation"] = this.newPasswordConfirmation;
        data["returnUrl"] = this.returnUrl;
        return data;
    }
}

/** Completes the password reset process. Maybe we need to retire one of them. They only differ by their use of the Email or username fields for user retrieval. */
export interface IForgotPasswordConfirmationRequest {
    /** The token. */
    token?: string | undefined;
    /** The user's email. */
    email: string;
    /** The new password. */
    newPassword: string;
    /** The new password confirmed (optional). */
    newPasswordConfirmation: string;
    /** The url to return to. */
    returnUrl?: string | undefined;
}

/** Triggers the initiation for a password reset. */
export class ForgotPasswordRequest implements IForgotPasswordRequest {
    /** The user's email. */
    email?: string | undefined;
    /** The url to return to. */
    returnUrl?: string | undefined;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.returnUrl = _data["returnUrl"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["returnUrl"] = this.returnUrl;
        return data;
    }
}

/** Triggers the initiation for a password reset. */
export interface IForgotPasswordRequest {
    /** The user's email. */
    email?: string | undefined;
    /** The url to return to. */
    returnUrl?: string | undefined;
}

/** Describes the grant type of a client in the database. */
export class GrantTypeInfo implements IGrantTypeInfo {
    /** The id of the grant type in the system. */
    id?: number | undefined;
    /** The name of the grant type. */
    name?: string | undefined;

    constructor(data?: IGrantTypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GrantTypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new GrantTypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** Describes the grant type of a client in the database. */
export interface IGrantTypeInfo {
    /** The id of the grant type in the system. */
    id?: number | undefined;
    /** The name of the grant type. */
    name?: string | undefined;
}

export class HttpValidationProblemDetails implements IHttpValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;

    constructor(data?: IHttpValidationProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        return data;
    }
}

export interface IHttpValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; } | undefined;

    [key: string]: any;
}

/** Models an identity resource for the application. */
export class IdentityResourceInfo implements IIdentityResourceInfo {
    /** Unique identifier for the identity resource. */
    id?: number;
    /** The name of the resource. */
    name?: string | undefined;
    /** The display name of the resource. */
    displayName?: string | undefined;
    /** The description of the resource. */
    description?: string | undefined;
    /** Determines whether this resource is enabled or not. */
    enabled?: boolean;
    /** Determines whether this resource is required or not. */
    required?: boolean;
    /** Determines whether this resource should be displayed emphasized or not. */
    emphasize?: boolean;
    /** Determines whether this resource should be displayed in the discovery document or not. */
    showInDiscoveryDocument?: boolean;
    /** Determines whether this resource is editable or not. */
    nonEditable?: boolean;
    /** List of associated claims that should be included when this resource is requested. */
    allowedClaims?: string[] | undefined;

    constructor(data?: IIdentityResourceInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.enabled = _data["enabled"];
            this.required = _data["required"];
            this.emphasize = _data["emphasize"];
            this.showInDiscoveryDocument = _data["showInDiscoveryDocument"];
            this.nonEditable = _data["nonEditable"];
            if (Array.isArray(_data["allowedClaims"])) {
                this.allowedClaims = [] as any;
                for (let item of _data["allowedClaims"])
                    this.allowedClaims!.push(item);
            }
        }
    }

    static fromJS(data: any): IdentityResourceInfo {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityResourceInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["enabled"] = this.enabled;
        data["required"] = this.required;
        data["emphasize"] = this.emphasize;
        data["showInDiscoveryDocument"] = this.showInDiscoveryDocument;
        data["nonEditable"] = this.nonEditable;
        if (Array.isArray(this.allowedClaims)) {
            data["allowedClaims"] = [];
            for (let item of this.allowedClaims)
                data["allowedClaims"].push(item);
        }
        return data;
    }
}

/** Models an identity resource for the application. */
export interface IIdentityResourceInfo {
    /** Unique identifier for the identity resource. */
    id?: number;
    /** The name of the resource. */
    name?: string | undefined;
    /** The display name of the resource. */
    displayName?: string | undefined;
    /** The description of the resource. */
    description?: string | undefined;
    /** Determines whether this resource is enabled or not. */
    enabled?: boolean;
    /** Determines whether this resource is required or not. */
    required?: boolean;
    /** Determines whether this resource should be displayed emphasized or not. */
    emphasize?: boolean;
    /** Determines whether this resource should be displayed in the discovery document or not. */
    showInDiscoveryDocument?: boolean;
    /** Determines whether this resource is editable or not. */
    nonEditable?: boolean;
    /** List of associated claims that should be included when this resource is requested. */
    allowedClaims?: string[] | undefined;
}

export class IdentityResourceInfoResultSet implements IIdentityResourceInfoResultSet {
    count?: number;
    items?: IdentityResourceInfo[] | undefined;

    constructor(data?: IIdentityResourceInfoResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IdentityResourceInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdentityResourceInfoResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityResourceInfoResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIdentityResourceInfoResultSet {
    count?: number;
    items?: IdentityResourceInfo[] | undefined;
}

/** File upload request */
export class ImageUploadRequest implements IImageUploadRequest {
    /** File data */
    file!: string;
    /** Zoom level. Defaults to 1.0 */
    scale?: number | undefined;
    /** offset X axis. Defaults to 0. */
    translateX?: number | undefined;
    /** offset Y axis. Defaults to 0 */
    translateY?: number | undefined;
    /** The side size of the viewport square used to crop the image source. 
This is used as a reference for converting the Indice.Features.Identity.Server.Manager.Models.ImageUploadRequest.TranslateX and Indice.Features.Identity.Server.Manager.Models.ImageUploadRequest.TranslateY to the internal crop sqare the will be used as the final size of the picture.
If left empty it is asumed as if it is the same as the size of the internal crop square. */
    viewPort?: number | undefined;

    constructor(data?: IImageUploadRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file = _data["file"];
            this.scale = _data["scale"];
            this.translateX = _data["translateX"];
            this.translateY = _data["translateY"];
            this.viewPort = _data["viewPort"];
        }
    }

    static fromJS(data: any): ImageUploadRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ImageUploadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file;
        data["scale"] = this.scale;
        data["translateX"] = this.translateX;
        data["translateY"] = this.translateY;
        data["viewPort"] = this.viewPort;
        return data;
    }
}

/** File upload request */
export interface IImageUploadRequest {
    /** File data */
    file: string;
    /** Zoom level. Defaults to 1.0 */
    scale?: number | undefined;
    /** offset X axis. Defaults to 0. */
    translateX?: number | undefined;
    /** offset Y axis. Defaults to 0 */
    translateY?: number | undefined;
    /** The side size of the viewport square used to crop the image source. 
This is used as a reference for converting the Indice.Features.Identity.Server.Manager.Models.ImageUploadRequest.TranslateX and Indice.Features.Identity.Server.Manager.Models.ImageUploadRequest.TranslateY to the internal crop sqare the will be used as the final size of the picture.
If left empty it is asumed as if it is the same as the size of the internal crop square. */
    viewPort?: number | undefined;
}

export enum PasswordExpirationPolicy {
    Monthly = "Monthly",
    Quarterly = "Quarterly",
    Semesterly = "Semesterly",
    Annually = "Annually",
    Biannually = "Biannually",
    Never = "Never",
}

export class PasswordOptions implements IPasswordOptions {
    requiredLength?: number;
    requiredUniqueChars?: number;
    requireNonAlphanumeric?: boolean;
    requireLowercase?: boolean;
    requireUppercase?: boolean;
    requireDigit?: boolean;

    constructor(data?: IPasswordOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requiredLength = _data["requiredLength"];
            this.requiredUniqueChars = _data["requiredUniqueChars"];
            this.requireNonAlphanumeric = _data["requireNonAlphanumeric"];
            this.requireLowercase = _data["requireLowercase"];
            this.requireUppercase = _data["requireUppercase"];
            this.requireDigit = _data["requireDigit"];
        }
    }

    static fromJS(data: any): PasswordOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requiredLength"] = this.requiredLength;
        data["requiredUniqueChars"] = this.requiredUniqueChars;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireLowercase"] = this.requireLowercase;
        data["requireUppercase"] = this.requireUppercase;
        data["requireDigit"] = this.requireDigit;
        return data;
    }
}

export interface IPasswordOptions {
    requiredLength?: number;
    requiredUniqueChars?: number;
    requireNonAlphanumeric?: boolean;
    requireLowercase?: boolean;
    requireUppercase?: boolean;
    requireDigit?: boolean;
}

/** Models a password validation rule. */
export class PasswordRuleInfo implements IPasswordRuleInfo {
    /** The name of the rule checked. */
    code?: string | undefined;
    /** The rule error description. */
    description?: string | undefined;
    /** The requirement for the rule. */
    requirement?: string | undefined;
    /** Determines if rule validation was successful or not. */
    isValid?: boolean;

    constructor(data?: IPasswordRuleInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
            this.requirement = _data["requirement"];
            this.isValid = _data["isValid"];
        }
    }

    static fromJS(data: any): PasswordRuleInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordRuleInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        data["requirement"] = this.requirement;
        data["isValid"] = this.isValid;
        return data;
    }
}

/** Models a password validation rule. */
export interface IPasswordRuleInfo {
    /** The name of the rule checked. */
    code?: string | undefined;
    /** The rule error description. */
    description?: string | undefined;
    /** The requirement for the rule. */
    requirement?: string | undefined;
    /** Determines if rule validation was successful or not. */
    isValid?: boolean;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

/** Register a device for push notifications. */
export class RegisterDeviceRequest implements IRegisterDeviceRequest {
    /** The device id to register for push notifications. */
    deviceId!: string;
    /** Platform Notification Service (PNS) obtained from client platform. */
    pnsHandle?: string | undefined;
    /** Device name. */
    name?: string | undefined;
    platform!: DevicePlatform;
    /** Tags are used to route notifications to the correct set of device handles. */
    tags?: string[] | undefined;
    /** Device model. */
    model?: string | undefined;
    /** Device OS version. */
    osVersion?: string | undefined;
    clientType?: DeviceClientType;
    /** Extra metadata for the device. */
    data?: any | undefined;

    constructor(data?: IRegisterDeviceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.pnsHandle = _data["pnsHandle"];
            this.name = _data["name"];
            this.platform = _data["platform"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.model = _data["model"];
            this.osVersion = _data["osVersion"];
            this.clientType = _data["clientType"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): RegisterDeviceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterDeviceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["pnsHandle"] = this.pnsHandle;
        data["name"] = this.name;
        data["platform"] = this.platform;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["model"] = this.model;
        data["osVersion"] = this.osVersion;
        data["clientType"] = this.clientType;
        data["data"] = this.data;
        return data;
    }
}

/** Register a device for push notifications. */
export interface IRegisterDeviceRequest {
    /** The device id to register for push notifications. */
    deviceId: string;
    /** Platform Notification Service (PNS) obtained from client platform. */
    pnsHandle?: string | undefined;
    /** Device name. */
    name?: string | undefined;
    platform: DevicePlatform;
    /** Tags are used to route notifications to the correct set of device handles. */
    tags?: string[] | undefined;
    /** Device model. */
    model?: string | undefined;
    /** Device OS version. */
    osVersion?: string | undefined;
    clientType?: DeviceClientType;
    /** Extra metadata for the device. */
    data?: any | undefined;
}

/** Models a new user that is registering on the system. */
export class RegisterRequest implements IRegisterRequest {
    /** The first name of the user. */
    firstName?: string | undefined;
    /** The last name of the user. */
    lastName?: string | undefined;
    /** The username used to login. */
    userName!: string;
    /** User password. */
    password!: string;
    /** User password confirmation. */
    passwordConfirmation?: string | undefined;
    /** Email. */
    email!: string;
    /** Phone number. */
    phoneNumber?: string | undefined;
    /** Privacy policy read. */
    hasReadPrivacyPolicy?: boolean;
    /** Terms read. */
    hasAcceptedTerms?: boolean;
    /** User claims. */
    claims?: BasicClaimInfo[] | undefined;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.passwordConfirmation = _data["passwordConfirmation"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.hasReadPrivacyPolicy = _data["hasReadPrivacyPolicy"];
            this.hasAcceptedTerms = _data["hasAcceptedTerms"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(BasicClaimInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["passwordConfirmation"] = this.passwordConfirmation;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["hasReadPrivacyPolicy"] = this.hasReadPrivacyPolicy;
        data["hasAcceptedTerms"] = this.hasAcceptedTerms;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        return data;
    }
}

/** Models a new user that is registering on the system. */
export interface IRegisterRequest {
    /** The first name of the user. */
    firstName?: string | undefined;
    /** The last name of the user. */
    lastName?: string | undefined;
    /** The username used to login. */
    userName: string;
    /** User password. */
    password: string;
    /** User password confirmation. */
    passwordConfirmation?: string | undefined;
    /** Email. */
    email: string;
    /** Phone number. */
    phoneNumber?: string | undefined;
    /** Privacy policy read. */
    hasReadPrivacyPolicy?: boolean;
    /** Terms read. */
    hasAcceptedTerms?: boolean;
    /** User claims. */
    claims?: BasicClaimInfo[] | undefined;
}

/** Models an system role. */
export class RoleInfo implements IRoleInfo {
    /** The id of the role. */
    id?: string | undefined;
    /** The name of the role. */
    name?: string | undefined;
    /** A description for the role. */
    description?: string | undefined;

    constructor(data?: IRoleInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): RoleInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RoleInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

/** Models an system role. */
export interface IRoleInfo {
    /** The id of the role. */
    id?: string | undefined;
    /** The name of the role. */
    name?: string | undefined;
    /** A description for the role. */
    description?: string | undefined;
}

export class RoleInfoResultSet implements IRoleInfoResultSet {
    count?: number;
    items?: RoleInfo[] | undefined;

    constructor(data?: IRoleInfoResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleInfoResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new RoleInfoResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRoleInfoResultSet {
    count?: number;
    items?: RoleInfo[] | undefined;
}

/** Models a secret value used for a client or API. */
export class SecretInfo implements ISecretInfo {
    /** Description of client secret. */
    description?: string | undefined;
    /** The value of client secret. */
    value?: string | undefined;
    /** Optional expiration of client secret. */
    expiration?: Date | undefined;
    /** The type of client secret. */
    type?: string | undefined;
    /** The identifier for the API secret. */
    id?: number;
    /** Indicates if the secret is expired. */
    readonly isExpired?: boolean;

    constructor(data?: ISecretInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.value = _data["value"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.id = _data["id"];
            (<any>this).isExpired = _data["isExpired"];
        }
    }

    static fromJS(data: any): SecretInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SecretInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["value"] = this.value;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["id"] = this.id;
        data["isExpired"] = this.isExpired;
        return data;
    }
}

/** Models a secret value used for a client or API. */
export interface ISecretInfo {
    /** Description of client secret. */
    description?: string | undefined;
    /** The value of client secret. */
    value?: string | undefined;
    /** Optional expiration of client secret. */
    expiration?: Date | undefined;
    /** The type of client secret. */
    type?: string | undefined;
    /** The identifier for the API secret. */
    id?: number;
    /** Indicates if the secret is expired. */
    isExpired?: boolean;
}

/** Models a secret. */
export class SecretInfoBase implements ISecretInfoBase {
    /** Description of client secret. */
    description?: string | undefined;
    /** The value of client secret. */
    value?: string | undefined;
    /** Optional expiration of client secret. */
    expiration?: Date | undefined;
    /** The type of client secret. */
    type?: string | undefined;

    constructor(data?: ISecretInfoBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.value = _data["value"];
            this.expiration = _data["expiration"] ? new Date(_data["expiration"].toString()) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): SecretInfoBase {
        data = typeof data === 'object' ? data : {};
        let result = new SecretInfoBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["value"] = this.value;
        data["expiration"] = this.expiration ? this.expiration.toISOString() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

/** Models a secret. */
export interface ISecretInfoBase {
    /** Description of client secret. */
    description?: string | undefined;
    /** The value of client secret. */
    value?: string | undefined;
    /** Optional expiration of client secret. */
    expiration?: Date | undefined;
    /** The type of client secret. */
    type?: string | undefined;
}

/** Models a request when sending a push notification. */
export class SendPushNotificationRequest implements ISendPushNotificationRequest {
    /** The title to send. */
    title?: string | undefined;
    /** The body to send. */
    body?: string | undefined;
    /** Defines if push notification is sent to all registered user devices. */
    broadcast?: boolean | undefined;
    /** The user identifier that correlates devices with users. This can be any identifier like user id, username, user email, customer code etc. Required when Indice.Features.Identity.Server.Devices.Models.SendPushNotificationRequest.Broadcast has the value <i>false</i>. */
    userTag?: string | undefined;
    /** List of extra tags. */
    tags?: string[] | undefined;
    /** Notification data. */
    data?: { [key: string]: any; } | undefined;
    /** Notification classification. */
    classification?: string | undefined;

    constructor(data?: ISendPushNotificationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.body = _data["body"];
            this.broadcast = _data["broadcast"];
            this.userTag = _data["userTag"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (<any>this.data)![key] = _data["data"][key];
                }
            }
            this.classification = _data["classification"];
        }
    }

    static fromJS(data: any): SendPushNotificationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SendPushNotificationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["body"] = this.body;
        data["broadcast"] = this.broadcast;
        data["userTag"] = this.userTag;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (<any>data["data"])[key] = (<any>this.data)[key];
            }
        }
        data["classification"] = this.classification;
        return data;
    }
}

/** Models a request when sending a push notification. */
export interface ISendPushNotificationRequest {
    /** The title to send. */
    title?: string | undefined;
    /** The body to send. */
    body?: string | undefined;
    /** Defines if push notification is sent to all registered user devices. */
    broadcast?: boolean | undefined;
    /** The user identifier that correlates devices with users. This can be any identifier like user id, username, user email, customer code etc. Required when Indice.Features.Identity.Server.Devices.Models.SendPushNotificationRequest.Broadcast has the value <i>false</i>. */
    userTag?: string | undefined;
    /** List of extra tags. */
    tags?: string[] | undefined;
    /** Notification data. */
    data?: { [key: string]: any; } | undefined;
    /** Notification classification. */
    classification?: string | undefined;
}

/** Models a request to set a user's password. */
export class SetPasswordRequest implements ISetPasswordRequest {
    /** The password of the user. */
    password!: string;
    /** Forces the user to change his password after changed by the system admin. */
    changePasswordAfterFirstSignIn?: boolean | undefined;
    /** Bypasses all password validation rules. */
    bypassPasswordValidation?: boolean | undefined;

    constructor(data?: ISetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.changePasswordAfterFirstSignIn = _data["changePasswordAfterFirstSignIn"];
            this.bypassPasswordValidation = _data["bypassPasswordValidation"];
        }
    }

    static fromJS(data: any): SetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["changePasswordAfterFirstSignIn"] = this.changePasswordAfterFirstSignIn;
        data["bypassPasswordValidation"] = this.bypassPasswordValidation;
        return data;
    }
}

/** Models a request to set a user's password. */
export interface ISetPasswordRequest {
    /** The password of the user. */
    password: string;
    /** Forces the user to change his password after changed by the system admin. */
    changePasswordAfterFirstSignIn?: boolean | undefined;
    /** Bypasses all password validation rules. */
    bypassPasswordValidation?: boolean | undefined;
}

/** Models toggling a user's 'Blocked' property. */
export class SetUserBlockRequest implements ISetUserBlockRequest {
    /** Indicates whether the user is forcefully blocked. */
    blocked?: boolean;

    constructor(data?: ISetUserBlockRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.blocked = _data["blocked"];
        }
    }

    static fromJS(data: any): SetUserBlockRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetUserBlockRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["blocked"] = this.blocked;
        return data;
    }
}

/** Models toggling a user's 'Blocked' property. */
export interface ISetUserBlockRequest {
    /** Indicates whether the user is forcefully blocked. */
    blocked?: boolean;
}

/** A model representing a user's sign in log entry. */
export class SignInLogEntry implements ISignInLogEntry {
    /** The unique id of the user's sign in log entry. */
    id?: string;
    /** A timestamp that indicates when the user's sign in log entry occurred. */
    createdAt?: Date;
    /** The name of the action. */
    actionName?: string | undefined;
    eventType?: SignInLogEventType;
    /** The unique identifier of the application. */
    applicationId?: string | undefined;
    /** The display name of the application. */
    applicationName?: string | undefined;
    /** The unique identifier of the subject. */
    subjectId?: string | undefined;
    /** The display name of the subject. */
    subjectName?: string | undefined;
    /** The unique identifier of the resource. */
    resourceId?: string | undefined;
    /** The name of the resource. */
    resourceType?: string | undefined;
    /** A friendly text describing the log entry. */
    description?: string | undefined;
    /** Indicates whether the operation that caused the user's sign in log entry was successful or not. */
    succeeded?: boolean;
    /** The IP address of the client. */
    ipAddress?: string | undefined;
    /** The unique identifier of the current request. */
    requestId?: string | undefined;
    /** The estimated client location based on the Indice.Features.Identity.SignInLogs.Models.SignInLogEntry.IpAddress. */
    location?: string | undefined;
    /** User's session id. */
    sessionId?: string | undefined;
    signInType?: SignInType;
    /** Indicates whether the specified log entry is marked for review. */
    review?: boolean;
    /** Two letter ISO code for the country. */
    countryIsoCode?: string | undefined;
    /** The device id. */
    deviceId?: string | undefined;
    /** The grant type used for the login. */
    grantType?: string | undefined;
    /** The approximate location of the operation. */
    coordinates?: string | undefined;
    extraData?: SignInLogEntryExtraData;

    constructor(data?: ISignInLogEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.actionName = _data["actionName"];
            this.eventType = _data["eventType"];
            this.applicationId = _data["applicationId"];
            this.applicationName = _data["applicationName"];
            this.subjectId = _data["subjectId"];
            this.subjectName = _data["subjectName"];
            this.resourceId = _data["resourceId"];
            this.resourceType = _data["resourceType"];
            this.description = _data["description"];
            this.succeeded = _data["succeeded"];
            this.ipAddress = _data["ipAddress"];
            this.requestId = _data["requestId"];
            this.location = _data["location"];
            this.sessionId = _data["sessionId"];
            this.signInType = _data["signInType"];
            this.review = _data["review"];
            this.countryIsoCode = _data["countryIsoCode"];
            this.deviceId = _data["deviceId"];
            this.grantType = _data["grantType"];
            this.coordinates = _data["coordinates"];
            this.extraData = _data["extraData"] ? SignInLogEntryExtraData.fromJS(_data["extraData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SignInLogEntry {
        data = typeof data === 'object' ? data : {};
        let result = new SignInLogEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["actionName"] = this.actionName;
        data["eventType"] = this.eventType;
        data["applicationId"] = this.applicationId;
        data["applicationName"] = this.applicationName;
        data["subjectId"] = this.subjectId;
        data["subjectName"] = this.subjectName;
        data["resourceId"] = this.resourceId;
        data["resourceType"] = this.resourceType;
        data["description"] = this.description;
        data["succeeded"] = this.succeeded;
        data["ipAddress"] = this.ipAddress;
        data["requestId"] = this.requestId;
        data["location"] = this.location;
        data["sessionId"] = this.sessionId;
        data["signInType"] = this.signInType;
        data["review"] = this.review;
        data["countryIsoCode"] = this.countryIsoCode;
        data["deviceId"] = this.deviceId;
        data["grantType"] = this.grantType;
        data["coordinates"] = this.coordinates;
        data["extraData"] = this.extraData ? this.extraData.toJSON() : <any>undefined;
        return data;
    }
}

/** A model representing a user's sign in log entry. */
export interface ISignInLogEntry {
    /** The unique id of the user's sign in log entry. */
    id?: string;
    /** A timestamp that indicates when the user's sign in log entry occurred. */
    createdAt?: Date;
    /** The name of the action. */
    actionName?: string | undefined;
    eventType?: SignInLogEventType;
    /** The unique identifier of the application. */
    applicationId?: string | undefined;
    /** The display name of the application. */
    applicationName?: string | undefined;
    /** The unique identifier of the subject. */
    subjectId?: string | undefined;
    /** The display name of the subject. */
    subjectName?: string | undefined;
    /** The unique identifier of the resource. */
    resourceId?: string | undefined;
    /** The name of the resource. */
    resourceType?: string | undefined;
    /** A friendly text describing the log entry. */
    description?: string | undefined;
    /** Indicates whether the operation that caused the user's sign in log entry was successful or not. */
    succeeded?: boolean;
    /** The IP address of the client. */
    ipAddress?: string | undefined;
    /** The unique identifier of the current request. */
    requestId?: string | undefined;
    /** The estimated client location based on the Indice.Features.Identity.SignInLogs.Models.SignInLogEntry.IpAddress. */
    location?: string | undefined;
    /** User's session id. */
    sessionId?: string | undefined;
    signInType?: SignInType;
    /** Indicates whether the specified log entry is marked for review. */
    review?: boolean;
    /** Two letter ISO code for the country. */
    countryIsoCode?: string | undefined;
    /** The device id. */
    deviceId?: string | undefined;
    /** The grant type used for the login. */
    grantType?: string | undefined;
    /** The approximate location of the operation. */
    coordinates?: string | undefined;
    extraData?: SignInLogEntryExtraData;
}

/** Models a user agent (browser) type. */
export class SignInLogEntryDevice implements ISignInLogEntryDevice {
    /** The device model. */
    model?: string | undefined;
    platform?: DevicePlatform;
    /** The raw value of the 'UserAgent' header. */
    userAgent?: string | undefined;
    /** Browser display name. */
    displayName?: string | undefined;
    /** The operating system name. */
    os?: string | undefined;

    constructor(data?: ISignInLogEntryDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.model = _data["model"];
            this.platform = _data["platform"];
            this.userAgent = _data["userAgent"];
            this.displayName = _data["displayName"];
            this.os = _data["os"];
        }
    }

    static fromJS(data: any): SignInLogEntryDevice {
        data = typeof data === 'object' ? data : {};
        let result = new SignInLogEntryDevice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["model"] = this.model;
        data["platform"] = this.platform;
        data["userAgent"] = this.userAgent;
        data["displayName"] = this.displayName;
        data["os"] = this.os;
        return data;
    }
}

/** Models a user agent (browser) type. */
export interface ISignInLogEntryDevice {
    /** The device model. */
    model?: string | undefined;
    platform?: DevicePlatform;
    /** The raw value of the 'UserAgent' header. */
    userAgent?: string | undefined;
    /** Browser display name. */
    displayName?: string | undefined;
    /** The operating system name. */
    os?: string | undefined;
}

/** Additional information about the user's sign in log entry. */
export class SignInLogEntryExtraData implements ISignInLogEntryExtraData {
    /** Gets the server process identifier. */
    processId?: number;
    /** Gets the redirect URI. */
    redirectUri?: string | undefined;
    /** Gets the requested scopes. */
    scope?: string | undefined;
    /** Gets the tokens. */
    tokens?: SignInLogEntryToken[] | undefined;
    /** Gets the error. */
    error?: string | undefined;
    /** Gets the error description. */
    errorDescription?: string | undefined;
    /** Gets the provider. */
    provider?: string | undefined;
    device?: SignInLogEntryDevice;
    userDevice?: SignInLogEntryUserDevice;
    warning?: SignInWarning;
    /** The name of the original event occurred. */
    originalEventType?: string | undefined;
    /** List of authentication methods used. */
    authenticationMethods?: string[] | undefined;

    constructor(data?: ISignInLogEntryExtraData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processId = _data["processId"];
            this.redirectUri = _data["redirectUri"];
            this.scope = _data["scope"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens!.push(SignInLogEntryToken.fromJS(item));
            }
            this.error = _data["error"];
            this.errorDescription = _data["errorDescription"];
            this.provider = _data["provider"];
            this.device = _data["device"] ? SignInLogEntryDevice.fromJS(_data["device"]) : <any>undefined;
            this.userDevice = _data["userDevice"] ? SignInLogEntryUserDevice.fromJS(_data["userDevice"]) : <any>undefined;
            this.warning = _data["warning"];
            this.originalEventType = _data["originalEventType"];
            if (Array.isArray(_data["authenticationMethods"])) {
                this.authenticationMethods = [] as any;
                for (let item of _data["authenticationMethods"])
                    this.authenticationMethods!.push(item);
            }
        }
    }

    static fromJS(data: any): SignInLogEntryExtraData {
        data = typeof data === 'object' ? data : {};
        let result = new SignInLogEntryExtraData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processId"] = this.processId;
        data["redirectUri"] = this.redirectUri;
        data["scope"] = this.scope;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["error"] = this.error;
        data["errorDescription"] = this.errorDescription;
        data["provider"] = this.provider;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["userDevice"] = this.userDevice ? this.userDevice.toJSON() : <any>undefined;
        data["warning"] = this.warning;
        data["originalEventType"] = this.originalEventType;
        if (Array.isArray(this.authenticationMethods)) {
            data["authenticationMethods"] = [];
            for (let item of this.authenticationMethods)
                data["authenticationMethods"].push(item);
        }
        return data;
    }
}

/** Additional information about the user's sign in log entry. */
export interface ISignInLogEntryExtraData {
    /** Gets the server process identifier. */
    processId?: number;
    /** Gets the redirect URI. */
    redirectUri?: string | undefined;
    /** Gets the requested scopes. */
    scope?: string | undefined;
    /** Gets the tokens. */
    tokens?: SignInLogEntryToken[] | undefined;
    /** Gets the error. */
    error?: string | undefined;
    /** Gets the error description. */
    errorDescription?: string | undefined;
    /** Gets the provider. */
    provider?: string | undefined;
    device?: SignInLogEntryDevice;
    userDevice?: SignInLogEntryUserDevice;
    warning?: SignInWarning;
    /** The name of the original event occurred. */
    originalEventType?: string | undefined;
    /** List of authentication methods used. */
    authenticationMethods?: string[] | undefined;
}

/** Request model for updating a Indice.Features.Identity.SignInLogs.Models.SignInLogEntry instance. */
export class SignInLogEntryRequest implements ISignInLogEntryRequest {
    /** Indicates whether we need to mark the specified log entry for review. */
    review?: boolean;
    /** An optional comment when a log entry is marked for review. */
    reviewComment?: string | undefined;

    constructor(data?: ISignInLogEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.review = _data["review"];
            this.reviewComment = _data["reviewComment"];
        }
    }

    static fromJS(data: any): SignInLogEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignInLogEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["review"] = this.review;
        data["reviewComment"] = this.reviewComment;
        return data;
    }
}

/** Request model for updating a Indice.Features.Identity.SignInLogs.Models.SignInLogEntry instance. */
export interface ISignInLogEntryRequest {
    /** Indicates whether we need to mark the specified log entry for review. */
    review?: boolean;
    /** An optional comment when a log entry is marked for review. */
    reviewComment?: string | undefined;
}

export class SignInLogEntryResultSet implements ISignInLogEntryResultSet {
    count?: number;
    items?: SignInLogEntry[] | undefined;

    constructor(data?: ISignInLogEntryResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SignInLogEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SignInLogEntryResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new SignInLogEntryResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISignInLogEntryResultSet {
    count?: number;
    items?: SignInLogEntry[] | undefined;
}

/** Data structure for issued tokens. */
export class SignInLogEntryToken implements ISignInLogEntryToken {
    /** Gets the type of the token. */
    tokenType?: string | undefined;
    /** Gets the token value. */
    tokenValue?: string | undefined;

    constructor(data?: ISignInLogEntryToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tokenType = _data["tokenType"];
            this.tokenValue = _data["tokenValue"];
        }
    }

    static fromJS(data: any): SignInLogEntryToken {
        data = typeof data === 'object' ? data : {};
        let result = new SignInLogEntryToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenType"] = this.tokenType;
        data["tokenValue"] = this.tokenValue;
        return data;
    }
}

/** Data structure for issued tokens. */
export interface ISignInLogEntryToken {
    /** Gets the type of the token. */
    tokenType?: string | undefined;
    /** Gets the token value. */
    tokenValue?: string | undefined;
}

/** User devices representation. */
export class SignInLogEntryUserDevice implements ISignInLogEntryUserDevice {
    /** The primary key. */
    id?: string;
    platform?: DevicePlatform;
    /** Device name. */
    name?: string | undefined;
    /** Device model. */
    model?: string | undefined;
    /** Device OS version. */
    osVersion?: string | undefined;
    /** The date this device was created. */
    dateCreated?: Date;
    /** Gets or sets the date and time, in UTC, when the device last signed in. */
    lastSignInDate?: Date | undefined;
    /** Flag that determines if push notifications are enabled for this device. */
    isPushNotificationsEnabled?: boolean;
    /** Flag for pin support. */
    supportsPinLogin?: boolean;
    /** Flag for fingerprint support. */
    supportsFingerprintLogin?: boolean;
    /** Extra metadata for the device. */
    data?: any | undefined;
    /** Device tags */
    tags?: string[] | undefined;
    /** Indicates whether the device is blocked. */
    requiresPassword?: boolean;
    /** Indicates whether the device is a trusted device (i.e. capable of strong customer authentication scenarios). */
    isTrusted?: boolean;
    /** The date that the device can be activated for trust. */
    trustActivationDate?: Date | undefined;
    /** Determines whether the device is pending trust activation. */
    isPendingTrustActivation?: boolean;
    /** Indicates whether device is blocked for any action. */
    blocked?: boolean;
    clientType?: DeviceClientType;
    /** The date until the client is remembered by the system and MFA is not asked. */
    mfaSessionExpirationDate?: Date | undefined;

    constructor(data?: ISignInLogEntryUserDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.platform = _data["platform"];
            this.name = _data["name"];
            this.model = _data["model"];
            this.osVersion = _data["osVersion"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.lastSignInDate = _data["lastSignInDate"] ? new Date(_data["lastSignInDate"].toString()) : <any>undefined;
            this.isPushNotificationsEnabled = _data["isPushNotificationsEnabled"];
            this.supportsPinLogin = _data["supportsPinLogin"];
            this.supportsFingerprintLogin = _data["supportsFingerprintLogin"];
            this.data = _data["data"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.requiresPassword = _data["requiresPassword"];
            this.isTrusted = _data["isTrusted"];
            this.trustActivationDate = _data["trustActivationDate"] ? new Date(_data["trustActivationDate"].toString()) : <any>undefined;
            this.isPendingTrustActivation = _data["isPendingTrustActivation"];
            this.blocked = _data["blocked"];
            this.clientType = _data["clientType"];
            this.mfaSessionExpirationDate = _data["mfaSessionExpirationDate"] ? new Date(_data["mfaSessionExpirationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SignInLogEntryUserDevice {
        data = typeof data === 'object' ? data : {};
        let result = new SignInLogEntryUserDevice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["platform"] = this.platform;
        data["name"] = this.name;
        data["model"] = this.model;
        data["osVersion"] = this.osVersion;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["lastSignInDate"] = this.lastSignInDate ? this.lastSignInDate.toISOString() : <any>undefined;
        data["isPushNotificationsEnabled"] = this.isPushNotificationsEnabled;
        data["supportsPinLogin"] = this.supportsPinLogin;
        data["supportsFingerprintLogin"] = this.supportsFingerprintLogin;
        data["data"] = this.data;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["requiresPassword"] = this.requiresPassword;
        data["isTrusted"] = this.isTrusted;
        data["trustActivationDate"] = this.trustActivationDate ? this.trustActivationDate.toISOString() : <any>undefined;
        data["isPendingTrustActivation"] = this.isPendingTrustActivation;
        data["blocked"] = this.blocked;
        data["clientType"] = this.clientType;
        data["mfaSessionExpirationDate"] = this.mfaSessionExpirationDate ? this.mfaSessionExpirationDate.toISOString() : <any>undefined;
        return data;
    }
}

/** User devices representation. */
export interface ISignInLogEntryUserDevice {
    /** The primary key. */
    id?: string;
    platform?: DevicePlatform;
    /** Device name. */
    name?: string | undefined;
    /** Device model. */
    model?: string | undefined;
    /** Device OS version. */
    osVersion?: string | undefined;
    /** The date this device was created. */
    dateCreated?: Date;
    /** Gets or sets the date and time, in UTC, when the device last signed in. */
    lastSignInDate?: Date | undefined;
    /** Flag that determines if push notifications are enabled for this device. */
    isPushNotificationsEnabled?: boolean;
    /** Flag for pin support. */
    supportsPinLogin?: boolean;
    /** Flag for fingerprint support. */
    supportsFingerprintLogin?: boolean;
    /** Extra metadata for the device. */
    data?: any | undefined;
    /** Device tags */
    tags?: string[] | undefined;
    /** Indicates whether the device is blocked. */
    requiresPassword?: boolean;
    /** Indicates whether the device is a trusted device (i.e. capable of strong customer authentication scenarios). */
    isTrusted?: boolean;
    /** The date that the device can be activated for trust. */
    trustActivationDate?: Date | undefined;
    /** Determines whether the device is pending trust activation. */
    isPendingTrustActivation?: boolean;
    /** Indicates whether device is blocked for any action. */
    blocked?: boolean;
    clientType?: DeviceClientType;
    /** The date until the client is remembered by the system and MFA is not asked. */
    mfaSessionExpirationDate?: Date | undefined;
}

/** The type of event for sign in log. */
export enum SignInLogEventType {
    TokenIssued = "TokenIssued",
    UserLoginCompleted = "UserLoginCompleted",
    UserPasswordValidationCompleted = "UserPasswordValidationCompleted",
}

/** Describes the user sign in type in terms of user presence. */
export enum SignInType {
    Interactive = "Interactive",
    NonInteractive = "NonInteractive",
}

export enum SignInWarning {
    ImpossibleTravel = "ImpossibleTravel",
}

/** Models a system client when API provides info for a single client. */
export class SingleClientInfo implements ISingleClientInfo {
    /** The unique identifier for this application. */
    clientId?: string | undefined;
    /** Application name that will be seen on consent screens. */
    clientName?: string | undefined;
    /** Application description. */
    description?: string | undefined;
    /** Determines whether this application is enabled or not. */
    enabled?: boolean | undefined;
    /** Specifies whether a consent screen is required. */
    requireConsent?: boolean | undefined;
    /** Specifies whether consent screen is remembered after having been given. */
    allowRememberConsent?: boolean | undefined;
    /** Application logo that will be seen on consent screens. */
    logoUri?: string | undefined;
    /** Application URL that will be seen on consent screens. */
    clientUri?: string | undefined;
    /** Specifies whether the client can be edited or not. */
    nonEditable?: boolean;
    /** Lifetime of identity token in seconds. */
    identityTokenLifetime?: number | undefined;
    /** Lifetime of access token in seconds. */
    accessTokenLifetime?: number | undefined;
    /** Maximum lifetime of a refresh token in seconds. */
    absoluteRefreshTokenLifetime?: number | undefined;
    /** Lifetime of a user consent in seconds. */
    consentLifetime?: number | undefined;
    /** The maximum duration (in seconds) since the last time the user authenticated. */
    userSsoLifetime?: number | undefined;
    /** Specifies logout URI at client for HTTP front-channel based logout. */
    frontChannelLogoutUri?: string | undefined;
    /** Gets or sets a salt value used in pair-wise subjectId generation for users of this client. */
    pairWiseSubjectSalt?: string | undefined;
    accessTokenType?: AccessTokenType;
    refreshTokenUsage?: TokenUsage;
    refreshTokenExpiration?: TokenExpiration;
    /** Gets or sets a value indicating whether to allow offline access. */
    allowOfflineAccess?: boolean | undefined;
    /** Gets or sets a value indicating whether the access token (and its claims) should be updated on a refresh token request. */
    updateAccessTokenClaimsOnRefresh?: boolean | undefined;
    /** Specifies if the user's session id should be sent to the FrontChannelLogoutUri. */
    frontChannelLogoutSessionRequired?: boolean | undefined;
    /** Gets or sets a value indicating whether JWT access tokens should include an identifier. */
    includeJwtId?: boolean | undefined;
    /** Controls whether access tokens are transmitted via the browser for this client. This can prevent accidental leakage of access tokens when multiple response types are allowed. */
    allowAccessTokensViaBrowser?: boolean | undefined;
    /** When requesting both an id token and access token, should the user claims always be added to the id token instead of requiring the client to use the user-info endpoint. */
    alwaysIncludeUserClaimsInIdToken?: boolean | undefined;
    /** Gets or sets a value indicating whether client claims should be always included in the access tokens - or only for client credentials flow. */
    alwaysSendClientClaims?: boolean | undefined;
    /** Lifetime of authorization code in seconds. */
    authorizationCodeLifetime?: number | undefined;
    /** Specifies whether a proof key is required for authorization code based token requests. */
    requirePkce?: boolean | undefined;
    /** Specifies whether a proof key can be sent using plain method. */
    allowPlainTextPkce?: boolean | undefined;
    /** Gets or sets a value to prefix it on client claim types. */
    clientClaimsPrefix?: string | undefined;
    /** Specifies logout URI at client for HTTP back-channel based logout. */
    backChannelLogoutUri?: string | undefined;
    /** If the user's session id should be sent to the Indice.Features.Identity.Server.Manager.Models.SingleClientInfo.FrontChannelLogoutUri. Defaults to true */
    backChannelLogoutSessionRequired?: boolean;
    /** Gets or sets the type of the device flow user code. */
    userCodeType?: string | undefined;
    /** Sliding lifetime of a refresh token in seconds. Defaults to 1296000 seconds / 15 days. */
    slidingRefreshTokenLifetime?: number;
    /** Gets or sets the device code lifetime. */
    deviceCodeLifetime?: number | undefined;
    /** List of client claims. */
    claims?: ClaimInfo[] | undefined;
    /** List of configured grant types. */
    grantTypes?: string[] | undefined;
    /** List of available client secrets. */
    secrets?: ClientSecretInfo[] | undefined;
    /** CORS origins allowed. */
    allowedCorsOrigins?: string[] | undefined;
    /** Allowed URIs to redirect after logout. */
    postLogoutRedirectUris?: string[] | undefined;
    /** Allowed URIs to redirect after successful login. */
    redirectUris?: string[] | undefined;
    /** The API resources that the client has access to. */
    apiResources?: string[] | undefined;
    /** The identity resources that the client has access to. */
    identityResources?: string[] | undefined;
    /** Translations. */
    translations?: { [key: string]: ClientTranslation; } | undefined;
    /** Determines whether login using a local account is allowed for this client. */
    enableLocalLogin?: boolean;
    /** List of identity providers that are not allowed for this client. */
    identityProviderRestrictions?: string[] | undefined;

    constructor(data?: ISingleClientInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.description = _data["description"];
            this.enabled = _data["enabled"];
            this.requireConsent = _data["requireConsent"];
            this.allowRememberConsent = _data["allowRememberConsent"];
            this.logoUri = _data["logoUri"];
            this.clientUri = _data["clientUri"];
            this.nonEditable = _data["nonEditable"];
            this.identityTokenLifetime = _data["identityTokenLifetime"];
            this.accessTokenLifetime = _data["accessTokenLifetime"];
            this.absoluteRefreshTokenLifetime = _data["absoluteRefreshTokenLifetime"];
            this.consentLifetime = _data["consentLifetime"];
            this.userSsoLifetime = _data["userSsoLifetime"];
            this.frontChannelLogoutUri = _data["frontChannelLogoutUri"];
            this.pairWiseSubjectSalt = _data["pairWiseSubjectSalt"];
            this.accessTokenType = _data["accessTokenType"];
            this.refreshTokenUsage = _data["refreshTokenUsage"];
            this.refreshTokenExpiration = _data["refreshTokenExpiration"];
            this.allowOfflineAccess = _data["allowOfflineAccess"];
            this.updateAccessTokenClaimsOnRefresh = _data["updateAccessTokenClaimsOnRefresh"];
            this.frontChannelLogoutSessionRequired = _data["frontChannelLogoutSessionRequired"];
            this.includeJwtId = _data["includeJwtId"];
            this.allowAccessTokensViaBrowser = _data["allowAccessTokensViaBrowser"];
            this.alwaysIncludeUserClaimsInIdToken = _data["alwaysIncludeUserClaimsInIdToken"];
            this.alwaysSendClientClaims = _data["alwaysSendClientClaims"];
            this.authorizationCodeLifetime = _data["authorizationCodeLifetime"];
            this.requirePkce = _data["requirePkce"];
            this.allowPlainTextPkce = _data["allowPlainTextPkce"];
            this.clientClaimsPrefix = _data["clientClaimsPrefix"];
            this.backChannelLogoutUri = _data["backChannelLogoutUri"];
            this.backChannelLogoutSessionRequired = _data["backChannelLogoutSessionRequired"];
            this.userCodeType = _data["userCodeType"];
            this.slidingRefreshTokenLifetime = _data["slidingRefreshTokenLifetime"];
            this.deviceCodeLifetime = _data["deviceCodeLifetime"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(ClaimInfo.fromJS(item));
            }
            if (Array.isArray(_data["grantTypes"])) {
                this.grantTypes = [] as any;
                for (let item of _data["grantTypes"])
                    this.grantTypes!.push(item);
            }
            if (Array.isArray(_data["secrets"])) {
                this.secrets = [] as any;
                for (let item of _data["secrets"])
                    this.secrets!.push(ClientSecretInfo.fromJS(item));
            }
            if (Array.isArray(_data["allowedCorsOrigins"])) {
                this.allowedCorsOrigins = [] as any;
                for (let item of _data["allowedCorsOrigins"])
                    this.allowedCorsOrigins!.push(item);
            }
            if (Array.isArray(_data["postLogoutRedirectUris"])) {
                this.postLogoutRedirectUris = [] as any;
                for (let item of _data["postLogoutRedirectUris"])
                    this.postLogoutRedirectUris!.push(item);
            }
            if (Array.isArray(_data["redirectUris"])) {
                this.redirectUris = [] as any;
                for (let item of _data["redirectUris"])
                    this.redirectUris!.push(item);
            }
            if (Array.isArray(_data["apiResources"])) {
                this.apiResources = [] as any;
                for (let item of _data["apiResources"])
                    this.apiResources!.push(item);
            }
            if (Array.isArray(_data["identityResources"])) {
                this.identityResources = [] as any;
                for (let item of _data["identityResources"])
                    this.identityResources!.push(item);
            }
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? ClientTranslation.fromJS(_data["translations"][key]) : new ClientTranslation();
                }
            }
            this.enableLocalLogin = _data["enableLocalLogin"];
            if (Array.isArray(_data["identityProviderRestrictions"])) {
                this.identityProviderRestrictions = [] as any;
                for (let item of _data["identityProviderRestrictions"])
                    this.identityProviderRestrictions!.push(item);
            }
        }
    }

    static fromJS(data: any): SingleClientInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SingleClientInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["description"] = this.description;
        data["enabled"] = this.enabled;
        data["requireConsent"] = this.requireConsent;
        data["allowRememberConsent"] = this.allowRememberConsent;
        data["logoUri"] = this.logoUri;
        data["clientUri"] = this.clientUri;
        data["nonEditable"] = this.nonEditable;
        data["identityTokenLifetime"] = this.identityTokenLifetime;
        data["accessTokenLifetime"] = this.accessTokenLifetime;
        data["absoluteRefreshTokenLifetime"] = this.absoluteRefreshTokenLifetime;
        data["consentLifetime"] = this.consentLifetime;
        data["userSsoLifetime"] = this.userSsoLifetime;
        data["frontChannelLogoutUri"] = this.frontChannelLogoutUri;
        data["pairWiseSubjectSalt"] = this.pairWiseSubjectSalt;
        data["accessTokenType"] = this.accessTokenType;
        data["refreshTokenUsage"] = this.refreshTokenUsage;
        data["refreshTokenExpiration"] = this.refreshTokenExpiration;
        data["allowOfflineAccess"] = this.allowOfflineAccess;
        data["updateAccessTokenClaimsOnRefresh"] = this.updateAccessTokenClaimsOnRefresh;
        data["frontChannelLogoutSessionRequired"] = this.frontChannelLogoutSessionRequired;
        data["includeJwtId"] = this.includeJwtId;
        data["allowAccessTokensViaBrowser"] = this.allowAccessTokensViaBrowser;
        data["alwaysIncludeUserClaimsInIdToken"] = this.alwaysIncludeUserClaimsInIdToken;
        data["alwaysSendClientClaims"] = this.alwaysSendClientClaims;
        data["authorizationCodeLifetime"] = this.authorizationCodeLifetime;
        data["requirePkce"] = this.requirePkce;
        data["allowPlainTextPkce"] = this.allowPlainTextPkce;
        data["clientClaimsPrefix"] = this.clientClaimsPrefix;
        data["backChannelLogoutUri"] = this.backChannelLogoutUri;
        data["backChannelLogoutSessionRequired"] = this.backChannelLogoutSessionRequired;
        data["userCodeType"] = this.userCodeType;
        data["slidingRefreshTokenLifetime"] = this.slidingRefreshTokenLifetime;
        data["deviceCodeLifetime"] = this.deviceCodeLifetime;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.grantTypes)) {
            data["grantTypes"] = [];
            for (let item of this.grantTypes)
                data["grantTypes"].push(item);
        }
        if (Array.isArray(this.secrets)) {
            data["secrets"] = [];
            for (let item of this.secrets)
                data["secrets"].push(item.toJSON());
        }
        if (Array.isArray(this.allowedCorsOrigins)) {
            data["allowedCorsOrigins"] = [];
            for (let item of this.allowedCorsOrigins)
                data["allowedCorsOrigins"].push(item);
        }
        if (Array.isArray(this.postLogoutRedirectUris)) {
            data["postLogoutRedirectUris"] = [];
            for (let item of this.postLogoutRedirectUris)
                data["postLogoutRedirectUris"].push(item);
        }
        if (Array.isArray(this.redirectUris)) {
            data["redirectUris"] = [];
            for (let item of this.redirectUris)
                data["redirectUris"].push(item);
        }
        if (Array.isArray(this.apiResources)) {
            data["apiResources"] = [];
            for (let item of this.apiResources)
                data["apiResources"].push(item);
        }
        if (Array.isArray(this.identityResources)) {
            data["identityResources"] = [];
            for (let item of this.identityResources)
                data["identityResources"].push(item);
        }
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        data["enableLocalLogin"] = this.enableLocalLogin;
        if (Array.isArray(this.identityProviderRestrictions)) {
            data["identityProviderRestrictions"] = [];
            for (let item of this.identityProviderRestrictions)
                data["identityProviderRestrictions"].push(item);
        }
        return data;
    }
}

/** Models a system client when API provides info for a single client. */
export interface ISingleClientInfo {
    /** The unique identifier for this application. */
    clientId?: string | undefined;
    /** Application name that will be seen on consent screens. */
    clientName?: string | undefined;
    /** Application description. */
    description?: string | undefined;
    /** Determines whether this application is enabled or not. */
    enabled?: boolean | undefined;
    /** Specifies whether a consent screen is required. */
    requireConsent?: boolean | undefined;
    /** Specifies whether consent screen is remembered after having been given. */
    allowRememberConsent?: boolean | undefined;
    /** Application logo that will be seen on consent screens. */
    logoUri?: string | undefined;
    /** Application URL that will be seen on consent screens. */
    clientUri?: string | undefined;
    /** Specifies whether the client can be edited or not. */
    nonEditable?: boolean;
    /** Lifetime of identity token in seconds. */
    identityTokenLifetime?: number | undefined;
    /** Lifetime of access token in seconds. */
    accessTokenLifetime?: number | undefined;
    /** Maximum lifetime of a refresh token in seconds. */
    absoluteRefreshTokenLifetime?: number | undefined;
    /** Lifetime of a user consent in seconds. */
    consentLifetime?: number | undefined;
    /** The maximum duration (in seconds) since the last time the user authenticated. */
    userSsoLifetime?: number | undefined;
    /** Specifies logout URI at client for HTTP front-channel based logout. */
    frontChannelLogoutUri?: string | undefined;
    /** Gets or sets a salt value used in pair-wise subjectId generation for users of this client. */
    pairWiseSubjectSalt?: string | undefined;
    accessTokenType?: AccessTokenType;
    refreshTokenUsage?: TokenUsage;
    refreshTokenExpiration?: TokenExpiration;
    /** Gets or sets a value indicating whether to allow offline access. */
    allowOfflineAccess?: boolean | undefined;
    /** Gets or sets a value indicating whether the access token (and its claims) should be updated on a refresh token request. */
    updateAccessTokenClaimsOnRefresh?: boolean | undefined;
    /** Specifies if the user's session id should be sent to the FrontChannelLogoutUri. */
    frontChannelLogoutSessionRequired?: boolean | undefined;
    /** Gets or sets a value indicating whether JWT access tokens should include an identifier. */
    includeJwtId?: boolean | undefined;
    /** Controls whether access tokens are transmitted via the browser for this client. This can prevent accidental leakage of access tokens when multiple response types are allowed. */
    allowAccessTokensViaBrowser?: boolean | undefined;
    /** When requesting both an id token and access token, should the user claims always be added to the id token instead of requiring the client to use the user-info endpoint. */
    alwaysIncludeUserClaimsInIdToken?: boolean | undefined;
    /** Gets or sets a value indicating whether client claims should be always included in the access tokens - or only for client credentials flow. */
    alwaysSendClientClaims?: boolean | undefined;
    /** Lifetime of authorization code in seconds. */
    authorizationCodeLifetime?: number | undefined;
    /** Specifies whether a proof key is required for authorization code based token requests. */
    requirePkce?: boolean | undefined;
    /** Specifies whether a proof key can be sent using plain method. */
    allowPlainTextPkce?: boolean | undefined;
    /** Gets or sets a value to prefix it on client claim types. */
    clientClaimsPrefix?: string | undefined;
    /** Specifies logout URI at client for HTTP back-channel based logout. */
    backChannelLogoutUri?: string | undefined;
    /** If the user's session id should be sent to the Indice.Features.Identity.Server.Manager.Models.SingleClientInfo.FrontChannelLogoutUri. Defaults to true */
    backChannelLogoutSessionRequired?: boolean;
    /** Gets or sets the type of the device flow user code. */
    userCodeType?: string | undefined;
    /** Sliding lifetime of a refresh token in seconds. Defaults to 1296000 seconds / 15 days. */
    slidingRefreshTokenLifetime?: number;
    /** Gets or sets the device code lifetime. */
    deviceCodeLifetime?: number | undefined;
    /** List of client claims. */
    claims?: ClaimInfo[] | undefined;
    /** List of configured grant types. */
    grantTypes?: string[] | undefined;
    /** List of available client secrets. */
    secrets?: ClientSecretInfo[] | undefined;
    /** CORS origins allowed. */
    allowedCorsOrigins?: string[] | undefined;
    /** Allowed URIs to redirect after logout. */
    postLogoutRedirectUris?: string[] | undefined;
    /** Allowed URIs to redirect after successful login. */
    redirectUris?: string[] | undefined;
    /** The API resources that the client has access to. */
    apiResources?: string[] | undefined;
    /** The identity resources that the client has access to. */
    identityResources?: string[] | undefined;
    /** Translations. */
    translations?: { [key: string]: ClientTranslation; } | undefined;
    /** Determines whether login using a local account is allowed for this client. */
    enableLocalLogin?: boolean;
    /** List of identity providers that are not allowed for this client. */
    identityProviderRestrictions?: string[] | undefined;
}

/** Models an application user when API provides info for a single user. */
export class SingleUserInfo implements ISingleUserInfo {
    /** User's unique identifier. */
    id?: string | undefined;
    /** Indicates whether a user's email is confirmed or not. */
    emailConfirmed?: boolean;
    /** Indicates whether lockout feature is enabled for the user. */
    lockoutEnabled?: boolean;
    /** Indicates whether a user's phone number is confirmed or not. */
    phoneNumberConfirmed?: boolean;
    /** Indicates whether two-factor authentication is enabled for the user. */
    twoFactorEnabled?: boolean;
    /** The date-time where the user was created in the system. */
    createDate?: Date;
    /** The date-time where the lockout period ends. */
    lockoutEnd?: Date | undefined;
    /** Indicates that the user is Locked. */
    isLocked?: boolean;
    /** User's email address. */
    email?: string | undefined;
    /** User's phone number. */
    phoneNumber?: string | undefined;
    /** The username. */
    userName?: string | undefined;
    /** Indicates whether the user is forcefully blocked. */
    blocked?: boolean;
    passwordExpirationPolicy?: PasswordExpirationPolicy;
    /** Indicates whether the user is a system administrator. */
    isAdmin?: boolean;
    /** The number of failed login attempts for the user. */
    accessFailedCount?: number;
    /** Gets or sets the date and time, in UTC, when the user last signed in. */
    lastSignInDate?: Date | undefined;
    /** If set, it represents the date when the current password will expire. */
    passwordExpirationDate?: Date | undefined;
    /** The names of the roles that the user belongs to. */
    roles?: string[] | undefined;
    /** User metadata expressed as claims. */
    claims?: ClaimInfo[] | undefined;

    constructor(data?: ISingleUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            (<any>this).isLocked = _data["isLocked"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.userName = _data["userName"];
            this.blocked = _data["blocked"];
            this.passwordExpirationPolicy = _data["passwordExpirationPolicy"];
            this.isAdmin = _data["isAdmin"];
            this.accessFailedCount = _data["accessFailedCount"];
            this.lastSignInDate = _data["lastSignInDate"] ? new Date(_data["lastSignInDate"].toString()) : <any>undefined;
            this.passwordExpirationDate = _data["passwordExpirationDate"] ? new Date(_data["passwordExpirationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(ClaimInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SingleUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SingleUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailConfirmed"] = this.emailConfirmed;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["isLocked"] = this.isLocked;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["userName"] = this.userName;
        data["blocked"] = this.blocked;
        data["passwordExpirationPolicy"] = this.passwordExpirationPolicy;
        data["isAdmin"] = this.isAdmin;
        data["accessFailedCount"] = this.accessFailedCount;
        data["lastSignInDate"] = this.lastSignInDate ? this.lastSignInDate.toISOString() : <any>undefined;
        data["passwordExpirationDate"] = this.passwordExpirationDate ? this.passwordExpirationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        return data;
    }
}

/** Models an application user when API provides info for a single user. */
export interface ISingleUserInfo {
    /** User's unique identifier. */
    id?: string | undefined;
    /** Indicates whether a user's email is confirmed or not. */
    emailConfirmed?: boolean;
    /** Indicates whether lockout feature is enabled for the user. */
    lockoutEnabled?: boolean;
    /** Indicates whether a user's phone number is confirmed or not. */
    phoneNumberConfirmed?: boolean;
    /** Indicates whether two-factor authentication is enabled for the user. */
    twoFactorEnabled?: boolean;
    /** The date-time where the user was created in the system. */
    createDate?: Date;
    /** The date-time where the lockout period ends. */
    lockoutEnd?: Date | undefined;
    /** Indicates that the user is Locked. */
    isLocked?: boolean;
    /** User's email address. */
    email?: string | undefined;
    /** User's phone number. */
    phoneNumber?: string | undefined;
    /** The username. */
    userName?: string | undefined;
    /** Indicates whether the user is forcefully blocked. */
    blocked?: boolean;
    passwordExpirationPolicy?: PasswordExpirationPolicy;
    /** Indicates whether the user is a system administrator. */
    isAdmin?: boolean;
    /** The number of failed login attempts for the user. */
    accessFailedCount?: number;
    /** Gets or sets the date and time, in UTC, when the user last signed in. */
    lastSignInDate?: Date | undefined;
    /** If set, it represents the date when the current password will expire. */
    passwordExpirationDate?: Date | undefined;
    /** The names of the roles that the user belongs to. */
    roles?: string[] | undefined;
    /** User metadata expressed as claims. */
    claims?: ClaimInfo[] | undefined;
}

/** Contains summary information about the system. */
export class SummaryInfo implements ISummaryInfo {
    /** Indicates the point in time where the statistics where last updated. */
    lastUpdatedAt?: Date;
    /** The total number of users. */
    totalUsers?: number;
    /** The total number of clients. */
    totalClients?: number;
    /** The total number of roles. */
    totalRoles?: number;
    activity?: UsersActivityInfo;
    stats?: UsersStatisticsInfo;

    constructor(data?: ISummaryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lastUpdatedAt = _data["lastUpdatedAt"] ? new Date(_data["lastUpdatedAt"].toString()) : <any>undefined;
            this.totalUsers = _data["totalUsers"];
            this.totalClients = _data["totalClients"];
            this.totalRoles = _data["totalRoles"];
            this.activity = _data["activity"] ? UsersActivityInfo.fromJS(_data["activity"]) : <any>undefined;
            this.stats = _data["stats"] ? UsersStatisticsInfo.fromJS(_data["stats"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SummaryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SummaryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastUpdatedAt"] = this.lastUpdatedAt ? this.lastUpdatedAt.toISOString() : <any>undefined;
        data["totalUsers"] = this.totalUsers;
        data["totalClients"] = this.totalClients;
        data["totalRoles"] = this.totalRoles;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["stats"] = this.stats ? this.stats.toJSON() : <any>undefined;
        return data;
    }
}

/** Contains summary information about the system. */
export interface ISummaryInfo {
    /** Indicates the point in time where the statistics where last updated. */
    lastUpdatedAt?: Date;
    /** The total number of users. */
    totalUsers?: number;
    /** The total number of clients. */
    totalClients?: number;
    /** The total number of roles. */
    totalRoles?: number;
    activity?: UsersActivityInfo;
    stats?: UsersStatisticsInfo;
}

/** Models a statistic value, */
export class SummaryStatistic implements ISummaryStatistic {
    /** The count. */
    count?: number;
    /** The percent. */
    percent?: number;

    constructor(data?: ISummaryStatistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            this.percent = _data["percent"];
        }
    }

    static fromJS(data: any): SummaryStatistic {
        data = typeof data === 'object' ? data : {};
        let result = new SummaryStatistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["percent"] = this.percent;
        return data;
    }
}

/** Models a statistic value, */
export interface ISummaryStatistic {
    /** The count. */
    count?: number;
    /** The percent. */
    percent?: number;
}

export enum TokenExpiration {
    Sliding = "Sliding",
    Absolute = "Absolute",
}

export enum TokenUsage {
    ReUse = "ReUse",
    OneTimeOnly = "OneTimeOnly",
}

export enum TotpDeliveryChannel {
    Sms = "Sms",
    Email = "Email",
    Telephone = "Telephone",
    Viber = "Viber",
    EToken = "EToken",
    PushNotification = "PushNotification",
    None = "None",
}

/** Request object used by an authenticated user in order to get a new Time base one time access token via one of the supported MFA mechanisms. */
export class TotpRequest implements ITotpRequest {
    channel?: TotpDeliveryChannel;
    /** Optionally pass the reason to generate the TOTP. */
    purpose?: string | undefined;
    /** The message to be sent in the SMS/Viber or PushNotification. It's important for the message to contain the {0} placeholder in the position where the OTP should be placed. */
    message?: string | undefined;
    /** The payload data in JSON string to be sent in the Push Notification. */
    data?: any | undefined;
    /** The type of the Push Notification. */
    classification?: string | undefined;
    /** The subject of the message for the Indice.Services.TotpDeliveryChannel.PushNotificationIndice.Features.Identity.Server.Totp.Models.TotpRequest.Channel. */
    subject?: string | undefined;
    /** The user authentication method to be used. */
    authenticationMethod?: string | undefined;
    /** The email template to be used when Indice.Features.Identity.Server.Totp.Models.TotpRequest.Channel is Indice.Services.TotpDeliveryChannel.Email or when Indice.Features.Identity.Server.Totp.Models.TotpRequest.AuthenticationMethod has a relevant channel. */
    emailTemplate?: string | undefined;

    constructor(data?: ITotpRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.channel = _data["channel"];
            this.purpose = _data["purpose"];
            this.message = _data["message"];
            this.data = _data["data"];
            this.classification = _data["classification"];
            this.subject = _data["subject"];
            this.authenticationMethod = _data["authenticationMethod"];
            this.emailTemplate = _data["emailTemplate"];
        }
    }

    static fromJS(data: any): TotpRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TotpRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["channel"] = this.channel;
        data["purpose"] = this.purpose;
        data["message"] = this.message;
        data["data"] = this.data;
        data["classification"] = this.classification;
        data["subject"] = this.subject;
        data["authenticationMethod"] = this.authenticationMethod;
        data["emailTemplate"] = this.emailTemplate;
        return data;
    }
}

/** Request object used by an authenticated user in order to get a new Time base one time access token via one of the supported MFA mechanisms. */
export interface ITotpRequest {
    channel?: TotpDeliveryChannel;
    /** Optionally pass the reason to generate the TOTP. */
    purpose?: string | undefined;
    /** The message to be sent in the SMS/Viber or PushNotification. It's important for the message to contain the {0} placeholder in the position where the OTP should be placed. */
    message?: string | undefined;
    /** The payload data in JSON string to be sent in the Push Notification. */
    data?: any | undefined;
    /** The type of the Push Notification. */
    classification?: string | undefined;
    /** The subject of the message for the Indice.Services.TotpDeliveryChannel.PushNotificationIndice.Features.Identity.Server.Totp.Models.TotpRequest.Channel. */
    subject?: string | undefined;
    /** The user authentication method to be used. */
    authenticationMethod?: string | undefined;
    /** The email template to be used when Indice.Features.Identity.Server.Totp.Models.TotpRequest.Channel is Indice.Services.TotpDeliveryChannel.Email or when Indice.Features.Identity.Server.Totp.Models.TotpRequest.AuthenticationMethod has a relevant channel. */
    emailTemplate?: string | undefined;
}

/** Verification request object. */
export class TotpVerificationRequest implements ITotpVerificationRequest {
    /** The TOTP code. */
    code!: string;
    /** Optionally pass the reason used to generate the TOTP. */
    purpose?: string | undefined;
    /** The user authentication method to be used. */
    authenticationMethod?: string | undefined;

    constructor(data?: ITotpVerificationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.purpose = _data["purpose"];
            this.authenticationMethod = _data["authenticationMethod"];
        }
    }

    static fromJS(data: any): TotpVerificationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TotpVerificationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["purpose"] = this.purpose;
        data["authenticationMethod"] = this.authenticationMethod;
        return data;
    }
}

/** Verification request object. */
export interface ITotpVerificationRequest {
    /** The TOTP code. */
    code: string;
    /** Optionally pass the reason used to generate the TOTP. */
    purpose?: string | undefined;
    /** The user authentication method to be used. */
    authenticationMethod?: string | undefined;
}

/** Trust device parameters payload. */
export class TrustDeviceRequest implements ITrustDeviceRequest {
    /** The id of the device to remove before trusting the defined device. */
    swapDeviceId?: string | undefined;

    constructor(data?: ITrustDeviceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.swapDeviceId = _data["swapDeviceId"];
        }
    }

    static fromJS(data: any): TrustDeviceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TrustDeviceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["swapDeviceId"] = this.swapDeviceId;
        return data;
    }
}

/** Trust device parameters payload. */
export interface ITrustDeviceRequest {
    /** The id of the device to remove before trusting the defined device. */
    swapDeviceId?: string | undefined;
}

export class UiFeaturesInfo implements IUiFeaturesInfo {
    /** Determines whether dashboard metrics should be visible. */
    metricsEnabled?: boolean;
    /** Determines whether sign in logs should be visible. */
    signInLogsEnabled?: boolean;

    constructor(data?: IUiFeaturesInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.metricsEnabled = _data["metricsEnabled"];
            this.signInLogsEnabled = _data["signInLogsEnabled"];
        }
    }

    static fromJS(data: any): UiFeaturesInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UiFeaturesInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metricsEnabled"] = this.metricsEnabled;
        data["signInLogsEnabled"] = this.signInLogsEnabled;
        return data;
    }
}

export interface IUiFeaturesInfo {
    /** Determines whether dashboard metrics should be visible. */
    metricsEnabled?: boolean;
    /** Determines whether sign in logs should be visible. */
    signInLogsEnabled?: boolean;
}

/** Models an API resource that will be updated on the server. */
export class UpdateApiResourceRequest implements IUpdateApiResourceRequest {
    /** Display name of the resource. */
    displayName?: string | undefined;
    /** Description of the resource. */
    description?: string | undefined;
    /** Specifies whether the resource is enabled. */
    enabled?: boolean;

    constructor(data?: IUpdateApiResourceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.enabled = _data["enabled"];
        }
    }

    static fromJS(data: any): UpdateApiResourceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApiResourceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["enabled"] = this.enabled;
        return data;
    }
}

/** Models an API resource that will be updated on the server. */
export interface IUpdateApiResourceRequest {
    /** Display name of the resource. */
    displayName?: string | undefined;
    /** Description of the resource. */
    description?: string | undefined;
    /** Specifies whether the resource is enabled. */
    enabled?: boolean;
}

/** Models an API scope that will be updated on the server. */
export class UpdateApiScopeRequest implements IUpdateApiScopeRequest {
    /** Display name of the resource. */
    displayName?: string | undefined;
    /** Description of the resource. */
    description?: string | undefined;
    /** Determines whether this scope is required or not. */
    required?: boolean;
    /** Determines whether this scope should be displayed emphasized or not. */
    emphasize?: boolean;
    /** Determines whether this scope should be displayed in the discovery document or not. */
    showInDiscoveryDocument?: boolean;
    /** Translations. */
    translations?: { [key: string]: ApiScopeTranslation; } | undefined;

    constructor(data?: IUpdateApiScopeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.required = _data["required"];
            this.emphasize = _data["emphasize"];
            this.showInDiscoveryDocument = _data["showInDiscoveryDocument"];
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? ApiScopeTranslation.fromJS(_data["translations"][key]) : new ApiScopeTranslation();
                }
            }
        }
    }

    static fromJS(data: any): UpdateApiScopeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApiScopeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["required"] = this.required;
        data["emphasize"] = this.emphasize;
        data["showInDiscoveryDocument"] = this.showInDiscoveryDocument;
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Models an API scope that will be updated on the server. */
export interface IUpdateApiScopeRequest {
    /** Display name of the resource. */
    displayName?: string | undefined;
    /** Description of the resource. */
    description?: string | undefined;
    /** Determines whether this scope is required or not. */
    required?: boolean;
    /** Determines whether this scope should be displayed emphasized or not. */
    emphasize?: boolean;
    /** Determines whether this scope should be displayed in the discovery document or not. */
    showInDiscoveryDocument?: boolean;
    /** Translations. */
    translations?: { [key: string]: ApiScopeTranslation; } | undefined;
}

/** Models an application setting that will be updated on the server. */
export class UpdateAppSettingRequest implements IUpdateAppSettingRequest {
    /** The value of application setting. */
    value!: string;

    constructor(data?: IUpdateAppSettingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateAppSettingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAppSettingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

/** Models an application setting that will be updated on the server. */
export interface IUpdateAppSettingRequest {
    /** The value of application setting. */
    value: string;
}

/** Models a claim type that will be updated on the server. */
export class UpdateClaimTypeRequest implements IUpdateClaimTypeRequest {
    /** The name used for display purposes. */
    displayName?: string | undefined;
    /** A description. */
    description?: string | undefined;
    /** Determines whether this claim is required to create new users. */
    required?: boolean;
    /** Determines whether this claim will be editable by a user if exposed through a public API. */
    userEditable?: boolean;
    /** A regex rule that constraints the values of the claim. */
    rule?: string | undefined;
    valueType?: ClaimValueType;

    constructor(data?: IUpdateClaimTypeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.required = _data["required"];
            this.userEditable = _data["userEditable"];
            this.rule = _data["rule"];
            this.valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): UpdateClaimTypeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClaimTypeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["required"] = this.required;
        data["userEditable"] = this.userEditable;
        data["rule"] = this.rule;
        data["valueType"] = this.valueType;
        return data;
    }
}

/** Models a claim type that will be updated on the server. */
export interface IUpdateClaimTypeRequest {
    /** The name used for display purposes. */
    displayName?: string | undefined;
    /** A description. */
    description?: string | undefined;
    /** Determines whether this claim is required to create new users. */
    required?: boolean;
    /** Determines whether this claim will be editable by a user if exposed through a public API. */
    userEditable?: boolean;
    /** A regex rule that constraints the values of the claim. */
    rule?: string | undefined;
    valueType?: ClaimValueType;
}

/** Models a client that will be updated on the server. */
export class UpdateClientRequest implements IUpdateClientRequest {
    /** Application name that will be seen on consent screens. */
    clientName?: string | undefined;
    /** Application URL that will be seen on consent screens. */
    clientUri?: string | undefined;
    /** Application logo that will be seen on consent screens. */
    logoUri?: string | undefined;
    /** Application description. */
    description?: string | undefined;
    /** Specifies whether a consent screen is required. */
    requireConsent?: boolean;
    /** Translations. */
    translations?: { [key: string]: ClientTranslation; } | undefined;
    /** Lifetime of identity token in seconds. */
    identityTokenLifetime?: number;
    /** Lifetime of access token in seconds */
    accessTokenLifetime?: number;
    /** Maximum lifetime of a refresh token in seconds. */
    absoluteRefreshTokenLifetime?: number;
    /** Lifetime of a user consent in seconds. */
    consentLifetime?: number | undefined;
    /** Gets or sets a value indicating whether to allow offline access. */
    allowOfflineAccess?: boolean;
    /** The maximum duration (in seconds) since the last time the user authenticated. */
    userSsoLifetime?: number | undefined;
    /** Specifies logout URI at client for HTTP front-channel based logout. */
    frontChannelLogoutUri?: string | undefined;
    /** Gets or sets a salt value used in pair-wise subjectId generation for users of this client. */
    pairWiseSubjectSalt?: string | undefined;
    /** Gets or sets a value indicating whether the access token (and its claims) should be updated on a refresh token request. */
    updateAccessTokenClaimsOnRefresh?: boolean;
    /** Specifies logout URI at client for HTTP back-channel based logout. */
    backChannelLogoutUri?: string | undefined;
    /** Specifies is the user's session id should be sent to the BackChannelLogoutUri. */
    backChannelLogoutSessionRequired?: boolean;
    accessTokenType?: AccessTokenType;
    refreshTokenExpiration?: TokenExpiration;
    refreshTokenUsage?: TokenUsage;
    /** Specifies is the user's session id should be sent to the FrontChannelLogoutUri. */
    frontChannelLogoutSessionRequired?: boolean;
    /** Gets or sets a value indicating whether JWT access tokens should include an identifier. */
    includeJwtId?: boolean;
    /** Controls whether access tokens are transmitted via the browser for this client. This can prevent accidental leakage of access tokens when multiple response types are allowed. */
    allowAccessTokensViaBrowser?: boolean;
    /** When requesting both an id token and access token, should the user claims always be added to the id token instead of requring the client to use the userinfo endpoint. */
    alwaysIncludeUserClaimsInIdToken?: boolean;
    /** Gets or sets a value indicating whether client claims should be always included in the access tokens - or only for client credentials flow. */
    alwaysSendClientClaims?: boolean;
    /** Lifetime of authorization code in seconds. */
    authorizationCodeLifetime?: number;
    /** Specifies whether a proof key is required for authorization code based token requests. */
    requirePkce?: boolean;
    /** Specifies whether a proof key can be sent using plain method. */
    allowPlainTextPkce?: boolean;
    /** Gets or sets a value to prefix it on client claim types. */
    clientClaimsPrefix?: string | undefined;
    /** Specifies whether consent screen is remembered after having been given. */
    allowRememberConsent?: boolean;
    /** Gets or sets the type of the device flow user code. */
    userCodeType?: string | undefined;
    /** Gets or sets the device code lifetime. */
    deviceCodeLifetime?: number;
    /** Specifies if client is enabled. */
    enabled?: boolean;
    /** Sliding lifetime of a refresh token in seconds. Defaults to 1296000 seconds / 15 days. */
    slidingRefreshTokenLifetime?: number;
    /** Determines whether login using a local account is allowed for this client. */
    enableLocalLogin?: boolean | undefined;
    /** List of identity providers that are not allowed for this client. */
    identityProviderRestrictions?: string[] | undefined;

    constructor(data?: IUpdateClientRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientName = _data["clientName"];
            this.clientUri = _data["clientUri"];
            this.logoUri = _data["logoUri"];
            this.description = _data["description"];
            this.requireConsent = _data["requireConsent"];
            if (_data["translations"]) {
                this.translations = {} as any;
                for (let key in _data["translations"]) {
                    if (_data["translations"].hasOwnProperty(key))
                        (<any>this.translations)![key] = _data["translations"][key] ? ClientTranslation.fromJS(_data["translations"][key]) : new ClientTranslation();
                }
            }
            this.identityTokenLifetime = _data["identityTokenLifetime"];
            this.accessTokenLifetime = _data["accessTokenLifetime"];
            this.absoluteRefreshTokenLifetime = _data["absoluteRefreshTokenLifetime"];
            this.consentLifetime = _data["consentLifetime"];
            this.allowOfflineAccess = _data["allowOfflineAccess"];
            this.userSsoLifetime = _data["userSsoLifetime"];
            this.frontChannelLogoutUri = _data["frontChannelLogoutUri"];
            this.pairWiseSubjectSalt = _data["pairWiseSubjectSalt"];
            this.updateAccessTokenClaimsOnRefresh = _data["updateAccessTokenClaimsOnRefresh"];
            this.backChannelLogoutUri = _data["backChannelLogoutUri"];
            this.backChannelLogoutSessionRequired = _data["backChannelLogoutSessionRequired"];
            this.accessTokenType = _data["accessTokenType"];
            this.refreshTokenExpiration = _data["refreshTokenExpiration"];
            this.refreshTokenUsage = _data["refreshTokenUsage"];
            this.frontChannelLogoutSessionRequired = _data["frontChannelLogoutSessionRequired"];
            this.includeJwtId = _data["includeJwtId"];
            this.allowAccessTokensViaBrowser = _data["allowAccessTokensViaBrowser"];
            this.alwaysIncludeUserClaimsInIdToken = _data["alwaysIncludeUserClaimsInIdToken"];
            this.alwaysSendClientClaims = _data["alwaysSendClientClaims"];
            this.authorizationCodeLifetime = _data["authorizationCodeLifetime"];
            this.requirePkce = _data["requirePkce"];
            this.allowPlainTextPkce = _data["allowPlainTextPkce"];
            this.clientClaimsPrefix = _data["clientClaimsPrefix"];
            this.allowRememberConsent = _data["allowRememberConsent"];
            this.userCodeType = _data["userCodeType"];
            this.deviceCodeLifetime = _data["deviceCodeLifetime"];
            this.enabled = _data["enabled"];
            this.slidingRefreshTokenLifetime = _data["slidingRefreshTokenLifetime"];
            this.enableLocalLogin = _data["enableLocalLogin"];
            if (Array.isArray(_data["identityProviderRestrictions"])) {
                this.identityProviderRestrictions = [] as any;
                for (let item of _data["identityProviderRestrictions"])
                    this.identityProviderRestrictions!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateClientRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientName"] = this.clientName;
        data["clientUri"] = this.clientUri;
        data["logoUri"] = this.logoUri;
        data["description"] = this.description;
        data["requireConsent"] = this.requireConsent;
        if (this.translations) {
            data["translations"] = {};
            for (let key in this.translations) {
                if (this.translations.hasOwnProperty(key))
                    (<any>data["translations"])[key] = this.translations[key] ? this.translations[key].toJSON() : <any>undefined;
            }
        }
        data["identityTokenLifetime"] = this.identityTokenLifetime;
        data["accessTokenLifetime"] = this.accessTokenLifetime;
        data["absoluteRefreshTokenLifetime"] = this.absoluteRefreshTokenLifetime;
        data["consentLifetime"] = this.consentLifetime;
        data["allowOfflineAccess"] = this.allowOfflineAccess;
        data["userSsoLifetime"] = this.userSsoLifetime;
        data["frontChannelLogoutUri"] = this.frontChannelLogoutUri;
        data["pairWiseSubjectSalt"] = this.pairWiseSubjectSalt;
        data["updateAccessTokenClaimsOnRefresh"] = this.updateAccessTokenClaimsOnRefresh;
        data["backChannelLogoutUri"] = this.backChannelLogoutUri;
        data["backChannelLogoutSessionRequired"] = this.backChannelLogoutSessionRequired;
        data["accessTokenType"] = this.accessTokenType;
        data["refreshTokenExpiration"] = this.refreshTokenExpiration;
        data["refreshTokenUsage"] = this.refreshTokenUsage;
        data["frontChannelLogoutSessionRequired"] = this.frontChannelLogoutSessionRequired;
        data["includeJwtId"] = this.includeJwtId;
        data["allowAccessTokensViaBrowser"] = this.allowAccessTokensViaBrowser;
        data["alwaysIncludeUserClaimsInIdToken"] = this.alwaysIncludeUserClaimsInIdToken;
        data["alwaysSendClientClaims"] = this.alwaysSendClientClaims;
        data["authorizationCodeLifetime"] = this.authorizationCodeLifetime;
        data["requirePkce"] = this.requirePkce;
        data["allowPlainTextPkce"] = this.allowPlainTextPkce;
        data["clientClaimsPrefix"] = this.clientClaimsPrefix;
        data["allowRememberConsent"] = this.allowRememberConsent;
        data["userCodeType"] = this.userCodeType;
        data["deviceCodeLifetime"] = this.deviceCodeLifetime;
        data["enabled"] = this.enabled;
        data["slidingRefreshTokenLifetime"] = this.slidingRefreshTokenLifetime;
        data["enableLocalLogin"] = this.enableLocalLogin;
        if (Array.isArray(this.identityProviderRestrictions)) {
            data["identityProviderRestrictions"] = [];
            for (let item of this.identityProviderRestrictions)
                data["identityProviderRestrictions"].push(item);
        }
        return data;
    }
}

/** Models a client that will be updated on the server. */
export interface IUpdateClientRequest {
    /** Application name that will be seen on consent screens. */
    clientName?: string | undefined;
    /** Application URL that will be seen on consent screens. */
    clientUri?: string | undefined;
    /** Application logo that will be seen on consent screens. */
    logoUri?: string | undefined;
    /** Application description. */
    description?: string | undefined;
    /** Specifies whether a consent screen is required. */
    requireConsent?: boolean;
    /** Translations. */
    translations?: { [key: string]: ClientTranslation; } | undefined;
    /** Lifetime of identity token in seconds. */
    identityTokenLifetime?: number;
    /** Lifetime of access token in seconds */
    accessTokenLifetime?: number;
    /** Maximum lifetime of a refresh token in seconds. */
    absoluteRefreshTokenLifetime?: number;
    /** Lifetime of a user consent in seconds. */
    consentLifetime?: number | undefined;
    /** Gets or sets a value indicating whether to allow offline access. */
    allowOfflineAccess?: boolean;
    /** The maximum duration (in seconds) since the last time the user authenticated. */
    userSsoLifetime?: number | undefined;
    /** Specifies logout URI at client for HTTP front-channel based logout. */
    frontChannelLogoutUri?: string | undefined;
    /** Gets or sets a salt value used in pair-wise subjectId generation for users of this client. */
    pairWiseSubjectSalt?: string | undefined;
    /** Gets or sets a value indicating whether the access token (and its claims) should be updated on a refresh token request. */
    updateAccessTokenClaimsOnRefresh?: boolean;
    /** Specifies logout URI at client for HTTP back-channel based logout. */
    backChannelLogoutUri?: string | undefined;
    /** Specifies is the user's session id should be sent to the BackChannelLogoutUri. */
    backChannelLogoutSessionRequired?: boolean;
    accessTokenType?: AccessTokenType;
    refreshTokenExpiration?: TokenExpiration;
    refreshTokenUsage?: TokenUsage;
    /** Specifies is the user's session id should be sent to the FrontChannelLogoutUri. */
    frontChannelLogoutSessionRequired?: boolean;
    /** Gets or sets a value indicating whether JWT access tokens should include an identifier. */
    includeJwtId?: boolean;
    /** Controls whether access tokens are transmitted via the browser for this client. This can prevent accidental leakage of access tokens when multiple response types are allowed. */
    allowAccessTokensViaBrowser?: boolean;
    /** When requesting both an id token and access token, should the user claims always be added to the id token instead of requring the client to use the userinfo endpoint. */
    alwaysIncludeUserClaimsInIdToken?: boolean;
    /** Gets or sets a value indicating whether client claims should be always included in the access tokens - or only for client credentials flow. */
    alwaysSendClientClaims?: boolean;
    /** Lifetime of authorization code in seconds. */
    authorizationCodeLifetime?: number;
    /** Specifies whether a proof key is required for authorization code based token requests. */
    requirePkce?: boolean;
    /** Specifies whether a proof key can be sent using plain method. */
    allowPlainTextPkce?: boolean;
    /** Gets or sets a value to prefix it on client claim types. */
    clientClaimsPrefix?: string | undefined;
    /** Specifies whether consent screen is remembered after having been given. */
    allowRememberConsent?: boolean;
    /** Gets or sets the type of the device flow user code. */
    userCodeType?: string | undefined;
    /** Gets or sets the device code lifetime. */
    deviceCodeLifetime?: number;
    /** Specifies if client is enabled. */
    enabled?: boolean;
    /** Sliding lifetime of a refresh token in seconds. Defaults to 1296000 seconds / 15 days. */
    slidingRefreshTokenLifetime?: number;
    /** Determines whether login using a local account is allowed for this client. */
    enableLocalLogin?: boolean | undefined;
    /** List of identity providers that are not allowed for this client. */
    identityProviderRestrictions?: string[] | undefined;
}

/** Defines the model required to update client URLs. */
export class UpdateClientUrls implements IUpdateClientUrls {
    /** Cors origins allowed. */
    allowedCorsOrigins?: string[] | undefined;
    /** Allowed URIs to redirect after logout. */
    postLogoutRedirectUris?: string[] | undefined;
    /** Allowed URIs to redirect after successful login. */
    redirectUris?: string[] | undefined;

    constructor(data?: IUpdateClientUrls) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["allowedCorsOrigins"])) {
                this.allowedCorsOrigins = [] as any;
                for (let item of _data["allowedCorsOrigins"])
                    this.allowedCorsOrigins!.push(item);
            }
            if (Array.isArray(_data["postLogoutRedirectUris"])) {
                this.postLogoutRedirectUris = [] as any;
                for (let item of _data["postLogoutRedirectUris"])
                    this.postLogoutRedirectUris!.push(item);
            }
            if (Array.isArray(_data["redirectUris"])) {
                this.redirectUris = [] as any;
                for (let item of _data["redirectUris"])
                    this.redirectUris!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateClientUrls {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientUrls();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allowedCorsOrigins)) {
            data["allowedCorsOrigins"] = [];
            for (let item of this.allowedCorsOrigins)
                data["allowedCorsOrigins"].push(item);
        }
        if (Array.isArray(this.postLogoutRedirectUris)) {
            data["postLogoutRedirectUris"] = [];
            for (let item of this.postLogoutRedirectUris)
                data["postLogoutRedirectUris"].push(item);
        }
        if (Array.isArray(this.redirectUris)) {
            data["redirectUris"] = [];
            for (let item of this.redirectUris)
                data["redirectUris"].push(item);
        }
        return data;
    }
}

/** Defines the model required to update client URLs. */
export interface IUpdateClientUrls {
    /** Cors origins allowed. */
    allowedCorsOrigins?: string[] | undefined;
    /** Allowed URIs to redirect after logout. */
    postLogoutRedirectUris?: string[] | undefined;
    /** Allowed URIs to redirect after successful login. */
    redirectUris?: string[] | undefined;
}

/** Update an existing user device model. */
export class UpdateDeviceRequest implements IUpdateDeviceRequest {
    /** Device name. */
    name?: string | undefined;
    /** Tags are used to route notifications to the correct set of device handles. */
    tags?: string[] | undefined;
    /** Platform Notification Service (PNS) obtained from client platform. */
    pnsHandle?: string | undefined;
    /** Device model. */
    model?: string | undefined;
    /** Device OS version. */
    osVersion?: string | undefined;
    /** Extra metadata for the device. */
    data?: any | undefined;

    constructor(data?: IUpdateDeviceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.pnsHandle = _data["pnsHandle"];
            this.model = _data["model"];
            this.osVersion = _data["osVersion"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): UpdateDeviceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDeviceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["pnsHandle"] = this.pnsHandle;
        data["model"] = this.model;
        data["osVersion"] = this.osVersion;
        data["data"] = this.data;
        return data;
    }
}

/** Update an existing user device model. */
export interface IUpdateDeviceRequest {
    /** Device name. */
    name?: string | undefined;
    /** Tags are used to route notifications to the correct set of device handles. */
    tags?: string[] | undefined;
    /** Platform Notification Service (PNS) obtained from client platform. */
    pnsHandle?: string | undefined;
    /** Device model. */
    model?: string | undefined;
    /** Device OS version. */
    osVersion?: string | undefined;
    /** Extra metadata for the device. */
    data?: any | undefined;
}

/** Models an identity resource that will be updated on the server. */
export class UpdateIdentityResourceRequest implements IUpdateIdentityResourceRequest {
    /** Display name of the resource. */
    displayName?: string | undefined;
    /** Description of the resource. */
    description?: string | undefined;
    /** Specifies whether the resource is enabled. */
    enabled?: boolean;
    /** Determines whether this resource should be displayed emphasized or not. */
    emphasize?: boolean;
    /** Determines whether this resource is required or not. */
    required?: boolean;
    /** Determines whether this scope should be displayed in the discovery document or not. */
    showInDiscoveryDocument?: boolean;

    constructor(data?: IUpdateIdentityResourceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.enabled = _data["enabled"];
            this.emphasize = _data["emphasize"];
            this.required = _data["required"];
            this.showInDiscoveryDocument = _data["showInDiscoveryDocument"];
        }
    }

    static fromJS(data: any): UpdateIdentityResourceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateIdentityResourceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["enabled"] = this.enabled;
        data["emphasize"] = this.emphasize;
        data["required"] = this.required;
        data["showInDiscoveryDocument"] = this.showInDiscoveryDocument;
        return data;
    }
}

/** Models an identity resource that will be updated on the server. */
export interface IUpdateIdentityResourceRequest {
    /** Display name of the resource. */
    displayName?: string | undefined;
    /** Description of the resource. */
    description?: string | undefined;
    /** Specifies whether the resource is enabled. */
    enabled?: boolean;
    /** Determines whether this resource should be displayed emphasized or not. */
    emphasize?: boolean;
    /** Determines whether this resource is required or not. */
    required?: boolean;
    /** Determines whether this scope should be displayed in the discovery document or not. */
    showInDiscoveryDocument?: boolean;
}

/** Models the request to update the max devices number for the user. */
export class UpdateMaxDevicesCountRequest implements IUpdateMaxDevicesCountRequest {
    /** The number to apply for devices count. */
    count?: number;

    constructor(data?: IUpdateMaxDevicesCountRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): UpdateMaxDevicesCountRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMaxDevicesCountRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        return data;
    }
}

/** Models the request to update the max devices number for the user. */
export interface IUpdateMaxDevicesCountRequest {
    /** The number to apply for devices count. */
    count?: number;
}

/** Models the request to update the password expiration policy for the user. */
export class UpdatePasswordExpirationPolicyRequest implements IUpdatePasswordExpirationPolicyRequest {
    policy!: PasswordExpirationPolicy;

    constructor(data?: IUpdatePasswordExpirationPolicyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.policy = _data["policy"];
        }
    }

    static fromJS(data: any): UpdatePasswordExpirationPolicyRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePasswordExpirationPolicyRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["policy"] = this.policy;
        return data;
    }
}

/** Models the request to update the password expiration policy for the user. */
export interface IUpdatePasswordExpirationPolicyRequest {
    policy: PasswordExpirationPolicy;
}

/** Models a role that will be updated on the server. */
export class UpdateRoleRequest implements IUpdateRoleRequest {
    /** A description for the role. */
    description?: string | undefined;

    constructor(data?: IUpdateRoleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateRoleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        return data;
    }
}

/** Models a role that will be updated on the server. */
export interface IUpdateRoleRequest {
    /** A description for the role. */
    description?: string | undefined;
}

/** Models a user claim that will be updated on the server. */
export class UpdateUserClaimRequest implements IUpdateUserClaimRequest {
    /** The value of the claim. */
    claimValue?: string | undefined;

    constructor(data?: IUpdateUserClaimRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): UpdateUserClaimRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserClaimRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claimValue"] = this.claimValue;
        return data;
    }
}

/** Models a user claim that will be updated on the server. */
export interface IUpdateUserClaimRequest {
    /** The value of the claim. */
    claimValue?: string | undefined;
}

/** Models the request to update the email for the user. */
export class UpdateUserEmailRequest implements IUpdateUserEmailRequest {
    /** The URL to return to. */
    returnUrl?: string | undefined;
    /** The new user email. */
    email!: string;

    constructor(data?: IUpdateUserEmailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.returnUrl = _data["returnUrl"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UpdateUserEmailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserEmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["returnUrl"] = this.returnUrl;
        data["email"] = this.email;
        return data;
    }
}

/** Models the request to update the email for the user. */
export interface IUpdateUserEmailRequest {
    /** The URL to return to. */
    returnUrl?: string | undefined;
    /** The new user email. */
    email: string;
}

/** Models a request for changing the username. */
export class UpdateUserNameRequest implements IUpdateUserNameRequest {
    /** The new username. */
    userName!: string;

    constructor(data?: IUpdateUserNameRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): UpdateUserNameRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserNameRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        return data;
    }
}

/** Models a request for changing the username. */
export interface IUpdateUserNameRequest {
    /** The new username. */
    userName: string;
}

/** Models the payload when user requests a phone number update. */
export class UpdateUserPhoneNumberRequest implements IUpdateUserPhoneNumberRequest {
    /** The phone number. */
    phoneNumber!: string;
    deliveryChannel?: string | undefined;

    constructor(data?: IUpdateUserPhoneNumberRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
            this.deliveryChannel = _data["deliveryChannel"];
        }
    }

    static fromJS(data: any): UpdateUserPhoneNumberRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPhoneNumberRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        data["deliveryChannel"] = this.deliveryChannel;
        return data;
    }
}

/** Models the payload when user requests a phone number update. */
export interface IUpdateUserPhoneNumberRequest {
    /** The phone number. */
    phoneNumber: string;
    deliveryChannel?: string | undefined;
}

/** Models a user that will be updated on the server. */
export class UpdateUserRequest implements IUpdateUserRequest {
    /** Indicates whether two-factor authentication is enabled for the user. */
    twoFactorEnabled?: boolean;
    /** User's email address. */
    email?: string | undefined;
    /** User's phone number. */
    phoneNumber?: string | undefined;
    /** The username. */
    userName?: string | undefined;
    /** Dynamic claims that have been marked as required. */
    claims?: BasicClaimInfo[] | undefined;
    passwordExpirationPolicy?: PasswordExpirationPolicy;
    /** Indicates whether the user is a system administrator. */
    isAdmin?: boolean;
    /** Indicates whether a user's email is confirmed or not. */
    emailConfirmed?: boolean;
    /** Indicates whether a user's phone number is confirmed or not. */
    phoneNumberConfirmed?: boolean;
    /** Flag indicating if we need to bypass email as username policy. */
    bypassEmailAsUserNamePolicy?: boolean;

    constructor(data?: IUpdateUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.userName = _data["userName"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(BasicClaimInfo.fromJS(item));
            }
            this.passwordExpirationPolicy = _data["passwordExpirationPolicy"];
            this.isAdmin = _data["isAdmin"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.bypassEmailAsUserNamePolicy = _data["bypassEmailAsUserNamePolicy"];
        }
    }

    static fromJS(data: any): UpdateUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["userName"] = this.userName;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["passwordExpirationPolicy"] = this.passwordExpirationPolicy;
        data["isAdmin"] = this.isAdmin;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["bypassEmailAsUserNamePolicy"] = this.bypassEmailAsUserNamePolicy;
        return data;
    }
}

/** Models a user that will be updated on the server. */
export interface IUpdateUserRequest {
    /** Indicates whether two-factor authentication is enabled for the user. */
    twoFactorEnabled?: boolean;
    /** User's email address. */
    email?: string | undefined;
    /** User's phone number. */
    phoneNumber?: string | undefined;
    /** The username. */
    userName?: string | undefined;
    /** Dynamic claims that have been marked as required. */
    claims?: BasicClaimInfo[] | undefined;
    passwordExpirationPolicy?: PasswordExpirationPolicy;
    /** Indicates whether the user is a system administrator. */
    isAdmin?: boolean;
    /** Indicates whether a user's email is confirmed or not. */
    emailConfirmed?: boolean;
    /** Indicates whether a user's phone number is confirmed or not. */
    phoneNumberConfirmed?: boolean;
    /** Flag indicating if we need to bypass email as username policy. */
    bypassEmailAsUserNamePolicy?: boolean;
}

/** Models a system client that a user has given consent to or currently has IdentityServer side tokens for. */
export class UserClientInfo implements IUserClientInfo {
    /** The unique identifier for this application. */
    clientId?: string | undefined;
    /** Application name that will be seen on consent screens. */
    clientName?: string | undefined;
    /** Application description. */
    description?: string | undefined;
    /** Determines whether this application is enabled or not. */
    enabled?: boolean | undefined;
    /** Specifies whether a consent screen is required. */
    requireConsent?: boolean | undefined;
    /** Specifies whether consent screen is remembered after having been given. */
    allowRememberConsent?: boolean | undefined;
    /** Application logo that will be seen on consent screens. */
    logoUri?: string | undefined;
    /** Application URL that will be seen on consent screens. */
    clientUri?: string | undefined;
    /** Specifies whether the client can be edited or not. */
    nonEditable?: boolean;
    /** Creation of grant. */
    createdAt?: Date;
    /** Expiration of grant. */
    expiresAt?: Date | undefined;
    /** Resources/scopes accessible by the application. */
    scopes?: string[] | undefined;

    constructor(data?: IUserClientInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.description = _data["description"];
            this.enabled = _data["enabled"];
            this.requireConsent = _data["requireConsent"];
            this.allowRememberConsent = _data["allowRememberConsent"];
            this.logoUri = _data["logoUri"];
            this.clientUri = _data["clientUri"];
            this.nonEditable = _data["nonEditable"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
        }
    }

    static fromJS(data: any): UserClientInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserClientInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["description"] = this.description;
        data["enabled"] = this.enabled;
        data["requireConsent"] = this.requireConsent;
        data["allowRememberConsent"] = this.allowRememberConsent;
        data["logoUri"] = this.logoUri;
        data["clientUri"] = this.clientUri;
        data["nonEditable"] = this.nonEditable;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        return data;
    }
}

/** Models a system client that a user has given consent to or currently has IdentityServer side tokens for. */
export interface IUserClientInfo {
    /** The unique identifier for this application. */
    clientId?: string | undefined;
    /** Application name that will be seen on consent screens. */
    clientName?: string | undefined;
    /** Application description. */
    description?: string | undefined;
    /** Determines whether this application is enabled or not. */
    enabled?: boolean | undefined;
    /** Specifies whether a consent screen is required. */
    requireConsent?: boolean | undefined;
    /** Specifies whether consent screen is remembered after having been given. */
    allowRememberConsent?: boolean | undefined;
    /** Application logo that will be seen on consent screens. */
    logoUri?: string | undefined;
    /** Application URL that will be seen on consent screens. */
    clientUri?: string | undefined;
    /** Specifies whether the client can be edited or not. */
    nonEditable?: boolean;
    /** Creation of grant. */
    createdAt?: Date;
    /** Expiration of grant. */
    expiresAt?: Date | undefined;
    /** Resources/scopes accessible by the application. */
    scopes?: string[] | undefined;
}

export class UserClientInfoResultSet implements IUserClientInfoResultSet {
    count?: number;
    items?: UserClientInfo[] | undefined;

    constructor(data?: IUserClientInfoResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserClientInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserClientInfoResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new UserClientInfoResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserClientInfoResultSet {
    count?: number;
    items?: UserClientInfo[] | undefined;
}

/** Models the */
export class UserConsentInfo implements IUserConsentInfo {
    /** The client id. */
    clientId?: string | undefined;
    /** Consent creation System.DateTime. */
    createdAt?: Date;
    /** Consent expiration System.DateTime. */
    expiresAt?: Date | undefined;
    /** Consent type. */
    type?: string | undefined;
    /** Associated scopes. */
    scopes?: string[] | undefined;
    /** Associated claims. */
    claims?: BasicClaimInfo[] | undefined;

    constructor(data?: IUserConsentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            this.type = _data["type"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(BasicClaimInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserConsentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserConsentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        data["type"] = this.type;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        return data;
    }
}

/** Models the */
export interface IUserConsentInfo {
    /** The client id. */
    clientId?: string | undefined;
    /** Consent creation System.DateTime. */
    createdAt?: Date;
    /** Consent expiration System.DateTime. */
    expiresAt?: Date | undefined;
    /** Consent type. */
    type?: string | undefined;
    /** Associated scopes. */
    scopes?: string[] | undefined;
    /** Associated claims. */
    claims?: BasicClaimInfo[] | undefined;
}

export class UserConsentInfoResultSet implements IUserConsentInfoResultSet {
    count?: number;
    items?: UserConsentInfo[] | undefined;

    constructor(data?: IUserConsentInfoResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserConsentInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserConsentInfoResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new UserConsentInfoResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserConsentInfoResultSet {
    count?: number;
    items?: UserConsentInfo[] | undefined;
}

/** Models an application user when retrieving a list. */
export class UserInfo implements IUserInfo {
    /** User's unique identifier. */
    id?: string | undefined;
    /** Indicates whether a user's email is confirmed or not. */
    emailConfirmed?: boolean;
    /** Indicates whether lockout feature is enabled for the user. */
    lockoutEnabled?: boolean;
    /** Indicates whether a user's phone number is confirmed or not. */
    phoneNumberConfirmed?: boolean;
    /** Indicates whether two-factor authentication is enabled for the user. */
    twoFactorEnabled?: boolean;
    /** The date-time where the user was created in the system. */
    createDate?: Date;
    /** The date-time where the lockout period ends. */
    lockoutEnd?: Date | undefined;
    /** Indicates that the user is Locked. */
    readonly isLocked?: boolean;
    /** User's email address. */
    email?: string | undefined;
    /** User's phone number. */
    phoneNumber?: string | undefined;
    /** The username. */
    userName?: string | undefined;
    /** Indicates whether the user is forcefully blocked. */
    blocked?: boolean;
    passwordExpirationPolicy?: PasswordExpirationPolicy;
    /** Indicates whether the user is a system administrator. */
    isAdmin?: boolean;
    /** The number of failed login attempts for the user. */
    accessFailedCount?: number;
    /** Gets or sets the date and time, in UTC, when the user last signed in. */
    lastSignInDate?: Date | undefined;
    /** If set, it represents the date when the current password will expire. */
    passwordExpirationDate?: Date | undefined;
    /** User's first name. */
    firstName?: string | undefined;
    /** User's last name. */
    lastName?: string | undefined;
    /** User metadata expressed as claims. */
    claims?: BasicClaimInfo[] | undefined;

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.createDate = _data["createDate"] ? new Date(_data["createDate"].toString()) : <any>undefined;
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            (<any>this).isLocked = _data["isLocked"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.userName = _data["userName"];
            this.blocked = _data["blocked"];
            this.passwordExpirationPolicy = _data["passwordExpirationPolicy"];
            this.isAdmin = _data["isAdmin"];
            this.accessFailedCount = _data["accessFailedCount"];
            this.lastSignInDate = _data["lastSignInDate"] ? new Date(_data["lastSignInDate"].toString()) : <any>undefined;
            this.passwordExpirationDate = _data["passwordExpirationDate"] ? new Date(_data["passwordExpirationDate"].toString()) : <any>undefined;
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(BasicClaimInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailConfirmed"] = this.emailConfirmed;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["createDate"] = this.createDate ? this.createDate.toISOString() : <any>undefined;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["isLocked"] = this.isLocked;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["userName"] = this.userName;
        data["blocked"] = this.blocked;
        data["passwordExpirationPolicy"] = this.passwordExpirationPolicy;
        data["isAdmin"] = this.isAdmin;
        data["accessFailedCount"] = this.accessFailedCount;
        data["lastSignInDate"] = this.lastSignInDate ? this.lastSignInDate.toISOString() : <any>undefined;
        data["passwordExpirationDate"] = this.passwordExpirationDate ? this.passwordExpirationDate.toISOString() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        return data;
    }
}

/** Models an application user when retrieving a list. */
export interface IUserInfo {
    /** User's unique identifier. */
    id?: string | undefined;
    /** Indicates whether a user's email is confirmed or not. */
    emailConfirmed?: boolean;
    /** Indicates whether lockout feature is enabled for the user. */
    lockoutEnabled?: boolean;
    /** Indicates whether a user's phone number is confirmed or not. */
    phoneNumberConfirmed?: boolean;
    /** Indicates whether two-factor authentication is enabled for the user. */
    twoFactorEnabled?: boolean;
    /** The date-time where the user was created in the system. */
    createDate?: Date;
    /** The date-time where the lockout period ends. */
    lockoutEnd?: Date | undefined;
    /** Indicates that the user is Locked. */
    isLocked?: boolean;
    /** User's email address. */
    email?: string | undefined;
    /** User's phone number. */
    phoneNumber?: string | undefined;
    /** The username. */
    userName?: string | undefined;
    /** Indicates whether the user is forcefully blocked. */
    blocked?: boolean;
    passwordExpirationPolicy?: PasswordExpirationPolicy;
    /** Indicates whether the user is a system administrator. */
    isAdmin?: boolean;
    /** The number of failed login attempts for the user. */
    accessFailedCount?: number;
    /** Gets or sets the date and time, in UTC, when the user last signed in. */
    lastSignInDate?: Date | undefined;
    /** If set, it represents the date when the current password will expire. */
    passwordExpirationDate?: Date | undefined;
    /** User's first name. */
    firstName?: string | undefined;
    /** User's last name. */
    lastName?: string | undefined;
    /** User metadata expressed as claims. */
    claims?: BasicClaimInfo[] | undefined;
}

export class UserInfoResultSet implements IUserInfoResultSet {
    count?: number;
    items?: UserInfo[] | undefined;

    constructor(data?: IUserInfoResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserInfoResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserInfoResultSet {
    count?: number;
    items?: UserInfo[] | undefined;
}

/** Models an user login provider. */
export class UserLoginProviderInfo implements IUserLoginProviderInfo {
    /** Provider name. */
    name?: string | undefined;
    /** Provider key. */
    key?: string | undefined;
    /** Provider display name. */
    displayName?: string | undefined;

    constructor(data?: IUserLoginProviderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.key = _data["key"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): UserLoginProviderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginProviderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["key"] = this.key;
        data["displayName"] = this.displayName;
        return data;
    }
}

/** Models an user login provider. */
export interface IUserLoginProviderInfo {
    /** Provider name. */
    name?: string | undefined;
    /** Provider key. */
    key?: string | undefined;
    /** Provider display name. */
    displayName?: string | undefined;
}

export class UserLoginProviderInfoResultSet implements IUserLoginProviderInfoResultSet {
    count?: number;
    items?: UserLoginProviderInfo[] | undefined;

    constructor(data?: IUserLoginProviderInfoResultSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserLoginProviderInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserLoginProviderInfoResultSet {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginProviderInfoResultSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserLoginProviderInfoResultSet {
    count?: number;
    items?: UserLoginProviderInfo[] | undefined;
}

/** Models percentage of user activity. */
export class UsersActivityInfo implements IUsersActivityInfo {
    day?: SummaryStatistic;
    week?: SummaryStatistic;
    month?: SummaryStatistic;

    constructor(data?: IUsersActivityInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.day = _data["day"] ? SummaryStatistic.fromJS(_data["day"]) : <any>undefined;
            this.week = _data["week"] ? SummaryStatistic.fromJS(_data["week"]) : <any>undefined;
            this.month = _data["month"] ? SummaryStatistic.fromJS(_data["month"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UsersActivityInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UsersActivityInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["day"] = this.day ? this.day.toJSON() : <any>undefined;
        data["week"] = this.week ? this.week.toJSON() : <any>undefined;
        data["month"] = this.month ? this.month.toJSON() : <any>undefined;
        return data;
    }
}

/** Models percentage of user activity. */
export interface IUsersActivityInfo {
    day?: SummaryStatistic;
    week?: SummaryStatistic;
    month?: SummaryStatistic;
}

/** Models various user statistics. */
export class UsersStatisticsInfo implements IUsersStatisticsInfo {
    emailsVerified?: SummaryStatistic;
    phoneNumbersVerified?: SummaryStatistic;

    constructor(data?: IUsersStatisticsInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailsVerified = _data["emailsVerified"] ? SummaryStatistic.fromJS(_data["emailsVerified"]) : <any>undefined;
            this.phoneNumbersVerified = _data["phoneNumbersVerified"] ? SummaryStatistic.fromJS(_data["phoneNumbersVerified"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UsersStatisticsInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UsersStatisticsInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailsVerified"] = this.emailsVerified ? this.emailsVerified.toJSON() : <any>undefined;
        data["phoneNumbersVerified"] = this.phoneNumbersVerified ? this.phoneNumbersVerified.toJSON() : <any>undefined;
        return data;
    }
}

/** Models various user statistics. */
export interface IUsersStatisticsInfo {
    emailsVerified?: SummaryStatistic;
    phoneNumbersVerified?: SummaryStatistic;
}

/** Class that models the request for validating a user's password. */
export class ValidatePasswordRequest implements IValidatePasswordRequest {
    /** A token representing the user id. */
    token?: string | undefined;
    /** The password. */
    password?: string | undefined;
    /** The username. */
    userName?: string | undefined;

    constructor(data?: IValidatePasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.password = _data["password"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): ValidatePasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ValidatePasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["password"] = this.password;
        data["userName"] = this.userName;
        return data;
    }
}

/** Class that models the request for validating a user's password. */
export interface IValidatePasswordRequest {
    /** A token representing the user id. */
    token?: string | undefined;
    /** The password. */
    password?: string | undefined;
    /** The username. */
    userName?: string | undefined;
}

/** Class that models the request for validating a user's username. */
export class ValidateUserNameRequest implements IValidateUserNameRequest {
    /** The username. */
    userName!: string;

    constructor(data?: IValidateUserNameRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): ValidateUserNameRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ValidateUserNameRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        return data;
    }
}

/** Class that models the request for validating a user's username. */
export interface IValidateUserNameRequest {
    /** The username. */
    userName: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}